<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Nginx 静态资源部署"><meta name="keywords" content="后端,Nginx,中间件"><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Nginx 静态资源部署 | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-静态资源部署"><span class="toc-number">1.</span> <span class="toc-text">Nginx 静态资源部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx静态资源概述"><span class="toc-number">1.1.</span> <span class="toc-text">Nginx静态资源概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态资源指令配置"><span class="toc-number">1.2.</span> <span class="toc-text">静态资源指令配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#listen指令"><span class="toc-number">1.2.1.</span> <span class="toc-text">listen指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server-name指令"><span class="toc-number">1.2.2.</span> <span class="toc-text">server_name指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配执行顺序"><span class="toc-number">1.2.3.</span> <span class="toc-text">匹配执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location指令"><span class="toc-number">1.2.4.</span> <span class="toc-text">location指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#root-alias指令"><span class="toc-number">1.2.5.</span> <span class="toc-text">root/alias指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index指令"><span class="toc-number">1.2.6.</span> <span class="toc-text">index指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-page指令"><span class="toc-number">1.2.7.</span> <span class="toc-text">error_page指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态资源优化配置"><span class="toc-number">1.3.</span> <span class="toc-text">静态资源优化配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sendﬁle"><span class="toc-number">1.3.1.</span> <span class="toc-text">sendﬁle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nopush"><span class="toc-number">1.3.2.</span> <span class="toc-text">tcp_nopush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nodelay"><span class="toc-number">1.3.3.</span> <span class="toc-text">tcp_nodelay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化总结"><span class="toc-number">1.3.4.</span> <span class="toc-text">优化总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态资源压缩配置"><span class="toc-number">1.4.</span> <span class="toc-text">静态资源压缩配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip模块配置指令"><span class="toc-number">1.4.1.</span> <span class="toc-text">Gzip模块配置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip压缩功能配置模板"><span class="toc-number">1.4.2.</span> <span class="toc-text">Gzip压缩功能配置模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip和sendfile共存问题"><span class="toc-number">1.4.3.</span> <span class="toc-text">Gzip和sendfile共存问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-static指令"><span class="toc-number">1.4.4.</span> <span class="toc-text">gzip_static指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx模块添加"><span class="toc-number">1.4.5.</span> <span class="toc-text">Nginx模块添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-static测试"><span class="toc-number">1.4.6.</span> <span class="toc-text">gzip_static测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态资源缓存配置"><span class="toc-number">1.5.</span> <span class="toc-text">静态资源缓存配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是缓存和Web缓存"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是缓存和Web缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web缓存的种类"><span class="toc-number">1.5.2.</span> <span class="toc-text">Web缓存的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用浏览器缓存"><span class="toc-number">1.5.3.</span> <span class="toc-text">为什么要用浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器缓存执行流程"><span class="toc-number">1.5.4.</span> <span class="toc-text">浏览器缓存执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器缓存相关指令"><span class="toc-number">1.5.5.</span> <span class="toc-text">浏览器缓存相关指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#expires指令"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">expires指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-header指令"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">add_header指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx服务端缓存"><span class="toc-number">1.5.6.</span> <span class="toc-text">Nginx服务端缓存</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">225</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">46</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Nginx 静态资源部署</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Nginx/">Nginx</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 30 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-静态资源部署"><a href="#Nginx-静态资源部署" class="headerlink" title="Nginx 静态资源部署"></a>Nginx 静态资源部署</h1><p><strong>引言</strong></p>
<p>静态资源如何部署？本内容带你了解静态资源相关的操作和内容。</p>
<p>静态资源指令配置、静态资源优化配置、静态资源压缩配置、静态资源缓存配置。</p>
<h2 id="Nginx静态资源概述"><a href="#Nginx静态资源概述" class="headerlink" title="Nginx静态资源概述"></a>Nginx静态资源概述</h2><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个 HTTP 请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。</p>
<p>静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的 html 页面、css 文件、js 文件、图片、视频等资源；</p>
<p>动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p>
<p>Nginx 处理静态资源的内容，我们需要考虑下面这几个问题：</p>
<ul>
<li>静态资源的配置指令</li>
<li>静态资源的配置优化</li>
<li>静态资源的压缩配置指令</li>
<li>静态资源的缓存处理</li>
<li>静态资源的访问控制，包括跨域问题和防盗链问题</li>
</ul>
<h2 id="静态资源指令配置"><a href="#静态资源指令配置" class="headerlink" title="静态资源指令配置"></a>静态资源指令配置</h2><h3 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h3><p>该指令是用来配置监听端口。默认监听 80（root 启动 Nginx） 和 8000（非 root 启动 Nginx） 端口。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>listen &lt;address&gt;[:port] [default_server] …… ;<br> listen &lt;port&gt; [default_server] …… ;</td>
<td>listen *:80 | *:8000</td>
<td>server</td>
</tr>
</tbody></table>
<p><code>listen</code> 指令的设置比较灵活，我们通过几个例子来把常用的设置方式熟悉下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen 127.0.0.1:8000; <span class="comment"># listen localhost:8000 监听指定的IP和端口</span></span><br><span class="line">listen 127.0.0.1;	<span class="comment"># 监听指定IP的所有端口</span></span><br><span class="line">listen 8000;	<span class="comment"># 监听指定端口上的连接</span></span><br><span class="line">listen *:8000;	<span class="comment"># 监听指定端口上的连接</span></span><br></pre></td></tr></table></figure>

<p><code>default_server</code> 属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的 <code>address:port</code>，则会执行默认的 server。如果不指定该标识符，又没有匹配到对应的 <code>address:port</code> 时，默认使用的是第一个 server，所以第一个 server 要好好设置，建议第一个 server 就加上 <code>default_server</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'This is a error request'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问 8080 端口，它会访问第二个 server，如果第二个 server 去掉 <code>default_server</code> ，则默认访问第一个 server。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.2e5c4uo1ghlw.webp" alt="image"></p>
<h3 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h3><p>该指令用来设置虚拟主机服务名称。默认为空。</p>
<p>比如 127.0.0.1、localhost、域名[<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> | <a href="http://www.jd.com]。" target="_blank" rel="noopener">www.jd.com]。</a></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>server_name &lt;name&gt; …… ;</td>
<td>server_name “”;</td>
<td>server</td>
</tr>
</tbody></table>
<ul>
<li>name 可以提供多个中间用空格分隔。</li>
</ul>
<p>关于 server_name 的配置方式有三种，分别是：</p>
<ul>
<li>精确匹配</li>
<li>通配符匹配</li>
<li>正则表达式匹配</li>
</ul>
<blockquote>
<p><strong>配置方式一：精确匹配</strong></p>
</blockquote>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com www.bing.com;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时以 <code>www.frx.com</code> 或者 <code>www.bing.com</code> 域名进行访问，就会跳转到 Nginx 的欢迎页面，前提是你需要拥有该域名，并且该域名和 Nginx 所在的系统 IP 进行绑定。</p>
<p>所以我可以利用 hosts 文件进行「模拟」域名。</p>
<blockquote>
<p>补充小知识点</p>
</blockquote>
<p>hosts 是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联「数据库」，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 hosts 文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。</p>
<p>hosts 文件不同系统的位置：</p>
<ul>
<li>在 windows 的位置：C:\Windows\System32\drivers\etc</li>
<li>在 centos 的位置：/etc/hosts</li>
</ul>
<p>因为域名是要收取一定的费用，所以我们可以使用修改 hosts 文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code> 文件来添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 hosts 文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加内容</span></span><br><span class="line">127.0.0.1 www.frx.com</span><br><span class="line">127.0.0.1 www.bing.com</span><br></pre></td></tr></table></figure>

<ul>
<li>访问测试</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.3nbv3p1703y0.webp" alt="image"></p>
<blockquote>
<p> <strong>配置方式二：使用通配符配置</strong></p>
</blockquote>
<p>server_name 指令支持通配符 *，但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">*.frx.com</span>	<span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="comment"># www.frx.cn abc.frx.cn www.bing.cn www.frx.com</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的配置就会报错，因为 * 不能出现在域名的中间和与其他字符串联使用</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">www.*</span>.cn www.frx.c*</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  .frx.com</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.frx.com</code> 相当于 <code>*..frx.com</code> + <code>frx.com</code></p>
<blockquote>
<p><strong>配置三：使用正则表达式配置</strong></p>
</blockquote>
<p>server_name 指令可以使用正则表达式，并且使用 <code>~</code> 作为正则表达式字符串的开始标记。</p>
<p>常见的正则表达式：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配搜索字符串开始位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配搜索字符串结束位置</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单个字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符，将下一个字符标记为特殊字符</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集，与任意一个指定字符匹配</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围，匹配指定范围内的任何字符</td>
</tr>
<tr>
<td>\w</td>
<td>与以下任意字符匹配 A-Z a-z 0-9 和下划线,等效于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符匹配，等效于[0-9]</td>
</tr>
<tr>
<td>{n}</td>
<td>正好匹配 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少匹配 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配至少 n 次至多 m 次</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次，等效于{0,}</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次，等效于{1,}</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次，等效于{0,1}</td>
</tr>
</tbody></table>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ~^www\.(\w+)\.com$;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 ~ 后面不能加空格</strong>。括号代表可以在 Ngxin 配置文件内获取其中的值，如上方的 (\w+) 的内容可以用 $1 获取到参数，如果有多个括号，依次使用 $2 $3 …… 获取。</p>
<p>比如现在访问 <code>http://www.frx.com</code>，则返回 frx 到页面上，因为frx 被放在 $1 处：<code>return 200 frx</code>。</p>
<p>⚠ 这里进行说明：server_name 配置了 localhost 和配置 IP 或者域名的区别</p>
<p>localhost 是「虚拟 IP」，如果不是本机访问，而是外界访问，那么这个就是无效的，但是为什么学习阶段的时候都不改呢，因为当 Nginx 没有匹配到指定的 <code>server_name</code>，默认找到第一个 server 块，而 Nginx 默认的第一个 server 块就是 localhost，哪怕你把 localhost 改为其他的，如 hello，它也能访问。只是因为在匹配不到的情况下，默认是第一个 service 块，哪怕它确实和访问的 IP 不匹配。</p>
<p>IP 如果和域名进行了绑定，那么在 <code>server_name</code> 中，两者都可以填写，填了域名，最后也是找到 IP，只是因为域名好记住。</p>
<p>知道了区别，在生产环境上，可以给个指定的错误页面。如果匹配不上，则返回友好的提示，如第一个 server 块：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;    <span class="comment"># 匹配不上的时候，也可以填写 localhost</span></span><br><span class="line">    <span class="attribute">return</span> <span class="string">"&lt;h1&gt;不好意思，匹配不到！"</span>;</span><br><span class="line">    <span class="comment"># return 403;   # 也可以直接返回错误码</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.frxcat.fun;    <span class="comment"># 匹配域名访问</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码块只允许域名访问，而不允许 IP 访问，避免其他人把未备案的域名解析到自己的服务器 IP。</p>
<p>当然你也可以不设置错误页面。因为 Nginx 匹配不上时，直接返回它的欢迎界面。</p>
<h3 id="匹配执行顺序"><a href="#匹配执行顺序" class="headerlink" title="匹配执行顺序"></a>匹配执行顺序</h3><p>由于 server_name 指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的 server_name 匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> ~^www\.\w+\.com$;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_after_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">*.frx.com</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_before_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'exact_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> _;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'default_server not found server'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://www.kele.com</code> 的优先级：（访问完后请注释掉处理这个请求的 server）</p>
<ul>
<li>exact_success（第一个是精确匹配，然后注释掉该 server）</li>
<li>wildcard_before_success（第二个是开始匹配符，然后注释掉该 server）</li>
<li>wildcard_after_success（第三个是结尾匹配符，然后注释掉该 server）</li>
<li>regex_success（第四个是正则表达式，然后注释掉该 server）</li>
<li>default_server not found server!!（第五个是默认 server，因为前四个都注释了，所以只能走默认的 server）</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li><p>No1：准确匹配 server_name</p>
</li>
<li><p>No2：通配符在开始时匹配 server_name 成功</p>
</li>
<li><p>No3：通配符在结束时匹配 server_name 成功</p>
</li>
<li><p>No4：正则表达式匹配 server_name 成功</p>
</li>
<li><p>No5：被默认的 default_server 处理，如果没有指定默认找第一个 server</p>
</li>
</ul>
<h3 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h3><p><code>location</code> 指令是用来设置请求的 URI。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>location [ = | ~ | <del>* | ^</del> | @ ] &lt;uri&gt;{…}</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<p>uri 变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么 Nginx 服务器在搜索匹配 location 的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，<strong>如果能匹配到直接访问正则表达式的，匹配不到，就使用刚才匹配度最高（前缀最长的）的那个 location 来处理请求</strong>。</p>
<p>属性介绍:</p>
<p>不带符号，要求必须以指定模式开头，但是不要求精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下访问都是正确的</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=kele</span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>=</code> 是用于不包含正则表达式的 uri，必须与指定的模式精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> =/abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 匹配成功</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=TOM</span><br><span class="line"><span class="comment"># 匹配失败</span></span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>~</code> 是用于表示当前 uri 中包含了正则表达式，并且区分大小写</p>
<p><code>~*</code> 是用于表示当前 uri 中包含了正则表达式，但是是不区分大小写</p>
<p>换句话说，<strong>如果 uri 包含了正则表达式，需要用上述两个符号来标识</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用正则表达式，区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式，不区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~*^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>^~</code> 是用于不包含正则表达式的 uri，功能和不加符号的一致，唯一不同的是，如果请求匹配上了，那么就停止搜索其他模式了。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~/abc</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@</code> 前缀可以用来定义一个命名的 location,该 location 不处理正常的外部请求,一般用来当作标识供内部重定向使用。它们不能嵌套,也不能包含嵌套的 location。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /try &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /error &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> = <span class="variable">@name</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="variable">@name</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"<span class="variable">@name</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时访问 <code>/try</code> 或者 <code>/error</code> 都会返回 <code>@name</code>。</p>
<h3 id="root-alias指令"><a href="#root-alias指令" class="headerlink" title="root/alias指令"></a>root/alias指令</h3><ul>
<li><code>root</code> 指令是设置请求资源的根目录。默认值是 html。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>root &lt;path&gt;;</td>
<td>root html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>path 是 Nginx 服务器接收到请求以后查找资源的根目录路径。</p>
<ul>
<li><code>alias</code> 指令是用来更改 location 的 URI。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>alias &lt;path&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<ul>
<li>path 是修改后的根路径。</li>
</ul>
<p><strong>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li><p>在 <code>/usr/local/nginx/html</code> 目录下创建一个 images 目录,并在目录下放入一张图片 <code>mv.png</code> 图片。</p>
<p>然后进入配置文件，添加如下内容：</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问图片的路径为：<code>http://192.168.91.200/images/mv.png</code></p>
<ol start="2">
<li>如果把root改为alias</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次访问上述地址，页面会出现 404 的错误，查看错误日志会发现是因为地址不对，所以验证了：</p>
<ul>
<li><p>root 的处理结果是：<strong>root 路径 + location 路径</strong>，location 路径包括匹配后面的请求，即包括 /mv.png</p>
<p><code>/usr/local/nginx/html/images/mv.png</code></p>
</li>
</ul>
<ul>
<li>alias 的处理结果是：<strong>使用 alias 路径替换 location 路径</strong>，但是不会替换匹配后面的请求，即不会替换 /mv.png</li>
</ul>
<p>需要在 alias 后面路径改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求。</li>
</ol>
<p>将上述配置修改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问就会出问题，查看错误日志还是路径不对，所以需要把 alias 后面加上 /</p>
<p>小结：</p>
<ul>
<li>root 的处理结果是: root 路径 + location 路径</li>
<li>alias 的处理结果是:使用 alias 路径替换 location 路径</li>
<li>alias 是一个目录别名的定义，root 则是最上层目录的含义</li>
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求<ul>
<li><strong>alias 不支持 location 的 =</strong></li>
</ul>
</li>
</ul>
<p>这里再多言几句，alias 后指定的资源路径，Nginx 就会去这个路径下找资源，「忽略」location 本身的的请求，仅拼接 location 后面的请求。如果你想去拼接 location 本身，就用绝对路径（包括 location）的alias。</p>
<h3 id="index指令"><a href="#index指令" class="headerlink" title="index指令"></a>index指令</h3><p><code>index</code> 指令是设置网站的默认首页。默认是 index.html。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>index &lt;file&gt; …;</td>
<td>index index.html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><code>index</code> 后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会从左往右依次进行查找，找到第一个为止。</p>
<p>举例说明：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">	<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问该 location 的时候，可以通过 <code>http://ip:port/</code> 访问，地址后面如果不添加任何内容，则默认依次访问 index.html 和 index.htm，找到第一个来进行返回。</p>
<h3 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h3><p>error_page 指令是设置网站的错误页面。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>error_page &lt;code&gt; …… [=[response]] &lt;uri&gt;;</td>
<td>—</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>code 是响应码。</p>
<p><strong>当出现对应的响应 code 后，如何来处理？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li>可以指定具体跳转的地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> http://www.frx.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当页面产生 404 时，自动跳转到 <code>http://www.frx.com</code></p>
<ol start="2">
<li>可以指定重定向地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> /50x.html;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生错误页面时，重定向到 /50x.html，然后触发 location，最终访问的是 html 目录下的 50x.html 页面</p>
<ol start="3">
<li>使用 location 的 @ 符合完成错误信息展示</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> <span class="variable">@jump_to_error</span>;</span><br><span class="line">	<span class="attribute">location</span> <span class="variable">@jump_to_error</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">404</span> <span class="string">'Not Found Page...'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选项 <code>=[response]</code> 的作用是用来将相应代码更改为另外一个，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">200</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，当返回 404 找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是 200 而不是 404，这块需要注意下，编写 error_page 后面的内容，404 后面需要加空格，200 前面不能加空格。</p>
<h2 id="静态资源优化配置"><a href="#静态资源优化配置" class="headerlink" title="静态资源优化配置"></a>静态资源优化配置</h2><p>Nginx 对静态资源如何进行优化配置。这里从三个属性配置进行优化：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodeplay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>建议三个都开启。如果想知道为什么，请往下看。</p>
<h3 id="sendﬁle"><a href="#sendﬁle" class="headerlink" title="sendﬁle"></a>sendﬁle</h3><p>该指令是用来开启高效的文件传输模式。默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>sendﬁle &lt;on | off&gt;;</td>
<td>sendﬁle oﬀ;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>请求静态资源的过程：客户端通过网络接口向服务端发送请求，操作系统将这些客户端的请求传递给服务器端应用程序，服务器端应用程序会处理这些请求，请求处理完成以后，操作系统还需要将处理得到的结果通过网络适配器传递回去。</p>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost；</span><br><span class="line">	location / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在 html 目录下有一个 welcome.html 页面，访问地址：<code>http://192.168.91.200/welcome.html</code>。</p>
<p>流程如下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.24hrbukvg0lc.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.5l2efa1uqlo0.webp" alt="image"></p>
<h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h3><p>该指令必须在 sendfile 打开的状态下才会生效，主要是用来提升网络包的传输「效率」。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nopush &lt;on | off&gt;;</td>
<td>tcp_nopush oﬀ;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a>tcp_nodelay</h3><p>该指令必须在 keep-alive 连接开启的情况下才生效，来提高网络包传输的「实时性」。默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nodelay &lt;on | off&gt;;</td>
<td>tcp_nodelay on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.1iu7wmocw0ao.webp" alt="image"></p>
<p><code>tcp_nopush</code> 就像大巴车，等所有旅客占满了座位，才开始发车到景点（客户端），而 <code>tcp_nodelay</code>，上来一个旅客，就马上发车到景点客户端）。</p>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>经过分析，『 tcp_nopush 』和『 tcp_nodelay 』看起来是「互斥的」，那么为什么要将这两个值都打开，这个大家需要知道的是在 Linux2.5.9 以后的版本中两者是可以兼容的，三个指令都开启的好处是，sendfile 可以开启高效的文件传输模式，『 tcp_nopush 』开启可以确保在发送到客户端之前数据包已经充分「填满」，这大大减少了网络开销，并加快了文件发送的速度。然后，当它到达最后一个可能因为没有「填满」而暂停的数据包时，Nginx 会忽略『 tcp_nopush 』参数， 然后，『 tcp_nodelay 』强制套接字发送数据。由此可知，『 tcp_nopush 』可以与『 tcp_nodelay 』一起设置，它比单独配置『 tcp_nodelay 』具有更强的性能。</p>
<p>所以回归开头，我们可以使用如下配置来优化 Nginx 静态资源的处理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个都开启</span></span><br><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<h2 id="静态资源压缩配置"><a href="#静态资源压缩配置" class="headerlink" title="静态资源压缩配置"></a>静态资源压缩配置</h2><p>经过上述内容的优化，我们再次思考一个问题，假如在满足上述优化的前提下，我们传送一个 1M 的数据和一个 10M 的数据那个效率高？答案显而易见，<strong>传输内容小，速度就会快</strong>。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是「压缩」，接下来，我们来学习 Nginx 的静态资源压缩模块。</p>
<p>在 Nginx 的配置文件中可以通过配置 gzip 来对静态资源进行压缩，相关的指令可以配置在 http 块、server 块和 location 块中，Nginx 可以通过对这些指令进行解析和处理：</p>
<ul>
<li><code>ngx_http_gzip_module</code> 模块</li>
<li><code>ngx_http_gzip_static_module</code> 模块</li>
<li><code>ngx_http_gunzip_module</code> 模块</li>
</ul>
<p>接下来我们从以下内容进行学习：</p>
<ul>
<li>Gzip 各模块支持的配置指令</li>
<li>Gzip 压缩功能的配置</li>
<li>Gzip 和 sendfile 的冲突解决</li>
<li>浏览器不支持 Gzip 的解决方案</li>
</ul>
<h3 id="Gzip模块配置指令"><a href="#Gzip模块配置指令" class="headerlink" title="Gzip模块配置指令"></a>Gzip模块配置指令</h3><p>接下来所学习的指令都来自 <code>ngx_http_gzip_module</code> 模块，该模块会在 Nginx 安装的时候内置到 Nginx 的安装环境中，也就是说我们可以直接使用这些指令。</p>
<ul>
<li><code>gzip</code> 指令是用于开启或者关闭 Gzip 功能。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip &lt;on | off&gt;;</td>
<td>gzip off;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>注意：只有该指令为打开状态，下面的指令才有效果</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_types</code> 指令可以根据响应页的 MIME 类型选择性地开启 Gzip 压缩功能。默认是 text/html</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_types &lt;mime-type&gt; …… ;</td>
<td>gzip_types text/html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>所选择的值可以从 mime.types 文件中进行查找，也可以使用 * 代表所有。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_types</span> application/javascript;</span><br><span class="line">	<span class="comment"># * 代表所有</span></span><br><span class="line">	<span class="attribute">gzip_types</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_comp_level</code> 指令是用于设置 Gzip 压缩程度，级别从 1-9，1 表示要是程度最低，要是效率最高，9 刚好相反，压缩程度最高，但是效率最低、最费时间。默认值是 1</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_comp_level &lt;level&gt;;</td>
<td>gzip_comp_level 1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_vary</code> 指令是用于设置使用 Gzip 进行压缩发送是否携带『Vary:Accept-Encoding』头域的响应头部。主要是告诉接收方，所发送的数据经过了 Gzip 压缩处理。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_vary &lt;on | off&gt;;</td>
<td>gzip_vary off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4bsq0xpu9s20.webp" alt="image"></p>
<ul>
<li><code>gzip_buffers</code> 指令是用于处理请求压缩的缓冲区数量和大小</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>gzip_buffers 32 4k | 16 8k;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>其中 number 是指定 Nginx 服务器向系统申请缓存空间个数，size 指的是每个缓存空间的大小。主要实现的是申请 number 个每个大小为 size 的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	  <span class="comment"># 缓存空间大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_disable</code> 指令是针对不同种类客户端发起的请求，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_disable &lt;regex&gt; …… ;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>regex 是根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用 Gzip.该指令一般是用来排除一些明显不支持 Gzip 的浏览器。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br></pre></td></tr></table></figure>

<p><code>gzip_http_version</code> 指令是针对不同的 HTTP 协议版本，可以选择性地开启和关闭 Gzip 功能。默认是 1.1 版本</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_http_version &lt;1.0 | 1.1&gt;;</td>
<td>gzip_http_version 1.1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>该指令是指定使用 Gzip 的 HTTP 最低版本，该指令一般采用默认值即可。</p>
<ul>
<li><code>gzip_min_length</code> 指令是针对传输数据的大小，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_min_length &lt;length&gt;;</td>
<td>gzip_min_length 20;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>Nignx 计量大小的单位：bytes [字节] / kb [千字节] / M [兆]</p>
<p>例如: 1024 / 10k | K / 10m | M</p>
<p>Gzip 压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的话，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用 Gzip 功能，响应页面的大小可以通过头信息中的 <code>Content-Length</code> 来获取。但是如何使用了 Chunk 编码动态压缩，该指令将被忽略。建议设置为 1K 或以上。</p>
<ul>
<li><code>gzip_proxied</code> 指令设置是否对服务端返回的结果进行 Gzip 压缩</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_proxied &lt;off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any&gt;;</td>
<td>gzip_proxied off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>off：关闭 Nginx 服务器对后台服务器返回结果的 Gzip 压缩</li>
<li>expired：如果 header 头中包含 『Expires』头信息，启用压缩</li>
<li>no-cache：如果 header 头中包含 『Cache-Control:no-cache』头信息，启用压缩</li>
<li>no-store：如果 header 头中包含 『Cache-Control:no-store』头信息，启用压缩</li>
<li>private：如果 header 头中包含 『Cache-Control:private』头信息，启用压缩</li>
<li>no_last_modified：如果 header 头中不包含 『Last-Modified』头信息，启用压缩</li>
<li>no_etag：如果 header 头中不包含 『ETag』 头信息，启用压缩</li>
<li>auth：如果 header 头中包含 『Authorization』 头信息，启用压缩</li>
<li>any：无条件启用压缩</li>
</ul>
<h3 id="Gzip压缩功能配置模板"><a href="#Gzip压缩功能配置模板" class="headerlink" title="Gzip压缩功能配置模板"></a>Gzip压缩功能配置模板</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;  			   		 <span class="comment"># 开启 Gzip 功能</span></span><br><span class="line"><span class="attribute">gzip_types</span> *;		   	 	 <span class="comment"># 压缩源文件类型,根据具体的访问资源类型设定</span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;	   		 <span class="comment"># Gzip 压缩级别</span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;          <span class="comment"># 进行压缩响应页面的最小长度，content-length</span></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	         <span class="comment"># 缓存空间大小</span></span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;       <span class="comment"># 指定压缩响应所需要的最低 HTTP 请求版本</span></span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;		         <span class="comment"># 往头信息中添加压缩标识</span></span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>; <span class="comment"># 对 IE6 以下的版本都不进行压缩</span></span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;           <span class="comment"># Nginx 作为反向代理压缩服务端返回数据的条件</span></span><br></pre></td></tr></table></figure>

<p>这些配置在很多地方可能都会用到，所以我们可以将这些内容抽取到一个配置文件中，然后通过 include 指令把配置文件再次加载到 nginx.conf 配置文件中，方法使用。</p>
<p>创建压缩配置文件：<code>nginx_gzip.conf</code>，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> *;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;</span><br></pre></td></tr></table></figure>

<p>在 Nginx 核心配置文件 <code>nginx.conf</code> 进行引入，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> nginx_gzip.conf</span><br></pre></td></tr></table></figure>

<h3 id="Gzip和sendfile共存问题"><a href="#Gzip和sendfile共存问题" class="headerlink" title="Gzip和sendfile共存问题"></a>Gzip和sendfile共存问题</h3><p>前面在讲解 sendfile 的时候，提到过，开启 sendfile 以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是 Gzip 要想对资源压缩，是需要经过用户进程进行操作的。Nginx 设置了Gzip 之后，静态文件的 sendfile 就不起作用了。所以要考虑如何解决两个设置的共存问题。</p>
<p>可以使用 <code>ngx_http_gzip_static_module</code> 模块的 <code>gzip_static</code> 指令来解决。</p>
<h3 id="gzip-static指令"><a href="#gzip-static指令" class="headerlink" title="gzip_static指令"></a>gzip_static指令</h3><p><code>gzip_static</code> 指令用于在检查与访问资源同名的 .gz 文件时，response 中以 Gzip 相关的 header 返回 .gz 文件的内容。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_static &lt;on | off | always&gt;;</td>
<td>gzip_static off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>在配置文件添加上述命令后，会报一个错误：<code>unknown directive &quot;gzip_static&quot;</code>，主要的原因是 Nginx 默认是没有添加 ngx_http_gzip_static_module 模块。如何来添加？</p>
<h3 id="Nginx模块添加"><a href="#Nginx模块添加" class="headerlink" title="Nginx模块添加"></a>Nginx模块添加</h3><ol>
<li>查询当前 Nginx 的配置参数，即查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 Nginx 安装目录下 sbin 目录中的 nginx 二进制文件进行更名备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/nginx/core/nginx-1.21.6</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 configure 来配置参数，添加 <code>ngx_http_gzip_static_module</code> 模块，记得加上第1步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module  <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用 make 命令进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 objs 目录下的 nginx 二进制执行文件移动到 nginx 安装目录下的 sbin 目录中</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.21.6/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>如果不执行第（2）步进行备份，则该步骤会覆盖原来的 nginx 可执行文件</p>
<ol start="8">
<li>在源码目录下执行更新命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="gzip-static测试"><a href="#gzip-static测试" class="headerlink" title="gzip_static测试"></a>gzip_static测试</h3><p>准备好一个 jquery.js 文件，放在 html 目录下</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.576ef03x00c0.webp" alt="image"></p>
<ol>
<li>直接访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.2b8dhabn0cbo.webp" alt="image"></p>
<ol start="2">
<li>使用 Gzip 命令进行压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 html 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩 js 文件</span></span><br><span class="line">gzip jquery.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4ivj1d091pg.webp" alt="image"></p>
<p>可以看出 <code>Content-Length</code> 的大小已经变得非常小。</p>
<h2 id="静态资源缓存配置"><a href="#静态资源缓存配置" class="headerlink" title="静态资源缓存配置"></a>静态资源缓存配置</h2><p>当浏览器请求 Nginx 服务器的资源后，我们可以让这些资源缓存在浏览器里，这样再一次请求相同的资源时，无需请求 Nginx 服务器，直接从浏览器的缓存里获取，减少 Nginx 服务器的压力。</p>
<h3 id="什么是缓存和Web缓存"><a href="#什么是缓存和Web缓存" class="headerlink" title="什么是缓存和Web缓存"></a>什么是缓存和Web缓存</h3><p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 DRAM 技术，而使用昂贵但较快速的 SRAM 技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p>
<p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 URL 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p>
<h3 id="Web缓存的种类"><a href="#Web缓存的种类" class="headerlink" title="Web缓存的种类"></a>Web缓存的种类</h3><p>客户端缓存</p>
<ul>
<li>浏览器缓存</li>
</ul>
<p>服务端缓存</p>
<ul>
<li>Nginx</li>
<li>Redis</li>
<li>Memcached 等</li>
</ul>
<h3 id="为什么要用浏览器缓存"><a href="#为什么要用浏览器缓存" class="headerlink" title="为什么要用浏览器缓存"></a>为什么要用浏览器缓存</h3><ul>
<li>成本最低的一种缓存实现</li>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟，加快页面打开速度</li>
</ul>
<h3 id="浏览器缓存执行流程"><a href="#浏览器缓存执行流程" class="headerlink" title="浏览器缓存执行流程"></a>浏览器缓存执行流程</h3><p>HTTP 协议中和页面缓存相关的字段，我们先来认识下：</p>
<table>
<thead>
<tr>
<th>header</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Expires</td>
<td>缓存过期的日期和时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>设置和缓存相关的配置信息</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源最后修改时间</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值，比如文件的 MD5 值</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.209c4krjzgf4.webp" alt="image"></p>
<ol>
<li>用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送 request 请求来获取数据；</li>
<li>服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回 200 的成功状态码并且在响应头上附上对应资源以及缓存信息；</li>
<li>当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件；</li>
<li>如果没有找到对应的缓存文件，则走第2步；</li>
<li>如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires)；</li>
<li>如果没有过期，则直接从本地缓存中返回数据进行展示（强缓存）；</li>
<li>如果 Expires 过期，接下来需要判断缓存文件是否发生过变化；</li>
<li>判断的标准有两个（都要判断），一个是 ETag(Entity Tag)，一个是 Last-Modified；</li>
<li>判断结果是未发生变化，则服务端返回 304，直接从缓存文件中获取数据（弱缓存）；</li>
<li>如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</li>
</ol>
<h3 id="浏览器缓存相关指令"><a href="#浏览器缓存相关指令" class="headerlink" title="浏览器缓存相关指令"></a>浏览器缓存相关指令</h3><p>Nginx 需要进行缓存相关设置，就需要用到如下的指令。</p>
<h4 id="expires指令"><a href="#expires指令" class="headerlink" title="expires指令"></a>expires指令</h4><p>该指令用来控制页面缓存的作用。可以通过该指令控制 HTTP 应答中的『Expires』和『Cache-Control』</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>expires [modified] &lt;time&gt;; expires &lt;epoch | max | off&gt;;</td>
<td>expires off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li><p>time：可以整数也可以是负数，指定过期时间，单位为 s（秒）。如果是负数，Cache-Control 则为 no-cache，如果为整数或 0，则 Cache-Control 的值为 max-age=time</p>
</li>
<li><p>epoch：指定 Expires 的值为『’1 January,1970,00:00:01 GMT’』，即 1970-01-01 00:00:00 ，Cache-Control 的值 no-cache</p>
<p>因为 Expires（缓存过期时间）是 1970 年，所以不缓存。</p>
</li>
<li><p>max：指定 Expires 的值为『’31 December2037 23:59:59GMT’ 』，即(2037-12-31 23:59:59，Cache-Control 的值为 10 年</p>
<p>因为 Expires（缓存过期时间）是 2037 年，虽然还有 16 年过期，但是最大只能缓存 10 年。</p>
</li>
<li><p>off：默认不缓存</p>
</li>
</ul>
<blockquote>
<p><strong>例子 1</strong></p>
</blockquote>
<p>在配置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|js|css|png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attribute">expires</span> max</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求：<code>http://192.168.91.200/jquery.js</code></p>
<p>查看开发者工具(F12)的 NetWork，如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4x3yczk58lk0.webp" alt="image"></p>
<p>315360000 折算下来正好是 10 年。</p>
<blockquote>
<p><strong>其他格式</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expires</span> <span class="number">30s</span>;  <span class="comment"># 表示把数据缓存 30 秒</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">30m</span>;  <span class="comment"># 表示把数据缓存 30 分</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">10h</span>;  <span class="comment"># 表示把数据缓存 10 小时</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">1d</span>;   <span class="comment"># 表示把数据缓存 1 天</span></span><br></pre></td></tr></table></figure>

<h4 id="add-header指令"><a href="#add-header指令" class="headerlink" title="add_header指令"></a>add_header指令</h4><p>add_header 指令是用来添加指定的响应头和响应值。</p>
<p>add_header 是响应体的指令，不是请求时的指令（比如 expires ），并且 add_header 也有和 expires 一样的功能。</p>
<p>如果 expires 和 add_header 同时开启的情况下，则 add_header 优于 expires 生效。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>add_header &lt;name&gt; &lt;value&gt; [always];</td>
<td>—</td>
<td>location &gt; server &gt; http &gt; ……</td>
</tr>
</tbody></table>
<p>always 可选，代表总是添加。</p>
<p>Cache-Control 作为响应头信息，可以在 Nginx 配置文件设置如下缓存响应指令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Cache-control must-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-cache;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-store;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-transform;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control public;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control private;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control proxy-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-Control max-age=&lt;seconds&gt;;  <span class="comment"># 秒</span></span><br><span class="line"><span class="attribute">add_header</span> Cache-control s-maxage=&lt;seconds&gt;; <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure>

<p>描述：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>no-cache</td>
<td>数据内容不能被缓存，每次请求都重新访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存请求或响应的任何内容，暂存也不可以(临时文件夹中不能暂存该资源)</td>
</tr>
<tr>
<td>no-transform</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>public</td>
<td>可以被任何缓存区缓存，如: 浏览器、服务器、代理服务器等</td>
</tr>
<tr>
<td>private（默认）</td>
<td>只能在浏览器中缓存，只有在第一次请求的时候才访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age=&lt;秒&gt;</td>
<td>过期时间，即以秒为单位的缓存时间</td>
</tr>
<tr>
<td>s-maxage=&lt;秒&gt;</td>
<td>公共缓存服务器响应的最大 Age 值</td>
</tr>
</tbody></table>
<p>值得注意的是：</p>
<ul>
<li>设置了 no-cache 或者 private 后，打开新窗口时会重新访问服务器。若设置 max-age，则缓存期间不访问服务器</li>
<li>设置 private 和正数的 max-age 时，后退时候不会访问服务器</li>
<li>设置 no-cache 和正数的 max-age 时，后退时会访问服务器</li>
</ul>
<h3 id="Nginx服务端缓存"><a href="#Nginx服务端缓存" class="headerlink" title="Nginx服务端缓存"></a>Nginx服务端缓存</h3><p>在 Web 缓存的种类，我们提到了 Ngixn 服务端缓存，而上面仅仅介绍了在浏览器进行缓存，而因为 Ngixn 服务端缓存的内容比较多，所以前往 <strong>Nginx - 缓存集成</strong> 进行学习。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GeYu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuistgy.github.io/2022/11/10/Nginx_Static_resource_deployment/">https://nuistgy.github.io/2022/11/10/Nginx_Static_resource_deployment/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuistgy.github.io">Yu's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/后端/">后端</a><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a><a class="post-meta__tags" href="/tags/中间件/">中间件</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5befa2f76de7c6b5" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/11/10/Nginx_Configuration_file/"><i class="fa fa-chevron-left">  </i><span>Nginx 核心配置文件</span></a></div><div class="next-post pull-right"><a href="/2022/11/09/Nginx_Base_Use/"><span>Nginx基本使用</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>