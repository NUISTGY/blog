<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">228</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/03/IO-操作系统IO模型/">IO模型-Linux操作系统中的IO模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IO/">IO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><blockquote>
<p><a href="https://blog.csdn.net/m0_73257876/article/details/126403791" target="_blank" rel="noopener">https://blog.csdn.net/m0_73257876/article/details/126403791</a></p>
<p><a href="https://juejin.cn/post/7136110312440201223" target="_blank" rel="noopener">https://juejin.cn/post/7136110312440201223</a></p>
</blockquote>
<h3 id="五种模型"><a href="#五种模型" class="headerlink" title="五种模型"></a>五种模型</h3><p>对于一个套接字上的输入操作，第一步是等待数据从网络中到达，当数据到达时被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</p>
<p>Linux 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<p>五种模型对比：</p>
<ul>
<li>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段，非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞</li>
</ul>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞</li>
<li>异步 I/O：第二阶段应用进程不会阻塞</li>
</ul>
<h4 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h4><p>应用进程通过系统调用 recvfrom 接收数据，会被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。阻塞不意味着整个操作系统都被阻塞，其它应用进程还可以执行，只是当前阻塞进程不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</p>
<p>recvfrom() 用于<strong>接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</strong>，把 recvfrom() 当成系统调用</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt></p>
<h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好数据，内核返回一个错误码，过一段时间应用进程再执行 recvfrom 系统调用，在两次发送请求的时间段，进程可以进行其他任务，这种方式称为轮询（polling）</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt></p>
<h4 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，等待数据阶段应用进程是非阻塞的。当内核数据准备就绪时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" alt></p>
<h4 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h4><p>IO 复用模型使用 select 或者 poll 函数等待数据，select 会监听所有注册好的 IO，<strong>等待多个套接字中的任何一个变为可读</strong>，等待过程会被阻塞，当某个套接字准备好数据变为可读时 select 调用就返回，然后调用 recvfrom 把数据从内核复制到进程中</p>
<p>IO 复用让单个进程具有处理多个 I/O 事件的能力，又被称为 Event Driven I/O，即<strong>事件驱动 I/O</strong></p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都要创建一个线程去处理，如果同时有几万个连接，就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt></p>
<h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><p>应用进程执行 aio_read 系统调用会立即返回，给内核传递描述符、缓冲区指针、缓冲区大小等。应用进程可以继续执行不会被阻塞，内核会在所有操作完成之后向应用进程发送信号</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png" alt></p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>Socket 不是文件，只是一个标识符，但是 Unix 操作系统把所有东西都<strong>看作</strong>是文件，所以 Socket 说成 file descriptor，也就是 fd</p>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd_set 使用 <strong>bitmap 数组</strong>实现，数组大小用 FD_SETSIZE 定义，<strong>单进程</strong>只能监听少于 FD_SETSIZE 数量的描述符，32 位机默认是 1024 个，64 位机默认是 2048，可以对进行修改，然后重新编译内核</p>
</li>
<li><p>fd_set 有三种类型的描述符：readset、writeset、exceptset，对应读、写、异常条件的描述符集合</p>
</li>
<li><p>n 是监测的 socket 的最大数量</p>
</li>
<li><p>timeout 为超时参数，调用 select 会一直<strong>阻塞</strong>直到有描述符的事件到达或者等待的时间超过 timeout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; 	<span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;	<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout == null：等待无限长的时间</li>
<li>tv_sec == 0 &amp;&amp; tv_usec == 0：获取后直接返回，不阻塞等待</li>
<li>tv_sec != 0 || tv_usec != 0：等待指定时间</li>
</ul>
</li>
<li><p>方法成功调用返回结果为<strong>就绪的文件描述符个数</strong>，出错返回结果为 -1，超时返回结果为 0</p>
</li>
</ul>
<p>Linux 提供了一组宏为 fd_set 进行赋值操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;			<span class="comment">// 将一个 fd_set 类型变量的所有值都置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 判断 fd 位是否被置为 1</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));<span class="comment">//绑定连接</span></span><br><span class="line">listen(sockfd, <span class="number">5</span>);<span class="comment">//监听5个端口</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;client, e, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">	fds[i] = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="comment">//将监听的对应的文件描述符fd存入fds：[3,4,5,6,7]</span></span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">		max = fds[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;rset);<span class="comment">//置为0</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    	FD_SET(fds[i], &amp;rset);<span class="comment">//对应位置1 [0001 1111 00.....]</span></span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">"round again"</span>);</span><br><span class="line">	select(max + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//监听</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset)) &#123;<span class="comment">//判断监听哪一个端口</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">            read(fds[i], buffer, MAXBUF);<span class="comment">//进入内核态读数据</span></span><br><span class="line">            print(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>select 调用流程图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-select%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt></p>
<ol>
<li>使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间，进程阻塞</li>
<li>注册回调函数 _pollwait</li>
<li>遍历所有 fd，调用其对应的 poll 方法判断当前请求是否准备就绪，对于 socket，这个 poll 方法是 sock_poll，sock_poll 根据情况会调用到 tcp_poll、udp_poll 或者 datagram_poll，以 tcp_poll 为例，其核心实现就是 _pollwait</li>
<li>_pollwait 把 <strong>current（调用 select 的进程）</strong>挂到设备的等待队列，不同设备有不同的等待队列，对于 tcp_poll ，其等待队列是 sk → sk_sleep（把进程挂到等待队列中并不代表进程已经睡眠），在设备收到消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒，进入就绪队列</li>
<li>poll 方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值</li>
<li>如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout 让 current 进程进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程，如果超过一定的超时时间（schedule_timeout）没有其他线程唤醒，则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd</li>
<li>把 fd_set 从内核空间拷贝到用户空间，阻塞进程继续执行</li>
</ol>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<p>其他流程图：<a href="https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1" target="_blank" rel="noopener">https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1</a></p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>select 和 poll 对比：</p>
<ul>
<li>select 会修改描述符，而 poll 不会</li>
<li>select 的描述符类型使用数组实现，有描述符的限制；而 poll 使用<strong>链表</strong>实现，没有描述符数量的限制</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高</li>
</ul>
<ul>
<li>select 和 poll 速度都比较慢，<strong>每次调用</strong>都需要将全部描述符数组 fd 从应用进程缓冲区复制到内核缓冲区，同时每次都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时会很大</li>
<li>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll</li>
<li>select 和 poll 的时间复杂度 O(n)，对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低，因为并不知道具体是哪个 socket 具有事件，所以随着 fd 数量的增加会造成遍历速度慢的<strong>线性下降</strong>性能问题</li>
<li>poll 还有一个特点是水平触发，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>epoll 使用事件的就绪通知方式，通过 epoll_ctl() 向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，一旦该 fd 就绪，<strong>内核通过 callback 回调函数将 I/O 准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件就绪的描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>epall_create：一个系统函数，函数将在内核空间内创建一个 epoll 数据结构，可以理解为 epoll 结构空间，返回值为 epoll 的文件描述符编号，以后有 client 连接时，向该 epoll 结构中添加监听，所以 epoll 使用一个文件描述符管理多个描述符</p>
</li>
<li><p>epall_ctl：epoll 的事件注册函数，select 函数是调用时指定需要监听的描述符和事件，epoll 先将用户感兴趣的描述符事件注册到 epoll 空间。此函数是非阻塞函数，用来增删改 epoll 空间内的描述符，参数解释：</p>
<ul>
<li><p>epfd：epoll 结构的进程 fd 编号，函数将依靠该编号找到对应的 epoll 结构</p>
</li>
<li><p>op：表示当前请求类型，有三个宏定义：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中</li>
<li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li>
<li>EPOLL_CTI_DEL：从 epfd 中删除一个 fd</li>
</ul>
</li>
<li><p>fd：需要监听的文件描述符，一般指 socket_fd</p>
</li>
<li><p>event：告诉内核对该 fd 资源感兴趣的事件，epoll_event 的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">_uint32_t</span> events;	<span class="comment">/*epoll events*/</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">/*user data variable*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events 可以是以下几个宏集合：EPOLLIN、EPOLOUT、EPOLLPRI、EPOLLERR、EPOLLHUP（挂断）、EPOLET（边缘触发）、EPOLLONESHOT（只监听一次，事件触发后自动清除该 fd，从 epoll 列表）</p>
</li>
</ul>
</li>
<li><p>epoll_wait：等待事件的产生，类似于 select() 调用，返回值为本次就绪的 fd 个数，直接从就绪链表获取，时间复杂度 O(1)</p>
<ul>
<li>epfd：<strong>指定感兴趣的 epoll 事件列表</strong></li>
<li>events：指向一个 epoll_event 结构数组，当函数返回时，内核会把就绪状态的数据拷贝到该数组</li>
<li>maxevents：标明 epoll_event 数组最多能接收的数据量，即本次操作最多能获取多少就绪数据</li>
<li>timeout：单位为毫秒<ul>
<li>0：表示立即返回，非阻塞调用</li>
<li>-1：阻塞调用，直到有用户感兴趣的事件就绪为止</li>
<li>大于 0：阻塞调用，阻塞指定时间内如果有事件就绪则提前返回，否则等待指定时间后返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）：</p>
<ul>
<li>LT 模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程，是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</li>
<li>ET 模式：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高；只支持 No-Blocking，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个文件描述符的任务饥饿</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll 描述符，每个应用程序只需要一个，用于监控所有套接字</span></span><br><span class="line"><span class="keyword">int</span> pollingfd = epoll_create(<span class="number">0xCAFE</span>);</span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )<span class="comment">// report error</span></span><br><span class="line"><span class="comment">// 初始化 epoll 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连接类实例与事件相关联，可以关联任何想要的东西</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视输入，并且在事件发生后不自动重新准备描述符</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// 将描述符添加到监控列表中，即使另一个线程在epoll_wait中等待，描述符将被正确添加</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多等待 20 个事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[20];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待10秒，检索20个并存入epoll_event数组</span></span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait(pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">// 检查epoll是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span>)<span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span>)<span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready; i+ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取连接指针</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：<a href="https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" target="_blank" rel="noopener">https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>epoll 的特点：</p>
<ul>
<li><p>epoll 仅适用于 Linux 系统</p>
</li>
<li><p>epoll 使用<strong>一个文件描述符管理多个描述符</strong>，将用户关心的文件描述符的事件存放到内核的一个事件表（个人理解成哑元节点）</p>
</li>
<li><p>没有最大描述符数量（并发连接）的限制，打开 fd 的上限远大于1024（1G 内存能监听约 10 万个端口）</p>
</li>
<li><p>epoll 的时间复杂度 O(1)，epoll 理解为 event poll，不同于忙轮询和无差别轮询，调用 epoll_wait <strong>只是轮询就绪链表</strong>。当监听列表有设备就绪时调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait 中阻塞的进程，所以 epoll 实际上是<strong>事件驱动</strong>（每个事件关联上fd）的，降低了 system call 的时间复杂度</p>
</li>
<li><p>epoll 内核中根据每个 fd 上的 callback 函数来实现，只有活跃的 socket 才会主动调用 callback，所以使用 epoll 没有前面两者的线性下降的性能问题，效率提高</p>
</li>
<li><p>epoll 注册新的事件是注册到到内核中 epoll 句柄中，不需要每次调用 epoll_wait 时重复拷贝，对比前面两种只需要将描述符从进程缓冲区向内核缓冲区<strong>拷贝一次</strong>，也可以利用 <strong>mmap() 文件映射内存</strong>加速与内核空间的消息传递（只是可以用，并没有用）</p>
</li>
<li><p>前面两者要把 current 往设备等待队列中挂一次，epoll 也只把 current 往等待队列上挂一次，但是这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列，这样可以节省开销</p>
</li>
<li><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符，也不会产生像 select 和 poll 的不确定情况</p>
</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd940e7fca2</a></p>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用场景： </p>
<ul>
<li><p>select 应用场景：</p>
<ul>
<li>select 的 timeout 参数精度为微秒，poll 和 epoll 为毫秒，因此 select 适用<strong>实时性要求比较高</strong>的场景，比如核反应堆的控制</li>
<li>select 可移植性更好，几乎被所有主流平台所支持</li>
</ul>
</li>
<li><p>poll 应用场景：poll 没有最大描述符数量的限制，适用于平台支持并且对实时性要求不高的情况</p>
</li>
<li><p>epoll 应用场景：</p>
<ul>
<li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是<strong>长连接</strong></li>
<li>需要同时监控小于 1000 个描述符，没必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势</li>
<li>需要监控的描述符状态变化多，而且是非常短暂的，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，每次对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率，并且 epoll 的描述符存储在内核，不容易调试</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h4><p>用户空间：用户代码、用户堆栈</p>
<p>内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info 进程描述符）</p>
<ul>
<li>进程描述符和用户的进程是一一对应的</li>
<li>SYS_API 系统调用：如 read、write，系统调用就是 0X80 中断</li>
<li>进程描述符 pd：进程从用户态切换到内核态时，需要<strong>保存用户态时的上下文信息在 PCB 中</strong></li>
<li>线程上下文：用户程序基地址，程序计数器、cpu cache、寄存器等，方便程序切回用户态时恢复现场</li>
<li>内核堆栈：<strong>系统调用函数也是要创建变量的，</strong>这些变量在内核堆栈上分配</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png" alt></p>
<h4 id="80中断"><a href="#80中断" class="headerlink" title="80中断"></a>80中断</h4><p>在用户程序中调用操作系统提供的核心态级别的子功能，为了系统安全需要进行用户态和内核态转换，状态的转换需要进行 CPU 中断，中断分为硬中断和软中断：</p>
<ul>
<li>硬中断：如网络传输中，数据到达网卡后，网卡经过一系列操作后发起硬件中断</li>
<li>软中断：如程序运行过程中本身产生的一些中断<ul>
<li>发起 <code>0X80</code> 中断</li>
<li>程序执行碰到除 0 异常</li>
</ul>
</li>
</ul>
<p>系统调用 system_call 函数所对应的中断指令编号是 0X80（十进制是 8×16=128），而该指令编号对应的就是系统调用程序的入口，所以称系统调用为 80 中断</p>
<p>系统调用的流程：</p>
<ul>
<li>在 CPU 寄存器里存一个系统调用号，表示哪个系统函数，比如 read</li>
<li>将 CPU 的临时数据都保存到 thread_info 中</li>
<li>执行 80 中断处理程序，找到刚刚存的系统调用号（read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间</li>
<li>最后恢复到用户态，通过 thread_info 恢复现场，用户态继续执行</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA (Direct Memory Access) ：直接存储器访问，让外部设备不通过 CPU 直接与系统内存交换数据的接口技术</p>
<p>作用：可以解决批量数据的输入/输出问题，使数据的传送速度取决于存储器和外设的工作速度</p>
<p>把内存数据传输到网卡然后发送：</p>
<ul>
<li>没有 DMA：CPU 读内存数据到 CPU 高速缓存，再写到网卡，这样就把 CPU 的速度拉低到和网卡一个速度</li>
<li>使用 DMA：把数据读到 Socket 内核缓存区（CPU 复制），CPU 分配给 DMA 开始<strong>异步</strong>操作，DMA 读取 Socket 缓冲区到 DMA 缓冲区，然后写到网卡。DMA 执行完后<strong>中断</strong>（就是通知） CPU，这时 Socket 内核缓冲区为空，CPU 从用户态切换到内核态，执行中断处理程序，将需要使用 Socket 缓冲区的阻塞进程移到就绪队列</li>
</ul>
<p>一个完整的 DMA 传输过程必须经历 DMA 请求、DMA 响应、DMA 传输、DMA 结束四个步骤：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-DMA.png" style="zoom: 50%;">

<p>DMA 方式是一种完全由硬件进行信息传送的控制方式，通常系统总线由 CPU 管理，在 DMA 方式中，CPU 的主存控制信号被禁止使用，CPU 把总线（地址总线、数据总线、控制总线）让出来由 DMA 控制器接管，用来控制传送的字节数、判断 DMA 是否结束、以及发出 DMA 结束信号，所以 DMA 控制器必须有以下功能：</p>
<ul>
<li>接受外设发出的 DMA 请求，并向 CPU 发出总线接管请求</li>
<li>当 CPU 发出允许接管信号后，进入 DMA 操作周期</li>
<li>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数</li>
<li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li>
<li>判断 DMA 传送是否结束，发出 DMA 结束信号，使 CPU 恢复正常工作状态（中断）</li>
</ul>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>传统的 I/O 操作进行了 4 次用户空间与内核空间的上下文切换，以及 4 次数据拷贝：</p>
<ul>
<li>JVM 发出 read 系统调用，OS 上下文切换到内核模式（切换 1）并将数据从网卡或硬盘等设备通过 DMA 读取到内核空间缓冲区（拷贝 1），内核缓冲区实际上是<strong>磁盘高速缓存（PageCache）</strong></li>
<li>OS 内核将数据复制到用户空间缓冲区（拷贝 2），然后 read 系统调用返回，又会导致一次内核空间到用户空间的上下文切换（切换 2）</li>
<li>JVM 处理代码逻辑并发送 write() 系统调用，OS 上下文切换到内核模式（切换3）并从用户空间缓冲区复制数据到内核空间缓冲区（拷贝3）</li>
<li>将内核空间缓冲区中的数据写到 hardware（拷贝4），write 系统调用返回，导致内核空间到用户空间的再次上下文切换（切换4）</li>
</ul>
<p>流程图中的箭头反过来也成立，可以从网卡获取数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-BIO%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>read 调用图示：read、write 都是系统调用指令</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-缓冲区读写.png" style="zoom: 67%;">


<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（Memory Mapped Files）内存映射加 write 实现零拷贝，<strong>零拷贝就是没有数据从内核空间复制到用户空间</strong></p>
<p>用户空间和内核空间都使用内存，所以可以共享同一块物理内存地址，省去用户态和内核态之间的拷贝。写网卡时，共享空间的内容拷贝到 Socket 缓冲区，然后交给 DMA 发送到网卡，只需要 3 次复制</p>
<p>进行了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（2 次 DMA，一次 CPU 复制）：</p>
<ul>
<li>发出 mmap 系统调用，DMA 拷贝到内核缓冲区，映射到共享缓冲区；mmap 系统调用返回，无需拷贝</li>
<li>发出 write 系统调用，将数据从内核缓冲区拷贝到内核 Socket 缓冲区；write 系统调用返回，DMA 将内核空间 Socket 缓冲区中的数据传递到协议引擎</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-mmap%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>原理：利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射后对物理内存的操作会<strong>被同步</strong>到硬盘上</p>
<p>缺点：不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘</p>
<p>Java NIO 提供了 <strong>MappedByteBuffer</strong> 类可以用来实现 mmap 内存映射，MappedByteBuffer 类对象<strong>只能通过调用 <code>FileChannel.map()</code> 获取</strong></p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile 实现零拷贝，打开文件的文件描述符 fd 和 socket 的 fd 传递给 sendfile，然后经过 3 次复制和 2 次用户态和内核态的切换</p>
<p>原理：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，由于和用户态完全无关，就减少了两次上下文切换</p>
<p>说明：零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-sendfile%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>sendfile2.4 之后，sendfile 实现了更简单的方式，文件到达内核缓冲区后，不必再将数据全部复制到 socket buffer 缓冲区，而是只<strong>将记录数据位置和长度相关等描述符信息</strong>保存到 socket buffer，DMA 根据 Socket 缓冲区中描述符提供的位置和偏移量信息直接将内核空间缓冲区中的数据拷贝到协议引擎上（2 次复制 2 次切换）</p>
<p>Java NIO 对 sendfile 的支持是 <code>FileChannel.transferTo()/transferFrom()</code>，把磁盘文件读取 OS 内核缓冲区后的 fileChannel，直接转给 socketChannel 发送，底层就是 sendfile</p>
<p>参考文章：<a href="https://blog.csdn.net/hancoder/article/details/112149121" target="_blank" rel="noopener">https://blog.csdn.net/hancoder/article/details/112149121</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/26/IO-传统BIO下网络编程/">IO模型-基于BIO的Java网络编程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IO/">IO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>一个 InetAddress 类的对象就代表一个 IP 地址对象</p>
<p>成员方法：</p>
<ul>
<li><code>static InetAddress getLocalHost()</code>：获得本地主机 IP 地址对象</li>
<li><code>static InetAddress getByName(String host)</code>：根据 IP 地址字符串或主机名获得对应的 IP 地址对象</li>
<li><code>String getHostName()</code>：获取主机名</li>
<li><code>String getHostAddress()</code>：获得 IP 地址字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取本机地址对象</span></span><br><span class="line">        InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip.getHostName());<span class="comment">//DESKTOP-NNMBHQR</span></span><br><span class="line">        System.out.println(ip.getHostAddress());<span class="comment">//192.168.11.1</span></span><br><span class="line">        <span class="comment">// 2.获取域名ip对象</span></span><br><span class="line">        InetAddress ip2 = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());<span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.getHostAddress());<span class="comment">//14.215.177.38</span></span><br><span class="line">        <span class="comment">// 3.获取公网IP对象。</span></span><br><span class="line">        InetAddress ip3 = InetAddress.getByName(<span class="string">"182.61.200.6"</span>);</span><br><span class="line">        System.out.println(ip3.getHostName());<span class="comment">//182.61.200.6</span></span><br><span class="line">        System.out.println(ip3.getHostAddress());<span class="comment">//182.61.200.6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.判断是否能通： ping  5s之前测试是否可通</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">5000</span>)); <span class="comment">// ping百度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>UDP（User Datagram Protocol）协议的特点：</p>
<ul>
<li>面向无连接的协议，发送端只管发送，不确认对方是否能收到，速度快，但是不可靠，会丢失数据</li>
<li>尽最大努力交付，没有拥塞控制</li>
<li>基于数据包进行数据传输，发送数据的包的大小限制 <strong>64KB</strong> 以内</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
</ul>
<p>UDP 协议的使用场景：在线视频、网络语音、电话</p>
<h4 id="实现UDP"><a href="#实现UDP" class="headerlink" title="实现UDP"></a>实现UDP</h4><p>UDP 协议相关的两个类：</p>
<ul>
<li>DatagramPacket（数据包对象）：用来封装要发送或要接收的数据，比如：集装箱</li>
<li>DatagramSocket（发送对象）：用来发送或接收数据包，比如：码头</li>
</ul>
<p><strong>DatagramPacket</strong>：</p>
<ul>
<li><p>DatagramPacket 类：</p>
<p><code>public new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：创建发送端数据包对象 </p>
<ul>
<li>buf：要发送的内容，字节数组</li>
<li>length：要发送内容的长度，单位是字节</li>
<li>address：接收端的IP地址对象</li>
<li>port：接收端的端口号</li>
</ul>
<p><code>public new DatagramPacket(byte[] buf, int length)</code>：创建接收端的数据包对象</p>
<ul>
<li>buf：用来存储接收到内容        </li>
<li>length：能够接收内容的长度</li>
</ul>
</li>
<li><p>DatagramPacket 类常用方法：</p>
<ul>
<li><code>public int getLength()</code>：获得实际接收到的字节个数</li>
<li><code>public byte[] getData()</code>：返回数据缓冲区</li>
</ul>
</li>
</ul>
<p><strong>DatagramSocket</strong>：</p>
<ul>
<li>DatagramSocket 类构造方法：<ul>
<li><code>protected DatagramSocket()</code>：创建发送端的 Socket 对象，系统会随机分配一个端口号</li>
<li><code>protected DatagramSocket(int port)</code>：创建接收端的 Socket 对象并指定端口号</li>
</ul>
</li>
<li>DatagramSocket 类成员方法：<ul>
<li><code>public void send(DatagramPacket dp)</code>：发送数据包</li>
<li><code>public void receive(DatagramPacket p)</code>：接收数据包</li>
<li><code>public void close()</code>：关闭数据报套接字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===启动客户端==="</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个集装箱对象，用于封装需要发送的数据包!</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="string">"我学Java"</span>.getBytes();</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer,bubffer.length,InetAddress.getLoclHost,<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个码头对象</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">// 3.开始发送数据包对象</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==启动服务端程序=="</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个接收客户都端的数据包对象（集装箱）</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, bubffer.length);</span><br><span class="line">        <span class="comment">// 2.创建一个接收端的码头对象</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 3.开始接收</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// 4.从集装箱中获取本次读取的数据量</span></span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        <span class="comment">// 5.输出数据</span></span><br><span class="line">        <span class="comment">// String rs = new String(socket.getData(), 0, len)</span></span><br><span class="line">        String rs = <span class="keyword">new</span> String(buffer , <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 6.服务端还可以获取发来信息的客户端的IP和端口。</span></span><br><span class="line">        String ip = packet.getAddress().getHostAdress();</span><br><span class="line">        <span class="keyword">int</span> port = packet.getPort();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>TCP/IP (Transfer Control Protocol) 协议，传输控制协议</p>
<p>TCP/IP 协议的特点：</p>
<ul>
<li>面向连接的协议，提供可靠交互，速度慢</li>
<li>点对点的全双工通信</li>
<li>通过<strong>三次握手</strong>建立连接，连接成功形成数据传输通道；通过<strong>四次挥手</strong>断开连接</li>
<li>基于字节流进行数据传输，传输数据大小没有限制</li>
</ul>
<p>TCP 协议的使用场景：文件上传和下载、邮件发送和接收、远程登录</p>
<p>注意：<strong>TCP 不会为没有数据的 ACK 超时重传</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/三次握手.png" alt="三次握手" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/四次挥手.png" alt="四次挥手" style="zoom: 67%;">

<p>推荐阅读：<a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener">https://yuanrengu.com/2020/77eef79f.html</a></p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>TCP 通信也叫 <strong>Socket 网络编程</strong>，只要代码基于 Socket 开发，底层就是基于了可靠传输的 TCP 通信</p>
<p>双向通信：Java Socket 是全双工的，在任意时刻，线路上存在 <code>A -&gt; B</code> 和 <code>B -&gt; A</code> 的双向信号传输，即使是阻塞 IO，读和写也是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>TCP 协议相关的类：</p>
<ul>
<li>Socket：一个该类的对象就代表一个客户端程序。</li>
<li>ServerSocket：一个该类的对象就代表一个服务器端程序。</li>
</ul>
<p>Socket 类：</p>
<ul>
<li><p>构造方法：</p>
<ul>
<li><p><code>Socket(InetAddress address,int port)</code>：创建流套接字并将其连接到指定 IP 指定端口号</p>
</li>
<li><p><code>Socket(String host, int port)</code>：根据 IP 地址字符串和端口号创建客户端 Socket 对象</p>
<p>注意事项：<strong>执行该方法，就会立即连接指定的服务器，连接成功，则表示三次握手通过</strong>，反之抛出异常</p>
</li>
</ul>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>OutputStream getOutputStream()</code>：获得字节输出流对象</li>
<li><code>InputStream getInputStream()</code>：获得字节输入流对象</li>
<li><code>void shutdownInput()</code>：停止接受</li>
<li><code>void shutdownOutput()</code>：停止发送数据，终止通信</li>
<li><code>SocketAddress getRemoteSocketAddress()</code>：返回套接字连接到的端点的地址，未连接返回 null</li>
</ul>
</li>
</ul>
<p>ServerSocket 类：</p>
<ul>
<li><p>构造方法：<code>public ServerSocket(int port)</code></p>
</li>
<li><p>常用 API：<code>public Socket accept()</code>，<strong>阻塞等待</strong>接收一个客户端的 Socket 管道连接请求，连接成功返回一个 Socket 对象</p>
<p>三次握手后 TCP 连接建立成功，服务器内核会把连接从 SYN 半连接队列（一次握手时在服务端建立的队列）中移出，移入 accept 全连接队列，等待进程调用 accept 函数时把连接取出。如果进程不能及时调用 accept 函数，就会造成 accept 队列溢出，最终导致建立好的 TCP 连接被丢弃</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-TCP三次握手.png" style="zoom:67%;">

</li>
</ul>
<p><strong>相当于</strong>客户端和服务器建立一个数据管道（虚连接，不是真正的物理连接），管道一般不用 close</p>
<h4 id="实现TCP"><a href="#实现TCP" class="headerlink" title="实现TCP"></a>实现TCP</h4><h5 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h5><p>客户端的开发流程：</p>
<ol>
<li>客户端要请求于服务端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输出流</li>
<li>通过字节输出流给服务端写出数据</li>
</ol>
<p>服务端的开发流程：</p>
<ol>
<li>用 ServerSocket 注册端口</li>
<li>接收客户端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输入流</li>
<li>从字节输入流中读取客户端发来的数据</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/TCP-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png" alt></p>
<ul>
<li>如果输出缓冲区空间不够存放主机发送的数据，则会被阻塞，输入缓冲区同理</li>
<li>缓冲区不属于应用程序，属于内核</li>
<li>TCP 从输出缓冲区读取数据会加锁阻塞线程</li>
</ul>
<h5 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h5><p>需求一：客户端发送一行数据，服务端接收一行数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">        ps.println(<span class="string">"我是客户端"</span>);</span><br><span class="line">        ps.flush();<span class="comment">//一般不关闭IO流</span></span><br><span class="line">        System.out.println(<span class="string">"客户端发送完毕~~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">if</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求二：客户端可以反复发送数据，服务端可以反复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求三：实现一个服务端可以同时接收多个客户端的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> socket.getOutputStream();</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">             Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span></span><br><span class="line">            <span class="keyword">new</span> ServerReaderThread(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    privat Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerReaderThread</span><span class="params">(Socket socket)</span></span>&#123;<span class="keyword">this</span>.socket = socket;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = socket.getInputStream();</span><br><span class="line">           	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is))</span><br><span class="line">           )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sout(socket.getRemoteSocketAddress() + <span class="string">":"</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            sout(socket.getRemoteSocketAddress() + <span class="string">"下线了~~~~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述缺点：</p>
<ul>
<li>一个客户端对应一个线程，容易导致资源耗尽</li>
<li>在客户端接入但并未发送消息的情况下，线程空等，浪费资源</li>
</ul>
<h3 id="伪异步"><a href="#伪异步" class="headerlink" title="伪异步"></a>伪异步</h3><h5 id="伪异步-1"><a href="#伪异步-1" class="headerlink" title="伪异步"></a>伪异步</h5><p>一个客户端要一个线程，并发越高系统瘫痪的越快，可以在服务端引入线程池，使用线程池来处理与客户端的消息通信</p>
<ul>
<li><p>优势：不会引起系统的死机，可以控制并发线程的数量</p>
</li>
<li><p>劣势：同时可以并发的线程将受到限制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//创建一个线程池，如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接...."</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/26/IO-Java中的NIO/">IO模型-Java中的NIO</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NIO/">NIO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>NIO的介绍</strong>：</p>
<p>Java NIO（New IO、Java non-blocking IO），从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API，NIO 支持面向缓冲区的、基于通道的 IO 操作，以更加高效的方式进行文件的读写操作</p>
<ul>
<li>NIO 有三大核心部分：<strong>Channel（通道），Buffer（缓冲区），Selector（选择器）</strong></li>
<li>NIO 是非阻塞 IO，传统 IO 的 read 和 write 只能阻塞执行，线程在读写 IO 期间不能干其他事情，比如调用 socket.accept()，如果服务器没有数据传输过来，线程就一直阻塞，而 NIO 中可以配置 Socket 为非阻塞模式</li>
<li>NIO 可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来，根据实际情况可以分配 20 或者 80 个线程来处理，不像之前的阻塞 IO 那样分配 1000 个</li>
</ul>
<p>NIO 和 BIO 的比较：</p>
<ul>
<li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多</p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</p>
<table>
<thead>
<tr>
<th>NIO</th>
<th>BIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向缓冲区（Buffer）</td>
<td>面向流（Stream）</td>
</tr>
<tr>
<td>非阻塞（Non Blocking IO）</td>
<td>阻塞IO(Blocking IO)</td>
</tr>
<tr>
<td>选择器（Selectors）</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>NIO 三大核心部分：Channel (通道)、Buffer (缓冲区)、Selector (选择器)</p>
<ul>
<li><p>Buffer 缓冲区</p>
<p>缓冲区本质是一块可以写入数据、读取数据的内存，<strong>底层是一个数组</strong>，这块内存被包装成 NIO Buffer 对象，并且提供了方法用来操作这块内存，相比较直接对数组的操作，Buffer 的 API 更加容易操作和管理</p>
</li>
<li><p>Channel 通道</p>
<p>Java NIO 的通道类似流，不同的是既可以从通道中读取数据，又可以写数据到通道，流的读写通常是单向的，通道可以非阻塞读取和写入通道，支持读取或写入缓冲区，也支持异步地读写</p>
</li>
<li><p>Selector 选择器</p>
<p>Selector 是一个 Java NIO 组件，能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入，这样一个单独的线程可以管理多个 channel，从而管理多个网络连接，提高效率</p>
</li>
</ul>
<p>NIO 的实现框架：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO%E6%A1%86%E6%9E%B6.png" alt></p>
<ul>
<li>每个 Channel 对应一个 Buffer</li>
<li>一个线程对应 Selector ， 一个 Selector 对应多个 Channel（连接）</li>
<li>程序切换到哪个 Channel 是由事件决定的，Event 是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 是一个内存块 ， 底层是一个数组</li>
<li>数据的读取写入是通过 Buffer 完成的 , BIO 中要么是输入流，或者是输出流，不能双向，NIO 的 Buffer 是可以读也可以写， flip() 切换 Buffer 的工作模式</li>
</ul>
<p>Java NIO 系统的核心在于：通道和缓冲区，通道表示打开的 IO 设备（例如：文件、 套接字）的连接。若要使用 NIO 系统，获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，用于特定基本数据类型的容器，用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer.png" alt></p>
<p><strong>Buffer 底层是一个数组</strong>，可以保存多个相同类型的数据，根据数据类型不同 ，有以下 Buffer 常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer </p>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul>
<li><p>容量（capacity）：作为一个内存块，Buffer 具有固定大小，缓冲区容量不能为负，并且创建后不能更改</p>
</li>
<li><p>限制 （limit）：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写），缓冲区的限制不能为负，并且不能大于其容量。写入模式，limit 等于 buffer 的容量；读取模式下，limit 等于写入的数据量</p>
</li>
<li><p>位置（position）：<strong>下一个要读取或写入的数据的索引</strong>，缓冲区的位置不能为负，并且不能大于其限制</p>
</li>
<li><p>标记（mark）与重置（reset）：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的位置，可以通过调用 reset() 方法恢复到这个 position</p>
</li>
<li><p>位置、限制、容量遵守以下不变式： <strong>0 &lt;= position &lt;= limit &lt;= capacity</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer操作.png" style="zoom:67%;">

</li>
</ul>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><code>static XxxBuffer allocate(int capacity)</code>：创建一个容量为 capacity 的 XxxBuffer 对象</p>
<p>Buffer 基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Buffer clear()</td>
<td>清空缓冲区，不清空内容，将位置设置为零，限制设置为容量</td>
</tr>
<tr>
<td>public Buffer flip()</td>
<td>翻转缓冲区，将缓冲区的界限设置为当前位置，position 置 0</td>
</tr>
<tr>
<td>public int capacity()</td>
<td>返回 Buffer的 capacity 大小</td>
</tr>
<tr>
<td>public final int limit()</td>
<td>返回 Buffer 的界限 limit 的位置</td>
</tr>
<tr>
<td>public Buffer limit(int n)</td>
<td>设置缓冲区界限为 n</td>
</tr>
<tr>
<td>public Buffer mark()</td>
<td>在此位置对缓冲区设置标记</td>
</tr>
<tr>
<td>public final int position()</td>
<td>返回缓冲区的当前位置 position</td>
</tr>
<tr>
<td>public Buffer position(int n)</td>
<td>设置缓冲区的当前位置为n</td>
</tr>
<tr>
<td>public Buffer reset()</td>
<td>将位置 position 重置为先前 mark 标记的位置</td>
</tr>
<tr>
<td>public Buffer rewind()</td>
<td>将位置设为为 0，取消设置的 mark</td>
</tr>
<tr>
<td>public final int remaining()</td>
<td>返回当前位置 position 和 limit 之间的元素个数</td>
</tr>
<tr>
<td>public final boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>public static ByteBuffer wrap(byte[] array)</td>
<td>将一个字节数组包装到缓冲区中</td>
</tr>
<tr>
<td>abstract ByteBuffer asReadOnlyBuffer()</td>
<td>创建一个新的只读字节缓冲区</td>
</tr>
<tr>
<td>public abstract ByteBuffer compact()</td>
<td>缓冲区当前位置与其限制（如果有）之间的字节被复制到缓冲区的开头</td>
</tr>
</tbody></table>
<p>Buffer 数据操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract byte get()</td>
<td>读取该缓冲区当前位置的单个字节，然后位置 + 1</td>
</tr>
<tr>
<td>public ByteBuffer get(byte[] dst)</td>
<td>读取多个字节到字节数组 dst 中</td>
</tr>
<tr>
<td>public abstract byte get(int index)</td>
<td>读取指定索引位置的字节，不移动 position</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(byte b)</td>
<td>将给定单个字节写入缓冲区的当前位置，position+1</td>
</tr>
<tr>
<td>public final ByteBuffer put(byte[] src)</td>
<td>将 src 字节数组写入缓冲区的当前位置</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(int index, byte b)</td>
<td>将指定字节写入缓冲区的索引位置，不移动 position</td>
</tr>
</tbody></table>
<p>提示：”\n”，占用两个字节</p>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<ul>
<li>写入数据到 Buffer</li>
<li>调用 flip()方法，转换为读取模式</li>
<li>从 Buffer 中读取数据</li>
<li>调用 buffer.clear() 方法清除缓冲区（不是清空了数据，只是重置指针）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String str = <span class="string">"seazean"</span>;</span><br><span class="line">		<span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">		ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		System.out.println(<span class="string">"-----------------allocate()----------------"</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//0</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">    buffer.put(str.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"-----------------put()----------------"</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//7</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"-----------------flip()----------------"</span>);</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">        buffer.get(dst);</span><br><span class="line">        System.out.println(dst.length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//5. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">      	System.out.println(<span class="string">"-----------------clear()----------------"</span>);</span><br><span class="line">      	System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">      	System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">      	System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="粘包拆包"><a href="#粘包拆包" class="headerlink" title="粘包拆包"></a>粘包拆包</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔，但这些数据在接收时，被进行了重新组合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello,world\n</span></span><br><span class="line"><span class="comment">// I'm zhangsan\n</span></span><br><span class="line"><span class="comment">// How are you?\n</span></span><br><span class="line">------ &gt; 黏包，半包</span><br><span class="line"><span class="comment">// Hello,world\nI'm zhangsan\nHo</span></span><br><span class="line"><span class="comment">// w are you?\n</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">"Hello,world\nI'm zhangsan\nHo"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">"w are you?\nhaha!\n"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">int</span> oldLimit = source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据数据的长度设置缓冲区</span></span><br><span class="line">            ByteBuffer target = ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            <span class="comment">// debugAll(target); 访问 buffer 的方法</span></span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问过的数据复制到开头</span></span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Byte Buffer 有两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）</p>
<p>Direct Memory 优点：</p>
<ul>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，使用 native 函数直接分配堆外内存</li>
<li><strong>读写性能高</strong>，读写频繁的场合可能会考虑使用直接内存</li>
<li>大大提高 IO 性能，避免了在 Java 堆和 native 堆来回复制数据</li>
</ul>
<p>直接内存缺点：</p>
<ul>
<li>不能使用内核缓冲区 Page Cache 的缓存优势，无法缓存最近被访问的数据和使用预读功能</li>
<li>分配回收成本较高，不受 JVM 内存回收管理</li>
<li>可能导致 OutOfMemoryError 异常：OutOfMemoryError: Direct buffer memory</li>
<li>回收依赖 System.gc() 的调用，但这个调用 JVM 不保证执行、也不保证何时执行，行为是不可控的。程序一般需要自行管理，成对去调用 malloc、free</li>
</ul>
<p>应用场景：</p>
<ul>
<li>传输很大的数据文件，数据的生命周期很长，导致 Page Cache 没有起到缓存的作用，一般采用直接 IO 的方式</li>
<li>适合频繁的 IO 操作，比如网络并发场景</li>
</ul>
<p>数据流的角度：</p>
<ul>
<li>非直接内存的作用链：本地 IO → 内核缓冲区→ 用户（JVM）缓冲区 →内核缓冲区 → 本地 IO</li>
<li>直接内存是：本地 IO → 直接内存 → 本地 IO</li>
</ul>
<p>JVM 直接内存图解：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存直接缓冲区.png" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存非直接缓冲区.png" style="zoom:50%;">



<h4 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h4><p>堆外内存不受 JVM GC 控制，可以使用堆外内存进行通信，防止 GC 后缓冲区位置发生变化的情况</p>
<p>NIO 使用的 SocketChannel 也是使用的堆外内存，源码解析：</p>
<ul>
<li><p>SocketChannel#write(java.nio.ByteBuffer) → SocketChannelImpl#write(java.nio.ByteBuffer)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         var3 = IOUtil.write(<span class="keyword">this</span>.fd, var1, -<span class="number">1L</span>, nd);</span><br><span class="line">     &#125; <span class="keyword">while</span>(var3 == -<span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IOUtil#write(java.io.FileDescriptor, java.nio.ByteBuffer, long, sun.nio.ch.NativeDispatcher)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 【判断是否是直接内存，是则直接写出，不是则封装到直接内存】</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        <span class="comment">// 从堆内buffer拷贝到堆外buffer</span></span><br><span class="line">        ByteBuffer var8 = Util.getTemporaryDirectBuffer(var7);</span><br><span class="line">        var8.put(var1);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 从堆外写到内核缓冲区</span></span><br><span class="line">		<span class="keyword">int</span> var9 = writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读操作相同</p>
</li>
</ul>
<h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><p>直接内存创建 Buffer 对象：<code>static XxxBuffer allocateDirect(int capacity)</code></p>
<p>DirectByteBuffer 源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123; </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配直接内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存赋值</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建回收函数</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分配和回收原理</strong>：</p>
<ul>
<li>使用了 Unsafe 对象的 allocateMemory 方法完成直接内存的分配，setMemory 方法完成赋值</li>
<li>ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory 来释放直接内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存分配的底层原理：Unsafe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_27</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>FileChannel 提供 map 方法返回 MappedByteBuffer 对象，把文件映射到内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射，完成映射后对物理内存的操作会被<strong>同步</strong>到硬盘上</p>
<p>FileChannel 中的成员属性：</p>
<ul>
<li><p>MapMode.mode：内存映像文件访问的方式，共三种：</p>
<ul>
<li><code>MapMode.READ_ONLY</code>：只读，修改得到的缓冲区将导致抛出异常</li>
<li><code>MapMode.READ_WRITE</code>：读/写，对缓冲区的更改最终将写入文件，但此次修改对映射到同一文件的其他程序不一定是可见</li>
<li><code>MapMode.PRIVATE</code>：私用，可读可写，但是修改的内容不会写入文件，只是 buffer 自身的改变</li>
</ul>
</li>
<li><p><code>public final FileLock lock()</code>：获取此文件通道的排他锁</p>
</li>
</ul>
<p>MappedByteBuffer，可以让文件在直接内存（堆外内存）中进行修改，这种方式叫做<strong>内存映射</strong>，可以直接调用系统底层的缓存，没有 JVM 和 OS 之间的复制操作，提高了传输效率，作用：</p>
<ul>
<li><strong>可以用于进程间的通信，能达到共享内存页的作用</strong>，但在高并发下要对文件内存进行加锁，防止出现读写内容混乱和不一致性，Java 提供了文件锁 FileLock，但在父/子进程中锁定后另一进程会一直等待，效率不高</li>
<li>读写那些太大而不能放进内存中的文件，<strong>分段映射</strong></li>
</ul>
<p>MappedByteBuffer 较之 ByteBuffer 新增的三个方法：</p>
<ul>
<li><code>final MappedByteBuffer force()</code>：缓冲区是 READ_WRITE 模式下，对缓冲区内容的修改<strong>强制写入文件</strong></li>
<li><code>final MappedByteBuffer load()</code>：将缓冲区的内容载入物理内存，并返回该缓冲区的引用</li>
<li><code>final boolean isLoaded()</code>：如果缓冲区的内容在物理内存中，则返回真，否则返回假</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读写模式</span></span><br><span class="line">        RandomAccessFile ra = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">// 获取对应的通道</span></span><br><span class="line">        FileChannel channel = ra.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1	FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2	0: 文件映射时的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3	5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        buffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'H'</span>);</span><br><span class="line">        buffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'9'</span>);</span><br><span class="line">        buffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">'Y'</span>);	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        ra.close();</span><br><span class="line">        System.out.println(<span class="string">"修改成功~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从硬盘上将文件读入内存，要经过文件系统进行数据拷贝，拷贝操作是由文件系统和硬件驱动实现。通过内存映射的方法访问硬盘上的文件，拷贝数据的效率要比 read 和 write 系统调用高：</p>
<ul>
<li>read() 是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝</li>
<li>mmap() 也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到共享内存，只进行了一次数据拷贝</li>
</ul>
<p>注意：mmap 的文件映射，在 Full GC 时才会进行释放，如果需要手动清除内存映射文件，可以反射调用 sun.misc.Cleaner 方法</p>
<p>参考文章：<a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">https://www.jianshu.com/p/f90866dcbffc</a></p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>通道（Channel）：表示 IO 源与目标打开的连接，Channel 类似于传统的流，只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer <strong>进行交互</strong></p>
<ol>
<li><p>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
</li>
<li><p>BIO 中的 Stream 是单向的，NIO 中的 Channel 是双向的，可以读操作，也可以写操作</p>
</li>
<li><p>Channel 在 NIO 中是一个接口：<code>public interface Channel extends Closeable{}</code></p>
</li>
</ol>
<p>Channel 实现类：</p>
<ul>
<li><p>FileChannel：用于读取、写入、映射和操作文件的通道，<strong>只能工作在阻塞模式下</strong></p>
<ul>
<li>通过 FileInputStream 获取的 Channel 只能读</li>
<li>通过 FileOutputStream 获取的 Channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
</li>
<li><p>DatagramChannel：通过 UDP 读写网络中的数据通道</p>
</li>
<li><p>SocketChannel：通过 TCP 读写网络中的数据</p>
</li>
<li><p>ServerSocketChannel：可以<strong>监听</strong>新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</p>
<p>提示：ServerSocketChanne 类似 ServerSocket、SocketChannel 类似 Socket</p>
</li>
</ul>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p>获取 Channel 方式：</p>
<ul>
<li>对支持通道的对象调用 <code>getChannel()</code> 方法</li>
<li>通过通道的静态方法 <code>open()</code> 打开并返回指定通道</li>
<li>使用 Files 类的静态方法 <code>newByteChannel()</code> 获取字节通道</li>
</ul>
<p>Channel 基本操作：<strong>读写都是相对于内存来看，也就是缓冲区</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract int read(ByteBuffer dst)</td>
<td>从 Channel 中读取数据到 ByteBuffer，从 position 开始储存</td>
</tr>
<tr>
<td>public final long read(ByteBuffer[] dsts)</td>
<td>将 Channel 中的数据分散到 ByteBuffer[]</td>
</tr>
<tr>
<td>public abstract int write(ByteBuffer src)</td>
<td>将 ByteBuffer 中的数据写入 Channel，从 position 开始写出</td>
</tr>
<tr>
<td>public final long write(ByteBuffer[] srcs)</td>
<td>将 ByteBuffer[] 到中的数据聚集到 Channel</td>
</tr>
<tr>
<td>public abstract long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long newPosition)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>public abstract long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
</tbody></table>
<p><strong>SelectableChannel 的操作 API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SocketChannel accept()</td>
<td>如果通道处于非阻塞模式，没有请求连接时此方法将立即返回 NULL，否则将阻塞直到有新的连接或发生 I/O 错误，<strong>通过该方法返回的套接字通道将处于阻塞模式</strong></td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops)</td>
<td>将通道注册到选择器上，并指定监听事件</td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops, Object att)</td>
<td>将通道注册到选择器上，并在当前通道<strong>绑定一个附件对象</strong>，Object 代表可以是任何类型</td>
</tr>
</tbody></table>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> 		<span class="comment">// 1、字节输出流通向目标文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        <span class="comment">// 2、得到字节输出流对应的通道  【FileChannel】</span></span><br><span class="line">        FileChannel channel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、分配缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="string">"hello,黑马Java程序员！"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4、把缓冲区切换成写出模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">"写数据到文件中！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        <span class="comment">// 2、需要得到文件字节输入流的文件通道</span></span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义一个缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、读取数据到缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 5、读取出缓冲区中的数据并输出即可</span></span><br><span class="line">        String rs = <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,buffer.remaining());</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>Channel 的方法：<strong>sendfile 实现零拷贝</strong></p>
<ul>
<li><p><code>abstract long transferFrom(ReadableByteChannel src, long position, long count)</code>：从给定的可读字节通道将字节传输到该通道的文件中</p>
<ul>
<li>src：源通道</li>
<li>position：文件中要进行传输的位置，必须是非负的 </li>
<li>count：要传输的最大字节数，必须是非负的 </li>
</ul>
</li>
<li><p><code>abstract long transferTo(long position, long count, WritableByteChannel target)</code>：将该通道文件的字节传输到给定的可写字节通道。</p>
<ul>
<li>position：传输开始的文件中的位置; 必须是非负的 </li>
<li>count：要传输的最大字节数; 必须是非负的 </li>
<li>target：目标通道 </li>
</ul>
</li>
</ul>
<p>文件复制的两种方式：</p>
<ol>
<li>Buffer</li>
<li>使用上述两种方法</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"C:\\壁纸.jpg"</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\壁纸new.jpg"</span>);</span><br><span class="line">        <span class="comment">// 得到一个字节字节输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        <span class="comment">// 得到一个字节输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="comment">// 得到的是文件通道</span></span><br><span class="line">        FileChannel isChannel = fis.getChannel();</span><br><span class="line">        FileChannel osChannel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 必须先清空缓冲然后再写入数据到缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 开始读取一次数据</span></span><br><span class="line">            <span class="keyword">int</span> flag = isChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(flag == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 把数据写出到</span></span><br><span class="line">            osChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">"复制完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">   	 	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">   	 	FileChannel isChannel = fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data03.txt"</span>);</span><br><span class="line">    	FileChannel osChannel = fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">    	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">    	FileChannel isChannel = fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data04.txt"</span>);</span><br><span class="line">    	FileChannel osChannel = fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分散聚集"><a href="#分散聚集" class="headerlink" title="分散聚集"></a>分散聚集</h4><p>分散读取（Scatter ）：是指把 Channel 通道的数据读入到多个缓冲区中去</p>
<p>聚集写入（Gathering ）：是指将多个 Buffer 中的数据聚集到 Channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        FileChannel isChannel = is.getChannel();</span><br><span class="line">        <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data02.txt"</span>);</span><br><span class="line">        FileChannel osChannel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义多个缓冲区做数据分散</span></span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        ByteBuffer[] buffers = &#123;buffer1 , buffer2&#125;;</span><br><span class="line">        <span class="comment">// 4、从通道中读取数据分散到各个缓冲区</span></span><br><span class="line">        isChannel.read(buffers);</span><br><span class="line">        <span class="comment">// 5、从每个缓冲区中查询是否有数据读取到了</span></span><br><span class="line">        <span class="keyword">for</span>(ByteBuffer buffer : buffers)&#123;</span><br><span class="line">            buffer.flip();<span class="comment">// 切换到读数据模式</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer.array() , <span class="number">0</span> , buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、聚集写入到通道</span></span><br><span class="line">        osChannel.write(buffers);</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">"文件复制~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>选择器（Selector） 是 SelectableChannle 对象的<strong>多路复用器</strong>，Selector 可以同时监控多个通道的状况，利用 Selector 可使一个单独的线程管理多个 Channel，<strong>Selector 是非阻塞 IO 的核心</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Selector.png" alt></p>
<ul>
<li>Selector 能够检测多个注册的通道上是否有事件发生（多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，就获取事件然后针对每个事件进行相应的处理，就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><p>创建 Selector：<code>Selector selector = Selector.open();</code></p>
<p>向选择器注册通道：<code>SelectableChannel.register(Selector sel, int ops, Object att)</code></p>
<ul>
<li>参数一：选择器，指定当前 Channel 注册到的选择器</li>
<li>参数二：选择器对通道的监听事件，监听的事件类型用四个常量表示<ul>
<li>读 : SelectionKey.OP_READ （1）</li>
<li>写 : SelectionKey.OP_WRITE （4）</li>
<li>连接 : SelectionKey.OP_CONNECT （8）</li>
<li>接收 : SelectionKey.OP_ACCEPT （16）</li>
<li>若不止监听一个事件，使用位或操作符连接：<code>int interest = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>
</ul>
</li>
<li>参数三：可以关联一个附件，可以是任何对象</li>
</ul>
<p><strong>Selector API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Selector open()</td>
<td>打开选择器</td>
</tr>
<tr>
<td>public abstract void close()</td>
<td>关闭此选择器</td>
</tr>
<tr>
<td>public abstract int select()</td>
<td><strong>阻塞</strong>选择一组通道准备好进行 I/O 操作的键</td>
</tr>
<tr>
<td>public abstract int select(long timeout)</td>
<td><strong>阻塞</strong>等待 timeout 毫秒</td>
</tr>
<tr>
<td>public abstract int selectNow()</td>
<td>获取一下，<strong>不阻塞</strong>，立刻返回</td>
</tr>
<tr>
<td>public abstract Selector wakeup()</td>
<td>唤醒正在阻塞的 selector</td>
</tr>
<tr>
<td>public abstract Set<selectionkey> selectedKeys()</selectionkey></td>
<td>返回此选择器的选择键集</td>
</tr>
</tbody></table>
<p>SelectionKey API:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract void cancel()</td>
<td>取消该键的通道与其选择器的注册</td>
</tr>
<tr>
<td>public abstract SelectableChannel channel()</td>
<td>返回创建此键的通道，该方法在取消键之后仍将返回通道</td>
</tr>
<tr>
<td>public final Object attachment()</td>
<td>返回当前 key 关联的附件</td>
</tr>
<tr>
<td>public final boolean isAcceptable()</td>
<td>检测此密钥的通道是否已准备好接受新的套接字连接</td>
</tr>
<tr>
<td>public final boolean isConnectable()</td>
<td>检测此密钥的通道是否已完成或未完成其套接字连接操作</td>
</tr>
<tr>
<td>public final boolean isReadable()</td>
<td>检测此密钥的频道是否可以阅读</td>
</tr>
<tr>
<td>public final boolean isWritable()</td>
<td>检测此密钥的通道是否准备好进行写入</td>
</tr>
</tbody></table>
<p>基本步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取通道</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//2.切换非阻塞模式</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3.绑定连接</span></span><br><span class="line">ssChannel.bin(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="comment">//4.获取选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//5.将通道注册到选择器上，并且指定“监听接收事件”</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<h3 id="NIO实现"><a href="#NIO实现" class="headerlink" title="NIO实现"></a>NIO实现</h3><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li><p>SelectableChannel_API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final SelectableChannel configureBlocking(boolean block)</td>
<td>设置此通道的阻塞模式</td>
</tr>
<tr>
<td>public final SelectionKey register(Selector sel, int ops)</td>
<td>向给定的选择器注册此通道，并选择关注的的事件</td>
</tr>
</tbody></table>
</li>
<li><p>SocketChannel_API：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public static SocketChannel open()</td>
<td>打开套接字通道</td>
</tr>
<tr>
<td align="left">public static SocketChannel open(SocketAddress remote)</td>
<td>打开套接字通道并连接到远程地址</td>
</tr>
<tr>
<td align="left">public abstract boolean connect(SocketAddress remote)</td>
<td>连接此通道的到远程地址</td>
</tr>
<tr>
<td align="left">public abstract SocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getLocalAddress()</td>
<td>返回套接字绑定的本地套接字地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getRemoteAddress()</td>
<td>返回套接字连接的远程套接字地址</td>
</tr>
</tbody></table>
</li>
<li><p>ServerSocketChannel_API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ServerSocketChannel open()</td>
<td>打开服务器套接字通道</td>
</tr>
<tr>
<td>public final ServerSocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址，并配置套接字以监听连接</td>
</tr>
<tr>
<td>public abstract SocketChannel accept()</td>
<td>接受与此通道套接字的连接，通过此方法返回的套接字通道将处于阻塞模式</td>
</tr>
</tbody></table>
<ul>
<li>如果 ServerSocketChannel 处于非阻塞模式，如果没有挂起连接，则此方法将立即返回 null</li>
<li>如果通道处于阻塞模式，如果没有挂起连接将无限期地阻塞，直到有新的连接或发生 I/O 错误</li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>服务端 ：</p>
<ol>
<li><p>获取通道，当客户端连接服务端时，服务端会通过 <code>ServerSocketChannel.accept</code> 得到 SocketChannel </p>
</li>
<li><p>切换非阻塞模式</p>
</li>
<li><p>绑定连接</p>
</li>
<li><p>获取选择器</p>
</li>
<li><p>将通道注册到选择器上，并且指定监听接收事件</p>
</li>
<li><p><strong>轮询式</strong>的获取选择器上已经准备就绪的事件</p>
</li>
</ol>
<p>客户端：</p>
<ol>
<li>获取通道：<code>SocketChannel sc = SocketChannel.open(new InetSocketAddress(HOST, PORT))</code></li>
<li>切换非阻塞模式</li>
<li>分配指定大小的缓冲区：<code>ByteBuffer buffer = ByteBuffer.allocate(1024)</code></li>
<li>发送数据给服务端</li>
</ol>
<p>37 行代码，如果判断条件改为 !=-1，需要客户端 close 一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 2、切换为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3、绑定连接的端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4、获取选择器Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 5、将通道都注册到选择器上去，并且开始指定监听接收事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		<span class="comment">// 6、使用Selector选择器阻塞等待轮已经就绪好的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"----开始新一轮的时间处理----"</span>);</span><br><span class="line">            <span class="comment">// 7、获取选择器中的所有注册的通道中已经就绪好的事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 8、开始遍历这些准备好的事件</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = it.next();<span class="comment">// 提取当前这个事件</span></span><br><span class="line">                <span class="comment">// 9、判断这个事件具体是什么</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 10、直接获取当前接入的客户端通道</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">// 11 、切换成非阻塞模式</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     ByteBuffer buffer = ByteBuffer.allocate(16);</span></span><br><span class="line"><span class="comment">                	 // 将一个 byteBuffer 作为附件【关联】到 selectionKey 上</span></span><br><span class="line"><span class="comment">                	 SelectionKey scKey = sc.register(selector, 0, buffer);</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 12、将本客户端通道注册到选择器</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 13、获取当前选择器上的读就绪事件</span></span><br><span class="line">                    SelectableChannel channel = key.channel();</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) channel;</span><br><span class="line">                    <span class="comment">// 14、读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 获取关联的附件</span></span><br><span class="line">                    <span class="comment">// ByteBuffer buffer = (ByteBuffer) key.attachment();</span></span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress() + <span class="string">":"</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buffer.clear();<span class="comment">// 清除之前的数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 删除当前的 selectionKey，防止重复操作</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 2、切换成非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3、分配指定缓冲区大小</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、发送数据给服务端</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            String msg = sc.nextLine();</span><br><span class="line">            buffer.put((<span class="string">"Client："</span> + msg).getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/76/">76</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>