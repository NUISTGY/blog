<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">223</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">82</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/14/Nginx_load_balancing/">Nginx 负载均衡</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h1><p><strong>负载均衡</strong></p>
<p>负载均衡是实际开发必须掌握的技能，Nginx 如何将少数请求跟多台服务器进行沟通，让每一台服务器的请求处理面面俱到？本内容将学习 Nginx 的负载均衡知识。</p>
<h2 id="负载均衡概述"><a href="#负载均衡概述" class="headerlink" title="负载均衡概述"></a>负载均衡概述</h2><p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？这就需要负载均衡来处理。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.5kgql84ikx80.webp" alt="image"></p>
<h2 id="负载均衡原理及处理流程"><a href="#负载均衡原理及处理流程" class="headerlink" title="负载均衡原理及处理流程"></a>负载均衡原理及处理流程</h2><p>系统的扩展可以分为纵向扩展和横向扩展。</p>
<ul>
<li>纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力</li>
<li>横向扩展是通过添加机器来满足大型网站服务的处理能力</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.1xwd1pm6du68.webp" alt="image"></p>
<p>如上图，负载均衡涉及到两个重要的角色分别是「应用集群」和「负载均衡器」。</p>
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据</li>
<li>负载均衡器：将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理</li>
</ul>
<h3 id="负载均衡作用"><a href="#负载均衡作用" class="headerlink" title="负载均衡作用"></a>负载均衡作用</h3><ul>
<li>解决服务器的高并发压力，提高应用程序的处理性能</li>
<li>提供故障转移，实现高可用</li>
<li>通过添加或减少服务器数量，增强网站的可扩展性</li>
<li>在负载均衡器上进行过滤，可以提高系统的安全性</li>
</ul>
<h2 id="负载均衡常用处理方式"><a href="#负载均衡常用处理方式" class="headerlink" title="负载均衡常用处理方式"></a>负载均衡常用处理方式</h2><p>先说明，我们常用的是 <a href="/middleware/Nginx/Nginx_load_balancing/#四-七层负载均衡">四/七层负载均衡</a> 方式，前面两个方式可以了解。</p>
<h3 id="用户手动选择"><a href="#用户手动选择" class="headerlink" title="用户手动选择"></a>用户手动选择</h3><p>这种方式比较原始，主要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p>
<p>如下图，用户点击不同的下载方式，就会跳转到不同的下载地址。这是主动式的负载均衡，我们无法控制用户的选择。如果用户全部点击第一个下载方式，那么服务器的压力将非常大。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.2auhoddxb2zo.webp" alt="image"></p>
<h3 id="DNS轮询方式"><a href="#DNS轮询方式" class="headerlink" title="DNS轮询方式"></a>DNS轮询方式</h3><p>DNS：域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换。</p>
<p>大多域名注册商都支持对同一个主机名添加多条 A 记录，这就是 DNS 轮询，DNS 服务器将解析请求按照 A 记录的顺序，随机分配到不同的 IP 上，这样就能完成简单的负载均衡。DNS 轮询的成本非常低，在一些不重要的服务器，被经常使用。</p>
<p>如下图：客户端如果想访问服务器集群，首先去 DNS 服务器获取我们曾经在 DNS 服务器保存的「记录表」，这个「记录表」将会把某个服务器的地址返回给客户端，客户端再根据这个地址，访问指定的服务器。这个「记录表」在开始期间需要我们去 DNS 服务器进行添加。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.b1m3qaeuxsk.webp" alt="image"></p>
<p>「记录表」长什么样，如下图的主机记录 www。这是我为某一个域名添加的 IP 地址，用 2 台服务器来做负载均衡。其中两个记录值都绑定了 <code>www.nginx521.cn</code> 地址。(一个域名可以绑定多个IP地址)</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.3drj9szeeus0.webp" alt="image"></p>
<p>验证:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.nginx521.cn</span><br></pre></td></tr></table></figure>

<p>注意：记得清空本地的 DNS 缓存，如果本地有缓存，无论你怎么 <code>ping</code>，都会 <code>ping</code> 到缓存的服务器地址，无法负载均衡</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure>

<p>目前需要 <code>ping</code> 一次然后清理一次缓存，才能实现负载均衡的轮询效果。</p>
<p>我们发现使用 DNS 来实现轮询，不需要投入过多的成本，虽然 DNS 轮询成本低廉，但是 DNS 负载均衡存在明显的缺点：</p>
<ol>
<li><p>可靠性低</p>
<p>假设一个域名 DNS 轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的 IP 从 DNS 中去掉，但是由于各大宽带接入商将众多的 DNS 存放在缓存中，以节省访问时间，导致 DNS 不会实时更新。所以 DNS 轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p>
</li>
<li><p>负载均衡不均衡</p>
<p>DNS 负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到 IP 地址的映射，这也会导致使用该 DNS 服务器的用户在一定时间内访问的是同一台 Web 服务器，从而引发 Web 服务器减的负载不均衡。</p>
<p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p>
</li>
</ol>
<h3 id="四-七层负载均衡"><a href="#四-七层负载均衡" class="headerlink" title="四/七层负载均衡"></a>四/七层负载均衡</h3><p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection)，叫开放式系统互联模型，这个是由国际标准化组织 ISO 指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.5g3vvj5xa3g0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.6uq265ihol80.webp" alt="image"></p>
<ul>
<li>应用层：为应用程序提供网络服务。</li>
<li>表示层：对数据进行格式化、编码、加密、压缩等操作</li>
<li>会话层：建立、维护、管理会话连接</li>
<li>传输层：建立、维护、管理端到端的连接，常见的有 TCP/UDP</li>
<li>网络层：IP 寻址和路由选择</li>
<li>数据链路层：控制网络层与物理层之间的通信</li>
<li>物理层：比特流传输</li>
</ul>
<p><strong>什么是四层负载均衡</strong></p>
<p>所谓四层负载均衡指的是 OSI 七层模型中的传输层，主要是基于 IP + PORT 的负载均衡</p>
<p>实现四层负载均衡的方式：</p>
<ul>
<li>硬件：F5 BIG-IP、Radware 等，性能好，成本高、无法扩展</li>
<li>软件：LVS、Nginx、Hayproxy 等，性能较好，成本低、可以扩展</li>
</ul>
<p><strong>什么是七层负载均衡</strong></p>
<p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的 URL 或主机 IP 的负载均衡</p>
<p>实现七层负载均衡的方式：</p>
<ul>
<li>软件：Nginx、Hayproxy 等</li>
</ul>
<p><strong>四层和七层负载均衡的区别</strong></p>
<ul>
<li>四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高（四层比七层少，速度块，效率高，但是可能请求丢失等）</li>
<li>四层负载均衡不识别域名，而七层负载均衡识别域名</li>
</ul>
<p>处理四层和七层负载以外，其实还有二层、三层负载均衡，二层是在数据链路层基于 mac 地址来实现负载均衡，三层是在网络层一般采用虚拟 IP 地址的方式实现负载均衡。</p>
<p><strong>实际环境采用的模式：四层负载(LVS) + 七层负载(Nginx)</strong></p>
<h2 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h2><p>Nginx 要实现七层负载均衡需要用到 proxy_pass 代理模块配置。Nginx 默认安装支持这个模块，我们不需要再做任何处理。Nginx 的负载均衡是在 Nginx 反向代理的基础上把用户的请求根据指定的算法分发到一组「upstream 虚拟服务池」。</p>
<h3 id="七层负载均衡指令"><a href="#七层负载均衡指令" class="headerlink" title="七层负载均衡指令"></a>七层负载均衡指令</h3><h4 id="upstream指令"><a href="#upstream指令" class="headerlink" title="upstream指令"></a>upstream指令</h4><p>该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听 TCP 和 Unix socket 的服务器。服务器可以指定不同的权重，默认为 1。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>upstream &lt;name&gt; {…}</td>
<td>—</td>
<td>http</td>
</tr>
</tbody></table>
<h4 id="server指令"><a href="#server指令" class="headerlink" title="server指令"></a>server指令</h4><p>该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者 Unix socket。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>server &lt;name&gt; [paramerters]</td>
<td>—</td>
<td>upstream</td>
</tr>
</tbody></table>
<p>server 后的 name 就是 upstream 后的 name，两者保持一致。</p>
<h3 id="七层负载均衡指令案例"><a href="#七层负载均衡指令案例" class="headerlink" title="七层负载均衡指令案例"></a>七层负载均衡指令案例</h3><p>准备四台服务器，一台用来做负载均衡器，三台用来接收负载均衡器的请求。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.etsfgkwsxaw.webp" alt="image"></p>
<p>因为目前只有两台服务器，所以一台用来做负载均衡器，另外一台用来接收负载均衡器的请求。</p>
<p>服务器设置：这里以三个端口代替三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器 1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 服务器 2</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9002</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 服务器 3</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9003</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负载均衡器设置：这是一个 Nginx 代理服务器，让它去负载均衡访问三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9091</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9092</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9093</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;   <span class="comment"># backend 要对应上 upstream 后的值，根据需求修改</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问负载均衡器的地址，如 <code>http://192.168.200.133:8083</code>，它会找到 <code>proxy_pass</code> 后的地址，比如上方，它会根据 backend 找到对应的 upstream 里内地址，替换掉 backend，变成：</p>
<ul>
<li>proxy_pass <code>http://192.168.200.146:9091</code></li>
<li>proxy_pass <code>http://192.168.200.146:9092</code></li>
<li>proxy_pass <code>http://192.168.200.146:9093</code></li>
</ul>
<p>但是它不会全部访问三个服务器地址，而是根据自己的算法（轮询）选择其中一个服务器地址。</p>
<h3 id="七层负载均衡状态"><a href="#七层负载均衡状态" class="headerlink" title="七层负载均衡状态"></a>七层负载均衡状态</h3><p>代理服务器在负责均衡调度中的状态有以下几个：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>down</td>
<td>当前的 server 暂时不参与负载均衡</td>
</tr>
<tr>
<td>backup</td>
<td>预留的备份服务器</td>
</tr>
<tr>
<td>max_fails</td>
<td>允许请求失败的次数</td>
</tr>
<tr>
<td>fail_timeout</td>
<td>经过 max_fails 失败后，服务暂停时间</td>
</tr>
<tr>
<td>max_conns</td>
<td>限制最大的接收连接数</td>
</tr>
</tbody></table>
<h4 id="down"><a href="#down" class="headerlink" title="down"></a>down</h4><p><code>down</code> 指令将该服务器标记为永久不可用，那么负载均衡器将不参与该服务器的负载均衡。</p>
<p>如下，如果不希望负载均衡器以负载均衡来处理 <code>192.168.200.146</code> 服务器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该状态一般会对需要停机维护的服务器进行设置。</p>
<h4 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h4><p><code>backup</code> 指令将该服务器标记为备份服务器，当主服务器不可用时，才用备份服务器来传递请求。</p>
<p>它不同于 down 指令，down 指令将服务器永久禁止，而 backp 指令仅仅临时禁止，当主服务器不可用后，临时禁止的服务器就会站出来。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中 9001 服务器永久禁止，而 9002 服务器是备份服务器，所以 9003 服务器是主服务器。</p>
<p>此时需要将 9003 端口的访问禁止掉，用它来模拟当唯一对外提供访问的服务宕机以后，backup 的备份服务器就能开始对外提供服务。</p>
<p>为了测试验证，我们需要使用防火墙来进行拦截。</p>
<p>介绍一个工具 <code>firewall-cmd</code>，该工具是 Linux 提供的专门用来操作 firewall 防火墙的。</p>
<p>查询防火墙中指定的端口是否开放</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=9001/tcp</span><br></pre></td></tr></table></figure>

<p>开放一个指定的端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9002/tcp</span><br></pre></td></tr></table></figure>

<p>批量添加开发端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9001-9003/tcp</span><br></pre></td></tr></table></figure>

<p>如何移除一个指定的端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=9003/tcp</span><br></pre></td></tr></table></figure>

<p>重新加载</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>--permanent</code> 表示设置为持久</li>
<li><code>--add-port</code> 表示添加指定端口</li>
<li><code>--remove-port</code> 表示移除指定端口</li>
</ul>
<p>经过测试，禁用掉 9003 端口后，再次访问负载均衡器，它只会请求 9002 端口的服务器(备份服务器)，而恢复 9003 端口，只会请求 9003 端口的服务器。</p>
<h4 id="max-conns"><a href="#max-conns" class="headerlink" title="max_conns"></a>max_conns</h4><p><code>max_conns</code> 指令用来限制同时连接到 upstream 负载上的单个服务器的最大连接数。默认为 0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>max_conns=&lt;number&gt;</td>
<td>0</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> max_conns=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 4 行配置标识 9003 端口的服务器最大能被 2 个客户端请求。</p>
<h4 id="max-fails和fail-timeout"><a href="#max-fails和fail-timeout" class="headerlink" title="max_fails和fail_timeout"></a>max_fails和fail_timeout</h4><p><code>max_fails</code> 指令设置允许请求代理服务器失败的次数，默认为 1。</p>
<p><code>fail_timeout</code> 指令设置经过 max_fails 失败后，服务暂停的时间，默认是 10 秒。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>max_fails=&lt;number&gt;</td>
<td>1</td>
<td>upstream</td>
</tr>
<tr>
<td>fail_timeout=&lt;time&gt;</td>
<td>10 秒</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字</li>
<li>time 是时间，单位为秒</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9003</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七层负载均衡策略"><a href="#七层负载均衡策略" class="headerlink" title="七层负载均衡策略"></a>七层负载均衡策略</h3><p>介绍完 Nginx 负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法？</p>
<p>Nginx 的 upstream 支持如下六种方式的分配算法，分别是:</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据 IP 分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据 URL 分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
</tr>
</tbody></table>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>这是 <code>upstream</code> 模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="weight加权-加权轮询"><a href="#weight加权-加权轮询" class="headerlink" title="weight加权[加权轮询]"></a>weight加权[加权轮询]</h4><p><code>weight</code> 指令用来设置服务器的权重，默认为 1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>weight=&lt;number&gt;</td>
<td>1</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> weight=<span class="number">10</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> weight=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>当对后端的多台动态应用服务器做负载均衡时，<code>ip_hash</code> 指令能够将某个客户端 IP 的请求通过哈希算法定位到同一台后端服务器上。</p>
<p>这样，当来自某一个 IP 的用户在后端 Web 服务器 A 上登录后，在访问该站点的其他 URL，能保证其访问的还是后端 Web 服务器 A</p>
<p>总结：哪个服务器曾经处理过请求，无论在哪里，相同的请求依然让该服务器处理</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ip_hash;</td>
<td>—</td>
<td>upstream</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要额外多说一点的是使用 ip_hash 指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.7a0ysgphfxg0.webp" alt="image"></p>
<h4 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h4><p>最少连接数，把请求转发给连接数较少的后端服务器。</p>
<p>轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，<code>least_conn</code> 这种方式就可以达到更好的负载均衡效果。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	least_conn;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.5vug3q9whrc0.webp" alt="image"></p>
<h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>按访问 URL 的 hash 结果来分配请求，使每个 URL 定向到同一个后端服务器，要配合缓存命中来使用。</p>
<p>当出现同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费时，使用 <code>url_hash</code>，可以使得同一个 URL（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p>
<p>总结：发送相同的请求时，希望只有一个服务器处理该请求，使用 <code>uri_hash</code>。因为 URL 相同，则哈希值(hash)相同，那么哈希值对应的服务器也相同。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">hash</span> &amp;request_uri;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图：文件系统有一个文件，目前只有 web 服务 1 和服务 3 获取了该文件，那么我们想要下载这个文件时，只能找服务 1 或服务 3，这时候就固定一个 URL，该 URL 不允许服务 2 进行处理，那么如何规定哪个服务处理呢？就用到 <code>url_hash</code>。</p>
<p>它会根据 URL 计算处哈希值，由哈希值对应服务，所以固定下载文件的 URL，就固定了一个服务处理。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.utb83x535xc.webp" alt="image"></p>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p><code>fair</code> 指令采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。</p>
<p>那么如何使用第三方模块的 fair 负载均衡策略？</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nupstream</span> backend&#123;</span><br><span class="line">	fair;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样直接使用会报错，因为 fair 属于第三方模块实现的负载均衡。需要添加 <code>nginx-upstream-fair</code> 模块，如何添加对应的模块：</p>
<ol>
<li>下载 <code>nginx-upstream-fair</code> 模块，下载地址如下：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gnosek/nginx-upstream-fair</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将下载的文件上传到服务器并进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入安装包目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip nginx-upstream-fair-master.zip</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>我的解压目录在 <code>/opt</code>，所以第 6 步记得指定好模块的路径。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx-upstream-fair-master fair</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/nginx/core/nginx-1.21.6</span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>使用 configure 来配置参数，添加模块，记得加上第（4）步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/opt/fair  <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>通过 make 模板进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译可能会出现如下错误，<code>ngx_http_upstream_srv_conf_t</code> 结构中缺少 <code>default_port</code></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.vj3xrayy84g.webp" alt="image"></p>
<p>解决方案：</p>
<p>在 Nginx 的源码目录（安装包目录）中 <code>src/http/ngx_http_upstream.h</code>，找到 <code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加 <code>default_port</code> 属性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/nginx/core/nginx-1.21.6/src/http/ngx_http_upstream.h</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_port_t	   default_port</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.1mcquncem2u8.webp" alt="image"></p>
<p>然后再进行 make。</p>
<ol start="9">
<li>将安装目录下的 objs 中的 nginx 拷贝到 sbin 目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6/objs</span><br><span class="line">cp nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>10 .更新nginx</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<p>上面介绍了 Nginx 常用的负载均衡的策略，有人说是 5 种，是把轮询和加权轮询归为一种，也有人说是 6 种。那么在咱们以后的开发中到底使用哪种，这个需要根据实际项目的应用场景来决定的。</p>
<h3 id="七层负载均衡案例"><a href="#七层负载均衡案例" class="headerlink" title="七层负载均衡案例"></a>七层负载均衡案例</h3><h4 id="案例一：对所有请求实现一般轮询规则的负载均衡"><a href="#案例一：对所有请求实现一般轮询规则的负载均衡" class="headerlink" title="案例一：对所有请求实现一般轮询规则的负载均衡"></a>案例一：对所有请求实现一般轮询规则的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例二：对所有请求实现加权轮询规则的负载均衡"><a href="#案例二：对所有请求实现加权轮询规则的负载均衡" class="headerlink" title="案例二：对所有请求实现加权轮询规则的负载均衡"></a>案例二：对所有请求实现加权轮询规则的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> weight=<span class="number">7</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> weight=<span class="number">3</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理请求概率：9001 端口 &gt; 9003 端口 &gt; 9002 端口</p>
<h4 id="案例三：对特定资源实现负载均衡"><a href="#案例三：对特定资源实现负载均衡" class="headerlink" title="案例三：对特定资源实现负载均衡"></a>案例三：对特定资源实现负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> videobackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> filebackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9004</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8084</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /video/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://videobackend;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /file/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://filebackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送 <code>/video/</code> 请求会被 9001 和 9002 端口的服务器处理。</p>
<p>发送 <code>/file/</code> 请求会被 9003 和 9004 端口的服务器处理。</p>
<h4 id="案例四：对不同域名实现负载均衡"><a href="#案例四：对不同域名实现负载均衡" class="headerlink" title="案例四：对不同域名实现负载均衡"></a>案例四：对不同域名实现负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> frxbackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> bingbackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9004</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">8085</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://frxbackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">8086</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.bing.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://bingbackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>www.frx.com</code> 地址的请求由 9001 端口和 9002 端口处理。</p>
<p><code>www.bing.com</code> 地址的请求由 9003 端口和 9004 端口处理。</p>
<h4 id="案例五：实现带有URL重写的负载均衡"><a href="#案例五：实现带有URL重写的负载均衡" class="headerlink" title="案例五：实现带有URL重写的负载均衡"></a>案例五：实现带有URL重写的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /file/ &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^(/file/.*)</span> /server/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>/file/xxx</code> 请求重写为 <code>/server/xxx</code>，然后触发 <code>location /server</code>，实现负载均衡。</p>
<p>此时被负载均衡的服务器地址也会带有 <code>/server</code> 以及后面的参数，如 <code>192.168.200.146:9001/server/xxx</code></p>
<h2 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h2><p>Nginx 在 1.9 之后，增加了一个 stream 模块，用来实现四层协议的转发、代理、负载均衡等。stream 模块的用法跟 http 的用法类似，允许我们配置一组 TCP 或者 UDP 等协议的监听，然后通过 proxy_pass 来转发我们的请求，通过 upstream 添加多个后端服务，实现负载均衡。</p>
<p>四层协议负载均衡的实现，一般都会用到 LVS、HAProxy、F5 等，要么很贵要么配置很麻烦，而 Nginx 的配置相对来说更简单，更能快速完成工作。</p>
<h3 id="添加stream模块的支持"><a href="#添加stream模块的支持" class="headerlink" title="添加stream模块的支持"></a>添加stream模块的支持</h3><p>Nginx 默认是没有编译这个模块的，需要使用到 stream 模块，那么需要在编译的时候加上 <code>--with-stream</code>。</p>
<p>完成添加 <code>--with-stream</code> 的实现步骤：</p>
<ul>
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
<li>拷贝 <code>Nginx -V</code> 的 configure arguments 配置信息</li>
<li>在 Nginx 的安装源码进行配置指定对应模块：<code>./configure --with-stream 加上一步拷贝的configure arguments 配置</code></li>
<li>通过 make 模板进行编译</li>
<li>将 objs 下面的 nginx 移动到 <code>/usr/local/nginx/sbin</code> 下</li>
<li>在源码目录下执行 <code>make upgrade</code> 进行升级，这个可以实现不停机添加新模块的功能</li>
</ul>
<p>添加模块的详细步骤我已经在 <a href>七层负载均衡策略-fair 指令</a>、<a href>静态资源部署-Nginx 模块添加</a>、<a href>反向代理-添加ssl支持</a> 描述过，而你只需要替换模块名字罢了。</p>
<h3 id="四层负载均衡指令"><a href="#四层负载均衡指令" class="headerlink" title="四层负载均衡指令"></a>四层负载均衡指令</h3><p>如果不想在 http 模块使用负载均衡，可以在 steam 模块使用。</p>
<h4 id="stream指令"><a href="#stream指令" class="headerlink" title="stream指令"></a>stream指令</h4><p>该指令提供在其中指定流服务器指令的配置文件上下文。和 http 模块同级。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>stream { … }</td>
<td>—</td>
<td>main</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> backend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="upstream指令-1"><a href="#upstream指令-1" class="headerlink" title="upstream指令"></a>upstream指令</h4><p>该指令和七层负载均衡的 upstream 指令是类似的。</p>
<h3 id="四层负载均衡的案例"><a href="#四层负载均衡的案例" class="headerlink" title="四层负载均衡的案例"></a>四层负载均衡的案例</h3><p>准备两台服务器，这里称为 A 和 B。服务器 A 的 IP 为 <code>192.168.200.146</code>，服务器 B 的IP 为 <code>192.168.200.133</code>，服务器 A 存放 Redis 和 Tomcat，服务器 B 作为负载均衡器，对服务器 A 的端口进行负载均衡处理。</p>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.6yak0csdt880.webp" alt="image"></p>
<h4 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h4><p>准备 Redis 服务器,在服务器 A 上准备两个 Redis，端口分别是 6379、6378。</p>
<ol>
<li>上传 redis 的安装包 <code>redis-4.0.14.tar.gz</code>，这里上传目录是 <code>/opt</code></li>
<li>将安装包进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-4.0.14.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入redis的安装包</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-4.0.14</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 make 和 install 进行编译和安装，这里的安装路径是 <code>/usr/local/redis/redis01</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis/redis01 install</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>拷贝 redis 配置文件 <code>redis.conf</code> 到 <code>/usr/local/redis/redis01/bin</code> 目录中，因为安装后，目录并没有 redis.conf</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-4.0.14/redis.conf	/usr/<span class="built_in">local</span>/redis/redis01/bin</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改 redis.conf 配置文件，注意：不是添加内容，是修改内容，要自己搜索 bind、port 和 daemonize 进行修改</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0   <span class="comment"># 允许任意地址访问</span></span><br><span class="line">port  6379      <span class="comment"># redis 的端口</span></span><br><span class="line">daemonize yes   <span class="comment"># 后台启动 redis</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 redis01 复制一份为 redis02</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis</span><br><span class="line">cp -r redis01 redis02</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>将 redis02 文件夹中的 redis.conf 进行修改，注意：不是添加内容，是修改内容，要自己搜索 bind、port 和 daemonize 进行修改</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0   <span class="comment"># 允许任意地址访问</span></span><br><span class="line">port  6378      <span class="comment"># redis 的端口</span></span><br><span class="line">daemonize yes   <span class="comment"># 后台启动 redis</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>分别启动，即可获取两个 Redis 并查看</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p>使用 Nginx 将请求分发到不同的 Redis 服务器上。</p>
<p>安装 Redis 并验证能启动成功后，在另一台服务器 B <code>192.168.200.133</code> 的 Nginx 配置文件添加如下内容：（确保安装了 steam 模块）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> redisbackend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;   <span class="comment"># 服务器 B 的 6379 端口</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;   <span class="comment"># 服务器 B 的 6378 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> redisbackend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时利用 redis-cli 连接测试</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.cbee2u83yhs.webp" alt="image"></p>
<p>服务器 B 通过负载均衡连接到了服务器 A 的 Redis，只是不知道连接的是 6378 还是 6379 端口，可以在 Redis 添加不一样的数据来测试，这里不演示了。</p>
<h4 id="Tomcat-配置"><a href="#Tomcat-配置" class="headerlink" title="Tomcat 配置"></a>Tomcat 配置</h4><p>准备 Tomcat 服务器 到服务器 A</p>
<ol>
<li>上传 tomcat 的安装包，<code>apache-tomcat-8.5.56.tar.gz</code></li>
<li>将安装包进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf apache-tomcat-8.5.56.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 tomcat 的 bin 目录，启动 tomcat</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> apache-tomcat-8.5.56/bin</span><br><span class="line">./startup</span><br></pre></td></tr></table></figure>

<p>服务器 B 的配置文件 nginx.conf 配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> redisbackend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;    <span class="comment"># 服务器 B 的 6379 端口</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;    <span class="comment"># 服务器 B 的 6378 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> tomcatbackend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:8080</span>;   <span class="comment"># 服务器 B 的 8080 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> redisbackend; <span class="comment"># redis 的负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>	<span class="number">82</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> tomcatbackend;  <span class="comment"># tomcat 的负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问服务器 B 的地址进行测试：<code>192.168.200.133:82</code>。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/12/Nginx_Reverse_proxy/">Nginx 反向代理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p><strong>引言</strong></p>
<p>Nginx 如何变成一个代理服务器？Nginx 又如何将客户端的请求转发给其他的服务器？本内容将学习 Nginx 的反向代理知识。</p>
<hr>
<h2 id="反向代理概述"><a href="#反向代理概述" class="headerlink" title="反向代理概述"></a>反向代理概述</h2><p>关于正向代理和反向代理，在 <a href="/pages/9551ee/#名词解释">Nginx - 介绍</a> 已经通过一张图详细的介绍过了，简而言之就是正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</p>
<p>Nginx 即可以实现正向代理，也可以实现反向代理。</p>
<p>我们先来通过一个小案例演示下 Nginx 正向代理的简单应用。</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>先提需求：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.53oygoz19gc0.webp" alt="image"></p>
<ol>
<li>服务端的设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">'client send request=&gt;clientIp=<span class="variable">$remote_addr</span> serverIp=<span class="variable">$host</span>'</span>;</span><br><span class="line">	server&#123;</span><br><span class="line">		<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">		<span class="attribute">server_name</span>	localhost;</span><br><span class="line">		<span class="attribute">access_log</span> logs/access.log main;</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">			<span class="attribute">root</span> html;</span><br><span class="line">			<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用客户端访问服务端：<code>http://192.168.200.133</code>，打开日志查看结果</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.16ifxal7swyk.webp" alt="image"></p>
<ol start="3">
<li>代理服务器设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">82</span>;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;   <span class="comment"># 设置 DNS 的 IP，用来解析 proxy_pass 中的域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://<span class="variable">$host</span><span class="variable">$request_uri</span>;   <span class="comment"># proxy_pass 实现正向代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proxy_pass</code> 后面有讲解。</p>
<ol start="4">
<li>客户端配置代理服务器的 IP(192.168.200.146)和 Nginx 配置监听的端口(82)</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yx93qbazra0.webp" alt="image"></p>
<ol start="5">
<li>设置完成后，再次通过浏览器访问服务端</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6litsat09000.webp" alt="image"></p>
<p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是使用了代理，那么服务端能看到的只是代理发送过去的请求，这样就使用 Nginx 实现了正向代理的设置。</p>
<p>但是 Nginx 正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习 Nginx 的反向代理，这是 Nginx 比较重要的一个功能。</p>
<h2 id="反向代理语法配置"><a href="#反向代理语法配置" class="headerlink" title="反向代理语法配置"></a>反向代理语法配置</h2><p>Nginx 反向代理模块的指令是由 <code>ngx_http_proxy_module</code> 模块进行解析，该模块在安装 Nginx 的时候已经自动加载到 Nginx 中了，接下来我们把反向代理中的常用指令一一介绍下：</p>
<ul>
<li>proxy_pass：配置代理的服务器地址</li>
<li>proxy_set_header：转发给被代理服务器时，设置一些请求头信息</li>
<li>proxy_redirect：防止客户端可以看到被代理服务器的地址</li>
</ul>
<p>这里只介绍三个指令，关于反向代理的指令非常多，想要了解更多，请前往 <a href="https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html" target="_blank" rel="noopener">Nginx 反向代理文档</a></p>
<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>该指令用来设置被代理服务器地址，可以是主机名称、IP 地址加端口号形式，没有默认值。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_pass &lt;URL&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<p><code>URL</code>：为要设置的被代理服务器地址，包含传输协议(<code>http</code>、<code>https://</code>)、主机名称或 IP 地址加端口号、URI 等要素。</p>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="attribute">location</span> /server &#123;</span><br><span class="line">    <span class="comment"># 结尾不加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/server/index.html</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结尾加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>准备两台服务器或者按照 Linux 系统的虚拟机，这里是 <code>192.168.200.133</code> 和 <code>192.168.200.146</code>，为了方便，我们称前者为服务器 A，后者为服务器 B。</p>
<ol>
<li>在服务器 A 的 Nginx 配置文件添加如下内容：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端请求服务器 A <code>http://192.168.200.133</code>，它会转发给服务器 B，此时的服务器 A 就是一个代理的角色。</p>
<p>访问服务器 A，我们看到 Nginx 的欢迎界面其实是服务器 B 的 Nginx，可以在服务器 B 的 Nginx 欢迎页面添加新的内容：<code>I am 146</code>，再次访问服务器 A，效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4ai1u3uxs940.webp" alt="image"></p>
<p>总结来说：</p>
<ul>
<li>正向代理相当于在客户端浏览器里直接访问目标域名，但是背地里请求会从配置好的代理服务器发出去，对服务端来说它只知道代理服务器请求了提出了这次请求。</li>
<li>反向代理时相当于在客户端浏览器里直接访问代理服务器，然后代理服务器根据内部配置好的规则选择相应的服务返回给客户端，此时客户端并不清楚毒品的源头是谁，只知道它是从proxy那拿了货。</li>
</ul>
<p><strong>在编写 proxy_pass 的时候，后面的值要不要加 /?</strong></p>
<p>这是看情况的。</p>
<p>接下来通过例子来说明提到的问题：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址加不加斜杠，效果都一样，因为 location 后的 / 会添加在代理地址后面</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址必须加斜杠，因为 location 后的 /server 会添加在代理地址后面，第一个将没有 / 结尾</span></span><br><span class="line">		<span class="comment">#proxy_pass http://192.168.200.146;</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面的 location：当客户端访问 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第一个 proxy_pass 就变成了 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第二个 proxy_pass 就变成了 http://localhost/index.html 效果就不一样了。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个 location（第 4 行代码）：当客户端访问 <code>http://localhost/index.html</code>，两个 <code>proxy_pass</code> 效果是一样的，因为 location 后的 <code>/</code> 会添加在代理地址后面，所以有没有 <code>/</code>，效果都一样。</p>
</li>
<li><p>第一个 location（第 14 行代码）：当客户端访问 <code>http://localhost/server/index.html</code>，这个时候，第一个 proxy_pass 就变成了 <code>http://192.168.200.146/server/index.html</code>，第二个 proxy_pass 就变成了 <code>http://192.168.200.146/index.html</code> 效果就不一样了</p>
<p>如果不以 <code>/</code> 结尾，则 location 后的 <code>/server</code> 会添加在地址后面，所以第一个 proxy_pass 因为没有 <code>/</code> 结尾而被加上 <code>/server</code>，而第二个自带了 <code>/</code> ，所以不会添加 <code>/server</code>。</p>
</li>
</ul>
<p>上面的例子仅仅针对：访问任意请求如 <code>/server</code> 时，想要代理到其他服务器的首页，则加 <code>/</code>，否则你如果真的想访问 <code>/server</code> 下的资源，那么不要加 <code>/</code>。</p>
<p>所以加了 <code>/</code> 后，请求的是服务器根目录下的资源。</p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><p>该指令可以更改 Nginx 服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器。默认值是发送代理服务器的地址和 close。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4bt7qzhbz1i0.webp" alt="image"></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_set_header &lt;field&gt; &lt;value&gt;;</td>
<td>proxy_set_header Host $proxy_host; proxy_set_header Connection close;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p>
<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>被代理服务器：服务器 B <code>192.168.200.146</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$http_username</span>;    <span class="comment"># 获取代理服务器发送过来的 http 请求头的 username 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务器: 服务器 A <code>192.168.200.133</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;           <span class="comment"># 访问 /server 触发代理</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:8080/;  <span class="comment"># 配置服务器 B 的地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> username TOM;  <span class="comment"># 发送 key 为 username，value 为 TOM 的请求头给服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.398ksbw6rv20.webp" alt="image"></p>
<p>客户端访问的是服务器 A，服务器 A 会将请求转发给服务器 B，服务器 B 返回打印 TOM 的页面给服务器 A，服务器 A 最后返回给客户端。</p>
<h3 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h3><p>该指令是用来重置头信息中的『 Location 』和『 Refresh 』的值，防止客户端可以看到被代理服务器的地址。</p>
<p>因为客户端看到的返回结果是『 Location 』和『 Refresh 』的值，所以在到达代理服务器的时，将两个值修改掉，防止客户端直接看到被代理服务器的地址。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_redirect redirect replacement;<br> proxy_redirect default; <br>proxy_redirect off;</td>
<td>proxy_redirect default;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>为什么要用该指令？</strong></p>
</blockquote>
<p>首先说明一下思路：客户端通过代理服务器 A 访问服务器 B 的资源，但是服务器 B 不存在该资源，则会报错。此时我们不希望它直接返回报错页面给客户端，我们希望服务器 B 返回的是它的欢迎页面。那么如何做呢？</p>
<ul>
<li>首先在服务器 B 进行判断是否存在资源，不存在则返回自己的欢迎页面，即重定向到自己的欢迎页面地址并返回，此时浏览器的地址将会发生改变</li>
<li>代理服务器 A 收到服务器 B 的欢迎页面和地址，但是我们不能直接返回给客户端，因为它会暴露服务器 B 的地址，这是重定向的原因</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.a4tptcx6lbk.webp" alt="image"></p>
<ul>
<li>此时用到 <code>proxy_redirect</code> 指令，重置服务器 B 返回过来的『 Location 』和『 Refresh 』值，将两个值改为代理服务器 A 的某个地址</li>
<li>因为改为了代理服务器 A 的某个地址，所以代理服务器 A 根据这个地址又去获取理服务器 B 的欢迎页面地址，返回给客户端</li>
</ul>
<p>很绕，简单总结下：客户端通过 A 找 B 不存在的资源，B 不想返回报错页面，于是重定向到自己的欢迎页面地址并返回给 A，A 收到了页面和地址（正常情况不要接收地址，只接收页面），发现不能暴露 B 的地址，于是修改接收的 B 的地址为自己的某一个地址，这个地址会重新发送请求去获取 B 的欢迎页面地址，然后返回给客户端。</p>
<p>这里要明白 B 返回的是重定向后的欢迎页面，重定向后，浏览器地址栏会变成重定向的地址，所以 A 才会以自己的地址转发获取到 B 的地址，所以最后浏览器显示 A 的地址，看到的却是 B 的欢迎页面。</p>
<p>代码：</p>
<p>服务端 B <code>192.168.200.146</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">302</span> http://192.168.200.146;   <span class="comment">#  2.如果请求的资源不存在，则重定向到服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务端 A <code>192.168.200.133</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;  <span class="comment"># 1.转发给服务器 B</span></span><br><span class="line">		<span class="attribute">proxy_redirect</span> http://192.168.200.146 http://192.168.200.133; <span class="comment"># 3.修改服务器 B 的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 该 server 去请求服务器 B 的欢迎页面</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">192.168.200.133</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;  <span class="comment"># 4.重新发送请求给服务器 B，获取欢迎页面</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行代码，当服务器 B 返回的是 <code>http://192.168.200.146</code>，为了不让它出现在浏览器的地址栏上，我们需要利用 <code>proxy_redirect</code> 将它修改为代理服务器 A 的地址，这个地址会以自己的地址重新访问服务器 B 的欢迎页面，最后返回给客户端。</p>
<p><strong>该指令的三组选项</strong></p>
<ul>
<li><p><code>proxy_redirect redirect replacement;</code></p>
<ul>
<li>redirect：被代理服务器返回的 Location 值</li>
<li>replacement：要替换 Location 的值</li>
</ul>
</li>
<li><p><code>proxy_redirect default;</code></p>
<ul>
<li><p>default：相比较第一组选项，default 仅仅提供了 <code>redirect</code> 和 <code>replacement</code> 的默认值</p>
<p>将本范围 location 块的 uri 变量作为 replacement。</p>
<p>将 proxy_pass 变量作为 redwadairect</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123; </span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;</span><br><span class="line">		<span class="attribute">proxy_redirect</span> default;  <span class="comment"># redirect 是 proxy_pass 的值：http://192.168.200.146:8081/</span></span><br><span class="line">        						 <span class="comment"># replacement 是 location 后的值：/server</span></span><br><span class="line">        <span class="comment"># 等价于：proxy_redirect http://192.168.200.146:8081/ /server</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>proxy_redirect off;</code></p>
<p>关闭 proxy_redirect 的功能</p>
</li>
</ul>
<h2 id="反向代理实战"><a href="#反向代理实战" class="headerlink" title="反向代理实战"></a>反向代理实战</h2><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.59ecpsonzxc0.webp" alt="image"></p>
<p>服务器 1，2，3 存在两种情况</p>
<ul>
<li>第一种情况: 三台服务器的内容不一样</li>
<li>第二种情况: 三台服务器的内容是一样</li>
</ul>
<p>第一种情况</p>
<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容不一样，那我们可以根据用户请求来分发到不同的服务器。</p>
<p>服务器有限，只能以三个端口模拟三台服务器，实际上是一个 IP 对应一个服务器。</p>
<p>代理服务器配置文件内容：</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代理服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8082</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost; </span><br><span class="line">    <span class="attribute">location</span> /server1 &#123;    </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9001/;   <span class="comment"># 代理 server1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server2 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9002/;   <span class="comment"># 代理 server2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server3 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9003/;   <span class="comment"># 代理 server3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="comment"># server1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server2</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9002</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server3</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9003</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容是一样的，该如何处理?</p>
<p>请看负载均衡的相关内容，里面将进行详细的介绍。</p>
</li>
</ul>
<h2 id="斜杠总结"><a href="#斜杠总结" class="headerlink" title="斜杠总结"></a>斜杠总结</h2><p>这里将发送 <code>http://192.168.199.27/frx/xu</code> 请求。</p>
<p><strong>不带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>/xu</td>
</tr>
</tbody></table>
<p>若 Nginx 会将原请求路径原封不动地转交给其他地址，如案例 3 和 4。</p>
<p><code>proxy_pass</code> 的 ip:port 后加了 <code>/</code>，代表去除掉请求和 location 的匹配的字符串，不加则追加全部请求到地址后面。</p>
<p><strong>带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bing/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bingxu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing/xu</td>
</tr>
</tbody></table>
<p><code>proxy_pass</code> 的 ip:port 后加了字符串，Nginx 会将匹配 location 的请求从「原请求路径」中剔除，再不匹配的字符串拼接到 proxy_pass 后生成「新请求路径」，然后将「新请求路径」转交给其他地址。</p>
<p>案例 2 中，<code>proxy_pass</code> 的 ip:port 后接了字符串，因此将 location 的 <code>/frx/</code> 从原请求路径 <code>/frx/xu</code> 中剔除，变为 <code>xu</code>，然后将 <code>xu</code> 拼接到 <code>http://192.168.1.48/bing</code> 后生成了新请求，因此其他地址收到的请求就是 <code>/bingxu</code>。</p>
<h2 id="Nginx安全控制"><a href="#Nginx安全控制" class="headerlink" title="Nginx安全控制"></a>Nginx安全控制</h2><p>关于 Web 服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx 反向代理是如何来提升 Web 服务器的安全呢？</p>
<p>答案是：安全隔离。</p>
<h3 id="什么是安全隔离"><a href="#什么是安全隔离" class="headerlink" title="什么是安全隔离"></a>什么是安全隔离</h3><p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3vhdv63nf9q0.webp" alt="image"></p>
<h3 id="如何使用SSL对流量加密"><a href="#如何使用SSL对流量加密" class="headerlink" title="如何使用SSL对流量加密"></a>如何使用SSL对流量加密</h3><p>翻译成大家能熟悉的说法就是将我们常用的 http 请求转变成 https 请求，那么这两个之间的区别简单的来说两个都是 HTTP 协议，只不过 https 是身披 SSL 外壳的 http.</p>
<p>HTTPS 是一种通过计算机网络进行安全通信的传输协议。它经由 HTTP 进行通信，利用 SSL/TLS 建立全通信，加密数据包，确保数据的安全性。</p>
<ul>
<li>SSL(Secure Sockets Layer)安全套接层</li>
<li>TLS(Transport Layer Security)传输层安全</li>
</ul>
<p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS 和 SSL 在传输层和应用层对网络连接进行加密。</p>
<p>总结来说为什么要使用 https:</p>
<ul>
<li>http 协议是明文传输数据，存在安全问题，而 https 是加密传输，相当于 http + SSL，并且可以防止流量劫持。</li>
</ul>
<p>Nginx 默认不支持 https 开头的协议，如果要想使用 SSL，需要满足一个条件即需要添加一个模块 <code>--with-http_ssl_module</code>，而该模块在编译的过程中又需要 OpenSSL 的支持，OpenSSL 我们在 <a href="/middleware/Nginx/Nginx_install/#nginx环境安装">Nginx 安装</a> 已经准备好了。</p>
<h3 id="添加SSL支持"><a href="#添加SSL支持" class="headerlink" title="添加SSL支持"></a>添加SSL支持</h3><p>完成 <code>--with-http_ssl_module</code> 模块的增量添加。</p>
<ol>
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /root/nginx/core/nginx-<span class="number">1</span>.<span class="number">20</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 configure 来配置参数，添加 <code>ngx_http_ssl_module</code> 模块，记得加上第（2）步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_ssl_module <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 make 模板进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 objs 下面的 nginx 可执行文件移动到 <code>/usr/local/nginx/sbin</code> 下</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.20.2/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在源码目录（安装包目录）下执行 <code>make upgrade</code> 进行升级，这个可以实现不停机添加新模块的功能</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.20.2</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="SSL相关指令"><a href="#SSL相关指令" class="headerlink" title="SSL相关指令"></a>SSL相关指令</h3><p>该模块的指令都是通过 <code>ngx_http_ssl_module</code> 模块来解析的，我们上一步已经添加了。</p>
<p>这里只介绍常用的几个指令，了解更多指令请前往 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html" target="_blank" rel="noopener">ngx_http_ssl_module 模块文档</a>。</p>
<p><code>ssl</code> 指令用来在指定的服务器开启 HTTPS，默认关闭。可以使用 listen 443 ssl，这种方式更通用些。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl &lt;on |off&gt;;</td>
<td>ssl off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>ssl 默认监听的是 443 端口，所以使用下面的指令和 <code>ssl on</code> 效果一致，因为下面的指令能突出 sll 的监听端口，所以建议使用它。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ssl_certificate</code> 指令是为当前这个虚拟主机指定一个带有 PEM 格式证书的证书。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_certificate &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_certificate_key</code> 指令用来指定 PEM secret key 文件的路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ceritificate_key &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_session_cache</code> 指令用来配置用于 SSL 会话的缓存</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_sesion_cache &lt;off | none | [builtin[:size]] [shared:name:size]&gt;</td>
<td>ssl_session_cache none;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>选项介绍：</p>
<ul>
<li><p><code>off</code>：严格禁止使用会话缓存：Nginx 明确告诉客户端会话不能被重用</p>
</li>
<li><p><code>none</code>：禁止使用会话缓存，Nginx 告诉客户端会话可以被重用，但实际上并不在缓存中存储会话参数（任性，言语同意用，行为取消用）</p>
</li>
<li><p><code>builtin</code>：内置 OpenSSL 缓存，仅在一个工作进程中使用。缓存大小在会话中指定。如果未给出大小，则等于 20480 个会话。使用内置缓存可能会导致内存碎片</p>
</li>
<li><p><code>shared</code>：所有工作进程之间共享缓存，缓存的相关信息用 name 和 size 来指定，同 name 的缓存可用于多个虚拟服务器</p>
<p>name 是允许缓存的数据名，size 是允许缓存的数据大小，以字节为单位</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_cache</span> builtin:<span class="number">1000</span> shared:SSL:<span class="number">10m</span>;</span><br></pre></td></tr></table></figure>

<p>10m 的 m 是兆。</p>
<p><code>ssl_session_timeout</code> 指令用于开启 SSL 会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间，默认值超时时间是 5 秒</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_session_timeout &lt;time&gt;;</td>
<td>ssl_session_timeout 5m;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_ciphers</code> 指令指出允许的密码，密码指定为 OpenSSL 支持的格式</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ciphers &lt;ciphers&gt;;</td>
<td>ssl_ciphers HIGH:!aNULL:!MD5;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>可以直接在 Linux 系统上使用 <code>openssl ciphers</code> 查看 OpenSSl 支持的格式</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ciphers</span><br></pre></td></tr></table></figure>

<p><code>ssl_prefer_server_ciphers</code> 指令指定是否服务器密码优先客户端密码，默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_perfer_server_ciphers &lt;on | off&gt;;</td>
<td>ssl_perfer_server_ciphers off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<h3 id="SSL证书生成"><a href="#SSL证书生成" class="headerlink" title="SSL证书生成"></a>SSL证书生成</h3><p><strong>方式一：使用阿里云/腾讯云等第三方服务进行购买免费版</strong></p>
<p>需要购买域名进行证书的绑定，否则证书无法使用。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5p2qyl61ozc0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5l7iqyudol00.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6ci6w9wu24g0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4k9v2b9n6tm0.webp" alt="image"></p>
<p>接着在右边弹窗进行域名绑定，填完写域名和个人信息，进入到验证信息</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.11wx9z7jit3k.webp" alt="image"></p>
<p>点击验证，不成功则去自己的域名解析列表查看，如下，点击添加记录，进行配置，或者已经看到记录类型是 TXT，记录值和上图一样的，则说明成功。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6qcpqete8ic0.webp" alt="image"></p>
<p>提交审核后，点击下载</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.28m5753glfy8.webp" alt="image"></p>
<p>下载 Nginx 服务器的证书</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6kmq7nhonys0.webp" alt="image"></p>
<p>下载压缩包进行加压后，得到 .pem 证书和 .key 证书，把两个证书上传到 Linux，进行配置，往下看。</p>
<p><strong>方式二：使用 OpenSSL 生成证书</strong></p>
<p>这个方式适用于学习阶段，实际开发阶段使用方式一</p>
<ol>
<li>先要确认当前系统是否有安装 OpenSSL</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>

<p>安装下面的命令进行生成（一步一步来）</p>
<ol start="2">
<li>创建 <code>/root/cerr</code> 目录并进入</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/cert</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/cert</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定加密算法和加密方式，生成 <code>server.key</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># genrsa 是加密算法，des3 是加密方式，-out 代表输入长度为 2048 的 server.key</span></span><br><span class="line">openssl genrsa -des3 -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后它会让你注册 server.key 的密码</span></span><br><span class="line"><span class="comment"># 输入密码 ......</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>根据你注册的 server.key 密码，生成 server.csr 文件，生成后它会让你注册你的基本信息，因为是个人的，所以信息随便填写</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里注册你的基本信息，信息随便填写</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.2b4bgtawqb4.webp" alt="image"></p>
<ol start="5">
<li>备份 server.key</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp server.key server.key.org</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>重新生成 server.key 文件，并输入刚才注册的密码</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> server.key.org -out server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会让你重新输入注册密码</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>生成 server.crt 文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最后使用 <code>ll</code> 查看目录下是否生成相应的文件：</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yl8ne2bkre0.webp" alt="image"></p>
<h3 id="SSL实例模板-通用"><a href="#SSL实例模板-通用" class="headerlink" title="SSL实例模板(通用)"></a>SSL实例模板(通用)</h3><p>Nginx 的置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;		<span class="comment"># 开启 SSL 功能</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;     <span class="comment"># 如果是购买的域名，这里加上该域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /root/cert/server.cert; <span class="comment"># 生成的 cert 或者 pem 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /root/cert/server.key; <span class="comment"># 生成的 key 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>; </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; <span class="comment"># 表示使用的加密套件的类型</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;  <span class="comment"># 表示使用的TLS协议的类型</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个模板就是 Nginx 解压目录的 conf 目录下的 nginx.conf 内容。</p>
<p><strong>建议</strong></p>
<p>配置 SSL 证书时候，不要修改原来的 server 模块（<code>listen 80</code> 模块），应该新建一个 server 模块。</p>
<p><strong>解决默认 http 问题。</strong></p>
<p>配置完 SSL 证书还远远不安全。如果直接输入 <code>www.frx.com</code>，会默认加上『 http:// 』 而不是『 https:// 』，如何修改为『 https:// 』呢，我们利用 Rewrite 功能</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.frx.com;   <span class="comment"># 如果是 www.frx.com 发送请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.frx.com<span class="variable">$1</span>;  <span class="comment"># 则改为 https 方式</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理系统调优"><a href="#反向代理系统调优" class="headerlink" title="反向代理系统调优"></a>反向代理系统调优</h2><p>反向代理值 Buffer 和 Cache。</p>
<p>Buffer 翻译过来是「缓冲」，Cache 翻译过来是「缓存」。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6p7uoj5ab0k0.webp" alt="image"></p>
<p>客户端通过代理服务器向被代理服务器获取数据后，代理服务器在获取的数据存储在缓存「瓶子」里，客户端再次获取相同资源时，直接从缓存「瓶子」里获取数据，不需要向被代理服务器获取数据，减轻压力。</p>
<p>相同点:</p>
<ul>
<li>两种方式都是用来提供 IO 吞吐效率，都是用来提升 Nginx 代理的性能。</li>
</ul>
<p>不同点:</p>
<ul>
<li>缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除</li>
<li>缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除</li>
</ul>
<h3 id="Proxy-Buffer-相关指令"><a href="#Proxy-Buffer-相关指令" class="headerlink" title="Proxy Buffer 相关指令"></a>Proxy Buffer 相关指令</h3><ul>
<li><p><code>proxy_buffering</code> 指令用来开启或者关闭代理服务器的缓冲区，默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffering &lt;on | off&gt;;</td>
<td>proxy_buffering on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_buffers</code> 指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>number：缓冲区的个数</li>
<li>size：每个缓冲区的大小，缓冲区的总大小就是 number * size</li>
</ul>
</li>
<li><p><code>proxy_buffer_size</code> 指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与 proxy_buffers 中的 size 一致即可，当然也可以更小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffer_size &lt;size&gt;;</td>
<td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_busy_buffers_size</code> 指令用来限制同时处于 BUSY 状态的缓冲总大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_busy_buffers_size &lt;size&gt;;</td>
<td>proxy_busy_buffers_size 8k | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_temp_path</code> 指令用于当缓冲区存满后，仍未被 Nginx 服务器完全接受，响应数据就会被临时存放在磁盘文件上的该指令设置的文件路径下</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_path &lt;path&gt;;</td>
<td>proxy_temp_path proxy_temp;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>注意 path 最多设置三层。</p>
</li>
<li><p><code>proxy_temp_file_write_size</code> 指令用来设置磁盘上缓冲文件的大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_file_write_size &lt;size&gt;;</td>
<td>proxy_temp_file_write_size 8K | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="网站调优模板-通用"><a href="#网站调优模板-通用" class="headerlink" title="网站调优模板(通用)"></a>网站调优模板(通用)</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_temp_file_write_size</span> <span class="number">128k</span>;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理问题"><a href="#反向代理问题" class="headerlink" title="反向代理问题"></a>反向代理问题</h2><p>反向代理有一个严重的问题，那就是反向代理的网站需要的 css、js、png 等静态文件默认是从 Nginx 里获取，显然一个你的服务器的代理了如淘宝、京东等网站，那么淘宝、京东等网站的静态文件是从你的服务器里获取，但是服务器根本没有，那么我们如何让代理的网站以及网站需要的 css、js、png 等静态文件一同获取呢，添加如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*</span> &#123;							<span class="comment"># 如果不是代理网站的根路径，请自行修改</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8081;   <span class="comment"># 代理的网站地址</span></span><br><span class="line">        <span class="comment"># 将网站的静态文件也代理过来</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/11/NginxStatic_resource_access/">Nginx 静态资源访问</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-静态资源访问"><a href="#Nginx-静态资源访问" class="headerlink" title="Nginx 静态资源访问"></a>Nginx 静态资源访问</h1><p><strong>引言</strong></p>
<p>如何访问 Nginx 的静态资源？这其中涉及到了 Nginx 的核心功能 Rewrite 重写技术，本内容将讲解处理访问静态资源的相关知识。</p>
<hr>
<h2 id="Nginx的跨域问题"><a href="#Nginx的跨域问题" class="headerlink" title="Nginx的跨域问题"></a>Nginx的跨域问题</h2><p>跨域问题，我们主要从以下方面进行解决：</p>
<ul>
<li>什么情况下会出现跨域问题</li>
<li>实例演示跨域问题</li>
<li>具体的解决方案是什么</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>浏览器的同源策略：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。</p>
<p>同源：协议、域名(IP)、端口相同即为同源</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.131/user/1</span><br><span class="line">https://192.168.200.131/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.132/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://www.nginx.com/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://www.nginx.org:80/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line"><span class="comment"># 满足同源</span></span><br></pre></td></tr></table></figure>

<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>简单描述下：</p>
<p>有两台服务器分别为 A、B，如果从服务器 A 的页面发送异步请求到服务器 B 获取数据，如果服务器 A 和服务器 B 不满足同源策略，则就会出现跨域问题。</p>
<h3 id="跨域案例"><a href="#跨域案例" class="headerlink" title="跨域案例"></a>跨域案例</h3><p>出现跨域问题会有什么效果？接下来通过一个需求来给大家演示下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.vlv6telsbb4.webp" alt="image"></p>
<ol>
<li>Nginx 的 html 目录下新建一个 a.html</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/html/a.htm</span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域问题演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        $.<span class="keyword">get</span>('http://192.168.200.133:8080/getUser',function(data)&#123;</span></span><br><span class="line"><span class="javascript">                                alert(<span class="built_in">JSON</span>.stringify(data));</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取数据"</span> <span class="attr">id</span>=<span class="string">"btn"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 nginx.conf 配置如下内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /getUser&#123;</span><br><span class="line">        <span class="attribute">default_type</span> application/json;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> 	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过浏览器测试访问</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.4md37urjzug0.webp" alt="image"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>add_header</code> 指令，该指令可以用来添加一些头信息。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>add_header &lt;name&gt; &lt;value&gt; ……</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>此处用来解决跨域问题，需要添加两个头信息，分别是</p>
<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
</ul>
<p><code>Access-Control-Allow-Origin</code>：直译过来是允许跨域访问的源地址信息，可以配置多个(多个用逗号分隔)，也可以使用 <code>*</code> 代表所有源。</p>
<p><code>Access-Control-Allow-Methods</code>：直译过来是允许跨域访问的请求方式，值可以为 GET、POST、PUT、DELETE ……，可以全部设置，也可以根据需要设置，多个用逗号分隔。</p>
<p>具体配置方式：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /getUser &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,PUT,DELETE;</span><br><span class="line">    <span class="attribute">default_type</span> application/json;   <span class="comment"># return 的格式是 json</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态资源防盗链"><a href="#静态资源防盗链" class="headerlink" title="静态资源防盗链"></a>静态资源防盗链</h2><h3 id="什么是资源盗链"><a href="#什么是资源盗链" class="headerlink" title="什么是资源盗链"></a>什么是资源盗链</h3><p>资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。</p>
<p>提供两种图片进行演示：</p>
<ul>
<li>京东：<code>https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg</code></li>
<li>百度：<code>https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB</code></li>
</ul>
<p>我们在 html 目录下准备一个页面 a.html，在页面上利用 img 标签引入这两个图片:</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.614vk7i0kx80.webp" alt="image"></p>
<p>访问：<code>http://192.168.200.133/a.html</code> 来查看效果</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.2m5u48xesf60.webp" alt="image"></p>
<p>从上面的效果，可以看出来，下面的图片地址添加了防止盗链的功能，京东这边我们可以直接使用其图片。</p>
<h3 id="防盗链实现原理"><a href="#防盗链实现原理" class="headerlink" title="防盗链实现原理"></a>防盗链实现原理</h3><p>了解防盗链的原理之前，我们得先学习一个 HTTP 的头信息 Referer，当浏览器向 Web 服务器发送请求的时候，一般都会带上 Referer，来告诉浏览器该网页是从哪个页面链接过来的。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.64vdmkvdywk0.webp" alt="image"></p>
<p>后台服务器可以根据获取到的这个 Referer 信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回 403（服务端拒绝访问）的状态信息。</p>
<h3 id="防盗链实现实例"><a href="#防盗链实现实例" class="headerlink" title="防盗链实现实例"></a>防盗链实现实例</h3><p>在本地模拟上述的服务器效果图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.4hr6e3mrf440.webp" alt="image"></p>
<p>Nginx 防盗链的具体实现：</p>
<p>valid_referers 指令：Nginx 会通过查看 Referer 自动和 valid_referers 的内容进行匹配，如果匹配到了就将 <code>$invalid_referer</code> 变量置 0，如果没有匹配到，则将 <code>$invalid_referer</code> 变量置为 1，匹配的过程中不区分大小写。</p>
<p>所以我们可以在配置文件判断 <code>$invalid_referer</code> 是否等于 1（true），即没有匹配到 ，等于则返回 403。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>valid_referers &lt;none | blocked | server_names | string&gt; ……</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<ul>
<li>none：如果 Header 中的 Referer 为空，允许访问</li>
<li>blocked：在 Header 中的 Referer 不为空，但是该值被防火墙或代理进行伪装过，如不带『 http:// 』 、『 https:// 』等协议头的资源才允许访问。</li>
<li>server_names：指定具体的域名或者 IP</li>
<li>string：可以支持正则表达式和 <code>*</code> 的字符串。如果是正则表达式，需要以 <code>~</code> 开头表示</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ *\.(png|jpg|gif)</span>&#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> www.baidu.com <span class="number">192.168.91.200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># valid_referers none blocked *.example.com example.*  www.example.org  ~\.google\.;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码如果没有匹配上 <code>www.baidu.com</code> 和 <code>192.168.91.200</code>，则 <code>$invalid_referer</code> 为 1（true），返回 403，代表不允许获取资源。</p>
<p>Nginx 配置文件支持 if 判断，但是 if 后面必须有空格。</p>
<p><strong>问题：如果图片有很多，该如何批量进行防盗链？可以针对目录进行防盗链。</strong></p>
<h3 id="针对目录防盗链"><a href="#针对目录防盗链" class="headerlink" title="针对目录防盗链"></a>针对目录防盗链</h3><p>假设 html 目录下有一个 images 目录，里面专门放防盗链的图片。</p>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> www.baidu.com <span class="number">192.168.199.27</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># valid_referers none blocked *.example.com example.*  www.example.org  ~\.google\.;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需将 location 的地址改成一个目录，这样我们可以对一个目录下的所有资源进行防盗链操作。</p>
<p><strong>问题：Referer 的限制比较粗，比如浏览器发送请求时恶意加一个 Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？</strong></p>
<p>此时我们需要用到 Nginx 的第三方模块 <code>ngx_http_accesskey_module</code>，第三方模块如何实现盗链，如何在 Nginx 中使用第三方模块的功能，在后面有讲解。</p>
<h2 id="Rewrite功能配置"><a href="#Rewrite功能配置" class="headerlink" title="Rewrite功能配置"></a>Rewrite功能配置</h2><p>Rewrite 是 Nginx 服务器提供的一个重要基本功能，是 Web 服务器产品中几乎必备的功能。主要的作用是用来实现 URL 的重写。</p>
<p>*<em>warning *</em></p>
<p>Nginx 服务器的 Rewrite 功能的实现依赖于 PCRE 的支持，因此在编译安装 Nginx 服务器之前，需要安装 PCRE 库。Nginx 使用的是<code>ngx_http_rewrite_module</code> 模块来解析和处理 Rewrite 功能的相关配置。</p>
<h3 id="地址重写与地址转发"><a href="#地址重写与地址转发" class="headerlink" title="地址重写与地址转发"></a>地址重写与地址转发</h3><p>重写和转发的区别:</p>
<ul>
<li>地址重写浏览器地址会发生变化而地址转发则不变</li>
<li>一次地址重写会产生两次请求而一次地址转发只会产生一次请求</li>
<li>地址重写到的页面必须是一个完整的路径而地址转发则不需要</li>
<li>地址重写因为是两次请求，所以 request 范围内属性不能传递给新页面，而地址转发因为是一次请求所以可以传递值</li>
<li>地址转发速度快于地址重写</li>
</ul>
<h3 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h3><p>该指令用来设置一个新的变量。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>set &lt;$key&gt; &lt;value&gt;;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li>variable：变量的名称，该变量名称要用 <code>$</code> 作为变量的第一个字符，且不能与 Nginx 服务器内置的全局变量同名。</li>
<li>value：变量的值，可以是字符串、其他变量或者变量的组合等。</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">        <span class="attribute">default_type</span> text/plain;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>https://192.168.200.133:8081:server</code>，返回结果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.6t618fip2fo0.webp" alt="image"></p>
<h3 id="Rewrite常用全局变量"><a href="#Rewrite常用全局变量" class="headerlink" title="Rewrite常用全局变量"></a>Rewrite常用全局变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$args</td>
<td>变量中存放了请求 URL 中的请求指令。比如 <code>http://192.168.200.133:8080?arg1=value1&amp;args2=value2</code> 中的『 arg1=value1&amp;arg2=value2 』，功能和 $query_string 一样</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>变量存储的是用户访问服务的代理信息（如果通过浏览器访问，记录的是浏览器的相关版本信息）</td>
</tr>
<tr>
<td>$host</td>
<td>变量存储的是访问服务器的 server_name 值</td>
</tr>
<tr>
<td>$document_uri</td>
<td>变量存储的是当前访问地址的URI。比如 <code>http://192.168.200.133/server?id=10&amp;name=zhangsan</code>中的『 /server 』，功能和 $uri 一样</td>
</tr>
<tr>
<td>$document_root</td>
<td>变量存储的是当前请求对应 location 的 root 值，如果未设置，默认指向 Nginx 自带 html 目录所在位置</td>
</tr>
<tr>
<td>$content_length</td>
<td>变量存储的是请求头中的 Content-Length 的值</td>
</tr>
<tr>
<td>$content_type</td>
<td>变量存储的是请求头中的 Content-Type 的值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>变量存储的是客户端的 cookie 信息，可以通过 <code>add_header Set-Cookie &#39;cookieName=cookieValue&#39;</code> 来添加 cookie 数据</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>变量中存储的是 Nginx 服务器对网络连接速率的限制，也就是 Nginx 配置中对 limit_rate 指令设置的值，默认是 0，不限制。</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>变量中存储的是客户端的 IP 地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>变量中存储了客户端与服务端建立连接的端口号</td>
</tr>
<tr>
<td>$remote_user</td>
<td>变量中存储了客户端的用户名，需要有认证模块才能获取</td>
</tr>
<tr>
<td>$scheme</td>
<td>变量中存储了访问协议</td>
</tr>
<tr>
<td>$server_addr</td>
<td>变量中存储了服务端的地址</td>
</tr>
<tr>
<td>$server_name</td>
<td>变量中存储了客户端请求到达的服务器的名称</td>
</tr>
<tr>
<td>$server_port</td>
<td>变量中存储了客户端请求到达服务器的端口号</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>变量中存储了客户端请求协议的版本，比如 『 HTTP/1.1 』</td>
</tr>
<tr>
<td>$request_body_file</td>
<td>变量中存储了发给后端服务器的本地文件资源的名称</td>
</tr>
<tr>
<td>$request_method</td>
<td>变量中存储了客户端的请求方式，比如『 GET 』,『 POST 』等</td>
</tr>
<tr>
<td>$request_filename</td>
<td>变量中存储了当前请求的资源文件的路径名</td>
</tr>
<tr>
<td>$request_uri</td>
<td>变量中存储了当前请求的 URI，并且携带请求参数，比如 <code>http://192.168.200.133/server?id=10&amp;name=zhangsan</code> 中的 『 /server?id=10&amp;name=zhangsan 』</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>例如</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/nginx/abc;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">        <span class="attribute">default_type</span> text/plain;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>=<span class="variable">$args</span>=<span class="variable">$http_user_agent</span>=<span class="variable">$host</span>=<span class="variable">$document_root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<code>http://192.168.200.133:8081/server?username=JERRY&amp;gender=1</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.6s6hlgez73g0.webp" alt="image"></p>
<blockquote>
<p><strong>可以把访问的信息记录在日志中</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="comment"># ......</span></span><br><span class="line">	<span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$request</span> - <span class="variable">$status</span> - <span class="variable">$request_uri</span> - <span class="variable">$http_user_agent</span>'</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">location</span> /server &#123;</span><br><span class="line">        	<span class="attribute">access_log</span> logs/access.log main;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/nginx/abc;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">            <span class="attribute">default_type</span> text/plain;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>=<span class="variable">$args</span>=<span class="variable">$http_user_agent</span>=<span class="variable">$host</span>=<span class="variable">$document_root</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<code>http://192.168.200.133:8081/server?username=JERRY&amp;gender=1</code></p>
<p>然后查看日志，效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.23y9h76w29b4.webp" alt="image"></p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p>该指令用来支持条件判断，并根据条件判断结果选择不同的 Nginx 配置。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>if (condition) { … }</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<p>if 和括号之间要有空格，condition 为判定条件，可以支持以下写法：</p>
<ul>
<li>变量名。如果变量名对应的值为空或者是 0，if 都判断为 false，其他条件为 true。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$param</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用『 = 』和『 != 』比较变量和字符串是否相等，满足条件为 true，不满足为 false</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> = POST)&#123;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">405</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：POST 和 Java 不太一样的地方是字符串不需要添加引号。</p>
<ul>
<li>使用正则表达式对变量进行匹配，匹配成功返回 true，否则返回 false。变量与正则表达式之间使用『 ~ 』，『 <del>* 』，『 !</del> 』，『 !~* 』来连接。<ul>
<li>『 ~ 』代表匹配正则表达式过程中区分大小写，进行模糊匹配</li>
<li>『 ~* 』代表匹配正则表达式过程中不区分大小写，进行模糊匹配</li>
<li>『 !~ 』和『 !~* 』刚好和上面取相反值，如果匹配上返回 false，匹配不上返回 true，进行模糊匹配</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~ MSIE)</span>&#123;</span><br><span class="line">	<span class="comment"># $http_user_agent 的值中是否包含 MSIE 字符串，如果包含返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断请求的文件是否存在使用『 -f 』和『 !-f 』<ul>
<li>当使用『 -f 』时，如果请求的文件存在返回 true，不存在返回 false。</li>
<li>当使用『 !-f 』时，如果请求文件不存在，但该文件所在目录存在返回 true，文件和目录都不存在返回 false，如果文件存在返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">	<span class="comment"># 判断请求的文件是否存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">	<span class="comment"># 判断请求的文件是否不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：用户访问的页面不存在，则返回一个友好的提示</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="comment"># 判断请求的文件是否不存在</span></span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;不好意思，文件资源找不到！&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断请求的目录是否存在使用『 -d 』和『 !-d 』</p>
<p>当使用『 -d 』时，如果请求的目录存在，返回 true，如果目录不存在则返回 false。</p>
<p>当使用『 !-d 』时，如果请求的目录不存在但该目录的上级目录存在则返回 true，该目录和它上级目录都不存在则返回 false，如果请求目录存在也返回false。</p>
</li>
</ul>
<h3 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h3><p>该指令用于中断当前相同作用域中的其他 Nginx 配置。与该指令处于同一作用域的 Nginx 配置中，位于它前面的指令配置生效，位于后面的指令配置无效。并且break还有另外一个功能就是终止当前的匹配并把当前的URI在本location进行重定向访问处理。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>break;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /testbreak &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$username</span> TOM;</span><br><span class="line">	<span class="attribute">if</span> (<span class="variable">$args</span>)&#123;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$username</span> JERRY;</span><br><span class="line">		break;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$username</span> ROSE;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="attribute">add_header</span> username <span class="variable">$username</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$username</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带参数访问：<code>http://192.168.200.133:8081/testbreak</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.2ok6tnbtnx20.webp" alt="image"></p>
<p>带参数访问：<code>http://192.168.200.133:8081/testbreak/1</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.1f6a03pxv4ow.webp" alt="image"></p>
<h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><p>该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在 return 后的所有 Nginx 配置都是无效的。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>return &lt;code&gt; [text];<br> return &lt;code&gt; &lt;URL&gt;; <br>return &lt;URL&gt;;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li>code：返回给客户端的 HTTP 状态代理。可以返回的状态代码为 0 ~ 999 的任意 HTTP 状态代理</li>
<li>text：返回给客户端的响应体内容，支持变量的使用和 JSON 字符串</li>
<li>URL：跳转给客户端的 URL 地址。</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"欢迎使用 Nginx"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /baidu &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">302</span> https://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问 Nginx，就会在页面看到这句话：欢迎使用 Nginx。</p>
<p>如果访问 <code>/baidu</code>，则跳转到 <code>https://www.baidu.com</code>。</p>
<h3 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h3><p>该指令通过正则表达式的使用来改变 URI。可以同时存在一个或者多个指令，按照顺序依次对 URL 进行匹配和处理。</p>
<p>URL 和 URI 的区别：</p>
<ul>
<li>URI：统一资源标识符</li>
<li>URL：统一资源定位符</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>rewrite regex replacement [flag];</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li><p>regex：用来匹配 URI 的正则表达式</p>
</li>
<li><p>replacement：匹配成功后，用于替换 URI 中被截取内容的字符串。如果该字符串是以 『 http:// 』或者『 https:// 』开头的，则不会继续向下对URI 进行其他处理，而是直接返回重写后的 URI 给客户端。</p>
<p>例如：（括号的值会作为 $1 的值）^ 代表匹配输入字符串的起始位置</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/url\w*$</span> https://www.baidu.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> /<span class="variable">$1</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://192.168.200.113/8081/rewrite/urlxxx</code>，跳转到 <code>https://www.baidu.com</code>。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/testxxx</code>，返回 test_sucess。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/demoxxx</code>，返回 demo_sucess。</p>
<p>flag：用来设置 Rewrite 对 URI 的处理行为，可选值有如下：</p>
<ul>
<li><code>last</code>：终止继续在本 location 块中处理接收到的后续 URI，并将此处重写的 URl 作为一个新的 URI，使用各 location 块进行处理。该标志将重写后的 URI 重写在 server 块中执行，为重写后的 URI 提供了转入到其他 location 块的机会。<strong>重写地址后访问其他的 location 块，浏览器地址栏 URL 地址不变</strong></li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">last</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">last</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://192.168.200.113/8081/rewrite/testxxx</code>，返回 test_sucess。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/demoxxx</code>，返回 demo_sucess。</p>
<p>单次访问不明显，多次访问，last 只处理第一个。</p>
<ul>
<li><code>break</code>：将此处重写的 URl 作为一个新的 URI，在本块中继续进行处理。该标志将重写后的地址在当前的 location 块中执行，不会将新的 URI 转向其他的 location 块。<strong>仅仅重写地址，不会触发其他 location 块，浏览器地址栏 URL 地址不变</strong></li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">break</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">break</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># /test 和 /demo 就在当前块进行处理，所以会在当前的 location 块找到如下 html 页面：</span></span><br><span class="line">    <span class="comment"># /usr/local/nginx/html/test/index.html</span></span><br><span class="line">    <span class="comment"># /usr/local/nginx/html/demo/index.html</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 break 指令类似。假设访问的是 /test，则将 /test 放在当前的 location 块进行处理，哪怕第二个 location 块就是处理 /test 的，它也不会去找第二个 location 块，只在当前块进行处理。所以他会请求 <code>/usr/local/nginx/html/test/index.html</code>。</p>
<ul>
<li><code>redirect</code>：将重写后的 URI 返回给客户端，状态码为 302，指明是临时重定向 URL，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">redirect</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">redirect</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点是重定向，就是<strong>浏览的地址栏会发送改变</strong>。如发送请求 <code>/testxxx</code>，它会重定向到 <code>/test</code>，触发第二个 location 块，浏览的地址栏也会由 <code>/testxxx</code> 变成 <code>/test</code>。</p>
<ul>
<li><code>permanent</code>：将重写后的 URI 返回给客户端，状态码为 301，指明是永久重定向 URL，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">permanent</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">permanent</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>redirect</code> 的区别就是状态码为 301，并且是永久重定向。</p>
<h3 id="flag-总结"><a href="#flag-总结" class="headerlink" title="flag 总结"></a>flag 总结</h3><table>
<thead>
<tr>
<th>标记符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>last</td>
<td>本条规则匹配完成后继续向下匹配新的 location URI 规则</td>
</tr>
<tr>
<td>break</td>
<td>本条规则匹配完成后终止，不在匹配任何规则</td>
</tr>
<tr>
<td>redirect</td>
<td>返回 302 临时重定向</td>
</tr>
<tr>
<td>permanent</td>
<td>返回 301 永久重定向</td>
</tr>
</tbody></table>
<ul>
<li>break 与 last 都停止处理后续重写规则，只不过 last 会重新发起新的请求并使用新的请求路由匹配location，但 break 不会。所以当请求 break 时，如匹配成功，则请求成功，返回 200；如果匹配失败，则返回 404</li>
<li>服务器配置好 redirect 和 permanent 之后，打开浏览器分别访问这两个请求地址，然后停止 Nginx 服务。这时再访问 redirect 请求会直接报出无法连接的错误。但是 permanent 请求是永久重定向，浏览器会忽略原始地址直接访问永久重定向之后的地址，所以请求仍然成功。（这个验证不能禁用浏览器的缓存，否则即使是 permanent 重定向，浏览器仍然会向原始地址发出请求验证之前的永久重定向是否有效）</li>
<li>对于搜索引擎来说，搜索引擎在抓取到 301 永久重定向请求响应内容的同时也会将原始的网址替换为重定向之后的网址，而对于 302 临时重定向请求则仍然会使用原始的网址并且可能会被搜索引擎认为有作弊的嫌疑。所以对于线上正式环境来讲，尽量避免使用 302 跳转</li>
<li>如果 replacement 以 「 http:// 」或「 https:// 」或「 $scheme 」开始，处理过程将终止，并将这个重定向直接返回给客户端</li>
</ul>
<h3 id="rewrite-log指令"><a href="#rewrite-log指令" class="headerlink" title="rewrite_log指令"></a>rewrite_log指令</h3><p>该指令配置是否开启 URL 重写日志的输出功能，默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>rewrite_log &lt;on | off&gt;;</td>
<td>rewrite_log off;</td>
<td>http、server、location、if</td>
</tr>
</tbody></table>
<p>开启后，URL 重写的相关日志将以 notice 级别输出到 error_log 指令配置的日志文件汇总。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /rewrite_log &#123;</span><br><span class="line">    <span class="attribute">rewrite_log</span> <span class="literal">on</span>;    <span class="comment"># 开启重写日志</span></span><br><span class="line">	<span class="attribute">error_log</span> logs /error.log <span class="literal">notice</span>;   <span class="comment"># 切换为 notice 模式，因为只支持这个模式</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'开启了重写日志'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rewrite的案例"><a href="#Rewrite的案例" class="headerlink" title="Rewrite的案例"></a>Rewrite的案例</h2><h3 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转"></a>域名跳转</h3><p>问题分析</p>
<p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入 <code>www.jd.com</code>，但是同样的我们也可以输入 <code>www.360buy.com</code> 同样也都能访问到京东网站。这个其实是因为京东刚开始的时候域名就是 <code>www.360buy.com</code>，后面由于各种原因把自己的域名换成了 <code>www.jd.com</code>，虽然说域名改变了，但是对于以前只记住了 <code>www.360buy.com</code> 的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用 Nginx 中 Rewrite 的域名跳转来解决。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>准备两个域名 <a href="http://www.360buy.com" target="_blank" rel="noopener">www.360buy.com</a> | <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.133 www.360buy.com</span><br><span class="line">192.168.200.133 www.jd.com</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>/usr/local/nginx/html/test</code> 目录下创建一个访问页面 frx.html</li>
</ul>
<p>添加内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 Nginx 实现当访问 <code>www.frx.com</code> 访问到 frx.html 页面</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> /usr/local/nginx/html/;</span><br><span class="line">		<span class="attribute">index</span> frx.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Rewrite 完成将 <code>www.360buy.com</code> 的请求跳转到 <code>www.jd.com</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.360buy.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.jd.com <span class="literal">permanent</span>;   <span class="comment"># 永久重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题描述：如何在域名跳转的过程中携带请求的 URI？</strong></p>
<p>比如 <code>www.360buy.com?part=显示器</code> 变成 <code>www.jd.com?part=显示器</code></p>
<ul>
<li>修改配置信息</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.itheima.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.hm.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>括号里是 <code>www.itheima.com</code> 后面出现 0 次或 多次不以 \n（换行）结尾的值，该值赋给 $1。</p>
<p><strong>问题描述：我们除了上述说的只有 <a href="http://www.jd.com、www.360buy.com，其实还有我们也可以通过" target="_blank" rel="noopener">www.jd.com、www.360buy.com，其实还有我们也可以通过</a> <a href="http://www.jingdong.com" target="_blank" rel="noopener">www.jingdong.com</a> 来访问，那么如何通过 Rewrite 来实现多个域名的跳转?</strong></p>
<ul>
<li>添加域名</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 hosts 文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加域名</span></span><br><span class="line">192.168.200.133 www.jingdong.com</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置信息</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.360buy.com www.jingdong.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.jd.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 server_name 用空格隔开。</p>
<h3 id="域名镜像"><a href="#域名镜像" class="headerlink" title="域名镜像"></a>域名镜像</h3><p>上述案例中，将 <code>www.360buy.com</code> 和 <code>www.jingdong.com</code> 都能跳转到 <code>www.jd.com</code>，那么 <code>www.jd.com</code> 我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，比如用户可以跳到首页 Web下，而管理员跳转到后台 Web，我们可以在 location 块中配置 Rewrite 功能。</p>
<p>比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> rewrite.myweb.com;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /user &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^/user(.*)</span> http://www.myweb.com/index<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 用户跳到首页</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /manage &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^/manage(.*)</span> http://www.myweb.com/manage<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 管理员跳到后台</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独立域名"><a href="#独立域名" class="headerlink" title="独立域名"></a>独立域名</h3><p>一个完整的项目包含多个模块，比如购物网站有商品商品搜索模块、商品详情模块已经购物车模块等，那么我们如何为每一个模块设置独立的域名。</p>
<p>需求：</p>
<ul>
<li><code>http://search.product.com</code>：访问商品搜索模块</li>
<li><code>http://item.product.com</code>：访问商品详情模块</li>
<li><code>http://cart.product.com</code>：访问商品购物车模块</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> search.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/search<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">	<span class="attribute">server_name</span> item.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/item<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line">	<span class="attribute">server_name</span> cart.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/cart<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动加『-』"><a href="#自动加『-』" class="headerlink" title="自动加『/』"></a>自动加『/』</h3><p>有时候访问的地址要求后面以 <code>/</code> 结尾，那么我们需要解决如果用户忘记输入 <code>/</code>，Nginx 就会自动加上 <code>/</code>。</p>
<p>通过一个例子来演示问题：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想访问上述资源，很简单，只需要通过 <code>http://192.168.200.133</code> 直接就能访问，地址后面不需要加 /，但是如果将上述的配置修改为如下内容:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /frx &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过 <code>http://192.168.200.133/frx/</code> 来访问，但是如果地址后面不加斜杠，如 <code>http://192.168.200.133/frx</code>，页面就会出问题。如果不加斜杠，Nginx 服务器内部会自动做一个 301 的重定向，重定向的地址会有一个指令叫 <code>server_name_in_redirect</code> 来决定重定向的地址：</p>
<ul>
<li><p>如果该指令为 on</p>
<p>重定向的地址为：<code>http://server_name/目录名/</code></p>
</li>
<li><p>如果该指令为 off</p>
<p>重定向的地址为：<code>http://原URL中的域名/目录名/</code></p>
</li>
</ul>
<p>所以就拿刚才的地址来说，访问 <code>http://192.168.200.133/frx</code> 如果不加斜杠，那么按照上述规则：</p>
<ul>
<li>如果指令 <code>server_name_in_redirect</code> 为 on，则 301 重定向地址变为 <code>http://localhost/frx/</code>，IP 发生改变，地址出现了问题</li>
<li>如果指令 <code>server_name_in_redirect</code> 为 off，则 301 重定向地址变为 <code>http://192.168.200.133/frx/</code>。这个符合我们的期望</li>
</ul>
<p>注意 <code>server_name_in_redirect</code> 指令在 Nginx 的 0.8.48 版本之前默认都是 on，之后改成了 off，所以现在我们这个版本不需要考虑这个问题，但是如果是 0.8.48 以前的版本并且 server_name_in_redirect 设置为 on，我们如何通过 Rewrite 来解决这个问题？</p>
<p>解决方案</p>
<p>我们可以使用 Rewrite 功能为末尾没有斜杠的 URL 自动添加一个斜杠</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">server_name_in_redirect</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">location</span> /frx &#123;</span><br><span class="line">		<span class="attribute">if</span> (-d <span class="variable">$request_filename</span>)&#123;   <span class="comment"># 如果请求的资源目录存在</span></span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/(.*)([^/])$</span> http://<span class="variable">$host</span>/<span class="variable">$1</span><span class="variable">$2</span>/ <span class="literal">permanent</span>; <span class="comment"># $2 获取第二个括号的值：/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$1 是第一个括号的值，$2 是第二个括号的值。</p>
<h3 id="合并目录"><a href="#合并目录" class="headerlink" title="合并目录"></a>合并目录</h3><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提供目的网站的有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含 URL 的目录层级，一般不要超过三层，否则的话不利于搜索引擎的搜索，也给客户端的输入带来了负担，但是将所有的文件放在一个目录下，又会导致文件资源管理混乱，并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用 Rewrite 如何解决这些问题呢？</p>
<p>举例，网站中有一个资源文件的访问路径 <code>/server/11/22/33/44/20.html</code>，也就是说 20.html 存在于第 5 级目录下，如果想要访问该资源文件，客户端的 URL 地址就要写成 <code>http://www.web.com/server/11/22/33/44/20.html</code>，并且在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个是非常不利于 SEO 搜索引擎优化的，同时客户端也不好记。使用 Rewrite 的正则表达式，我们可以进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.web.com;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$</span>  /server/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$4</span>/<span class="variable">$5</span>.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置后，客户端只需要输入 <code>http://www.web.com/server-11-22-33-44-20.html</code> 就可以访问到 20.html 页面了。这里也充分利用了 Rewrite 指令支持正则表达式的特性。</p>
<h3 id="多级域名"><a href="#多级域名" class="headerlink" title="多级域名"></a>多级域名</h3><p>当你配置了多级域名，如二级域名 <code>xxx.frxcat.fun</code>，并且静态资源目录恰好和二级域名的 <code>xxx</code> 可以匹配，则可以使用正则表达式进行匹配，日后，如果又多个 <code>xxx</code>，则再创建对应的该目录即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> ~^(.+)?.frxcat.fun$;</span><br><span class="line">    <span class="attribute">index</span> idnex.html;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$host</span> = frxcat.fun)&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.frxcat.fun<span class="variable">$2</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /data/html/<span class="variable">$1</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样访问 <code>docs.frxcat.fun</code>，自动去 <code>/data/html/docs/</code> 目录下找到 index.html，如果是 <code>bing.youngkbt.cn</code>，则会去 <code>/data/html/bing/</code> 目录下找到 idnex.html，以此类推。</p>
<p>if 语句的作用是将 <code>frxcat.fun</code> 重定向到 <code>www.frxcat.fun</code>，这样既解决了网站的主目录访问，又可以增加 SEO 中对 <code>www.frxcat.fun</code> 的域名权重。</p>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>防盗链之前我们已经介绍过了相关的知识，在 Rewrite 中的防盗链和之前将的原理其实都是一样的，只不过通过 Rewrite 可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用 Rewrite 将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。</p>
<p>下面有两个配置实例：</p>
<ul>
<li>根据文件类型实现防盗链配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">locatin</span> <span class="regexp">~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$</span> &#123;</span><br><span class="line">		<span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names <span class="regexp">*.web.com</span>; <span class="comment"># server_names 后指定具体的域名或者 IP</span></span><br><span class="line">		<span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.web.com/images/forbidden.png;  <span class="comment"># 跳转到默认地址</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据目录实现防盗链配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">location</span> /file &#123;</span><br><span class="line">		<span class="attribute">root</span> /server/file;  <span class="comment"># 资源在 server 目录下的 file 目录里</span></span><br><span class="line">		<span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names <span class="regexp">*.web.com</span>; <span class="comment"># server_names 后指定具体的域名或者 IP</span></span><br><span class="line">		<span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.web.com/images/forbidden.png;  <span class="comment"># 跳转到 file 目录下的图片</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问限流"><a href="#访问限流" class="headerlink" title="访问限流"></a>访问限流</h2><p>我们构建网站是为了让用户访问它们，我们希望用于合法访问。所以不得不采取一些措施限制滥用访问的用户。这种滥用指的是从同一 IP 每秒到服务器请求的连接数。因为这可能是在同一时间内，世界各地的多台机器上的爬虫机器人多次尝试爬取网站的内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制用户连接数来预防 DOS 攻击</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=perip:<span class="number">10m</span>;</span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$server_name</span> zone=perserver:<span class="number">10m</span>;</span><br><span class="line"><span class="comment"># 限制同一客户端 ip 最大并发连接数</span></span><br><span class="line"><span class="attribute">limit_conn</span> perip <span class="number">2</span>;</span><br><span class="line"><span class="comment"># 限制同一server最大并发连接数</span></span><br><span class="line"><span class="attribute">limit_conn</span> perserver <span class="number">20</span>;</span><br><span class="line"><span class="comment"># 限制下载速度，根据自身服务器带宽配置</span></span><br><span class="line"><span class="attribute">limit_rate</span> <span class="number">300k</span>;</span><br></pre></td></tr></table></figure>

<h2 id="链接超时"><a href="#链接超时" class="headerlink" title="链接超时"></a>链接超时</h2><p>长时间占着连接资源不释放，最终会导致请求的堆积，Nginx 处理请求效率大大降低。所以我们对连接的控制都要注意设置超时时间，通过超时机制自动回收资源、避免资源浪费。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端、服务端设置</span></span><br><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line"><span class="attribute">server_names_hash_max_size</span> <span class="number">512</span>;</span><br><span class="line"><span class="comment"># 长连接超时配置</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">15s</span>;</span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">15s</span>;</span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">60s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理设置</span></span><br><span class="line"><span class="comment"># 与后端服务器建立连接的超时时间。注意这个一般不能大于 75 秒</span></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">30s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">120s</span>;</span><br><span class="line"><span class="comment"># 从后端服务器读取响应的超时</span></span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">120s</span>;</span><br></pre></td></tr></table></figure>

<h2 id="HTML引入"><a href="#HTML引入" class="headerlink" title="HTML引入"></a>HTML引入</h2><p>我们编写 .html 文件的时候，难免需要引入 css 和 js 文件，如果是在本地，那么引入非常简单，直接相对路径即可，但是部署到 Nginx 时，相对路径不再是相对 html 文件的目录，所以生产环境和开发环境的引入格式不一样。</p>
<p>在 Nginx 中的 .html 文件，引入 css 和 js，要加上 <code>/</code> 作为开头，<code>/</code> 代表 Nginx 的根目录，即配置文件 <code>location /</code> 的指定的 root 路径。</p>
<p>比如 Nginx 的配置文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/nginx/html; <span class="comment"># 静态文件根目录</span></span><br><span class="line">        <span class="attribute">index</span> idnex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个 aa.html 在 <code>/usr/local/nginx/html/test</code> 目录下，并且 aa.html 引入了 aa.css 和 aa.js，两个静态文件在 aa.html 所在目录的 static 文件夹里。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/html/<span class="built_in">test</span> 目录</span><br><span class="line">├── a.html</span><br><span class="line">├── static</span><br><span class="line">│	├── a.css</span><br><span class="line">│	├── a.js</span><br></pre></td></tr></table></figure>

<p>在本地环境，我们可以这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/aa.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/aa.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是部署到 Nginx 后，这样写会找不到这两个资源，因为 <code>/</code> 触发 <code>location /</code>，进入 <code>/usr/local/nginx/html</code> 目录，而这两个文件在 <code>/usr/local/nginx/html/test/static</code> 目录下，所以我们部署到 Nginx 后，需要修改为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/test/static/aa.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/test/static/aa.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/46/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/75/">75</a><a class="extend next" rel="next" href="/page/48/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>