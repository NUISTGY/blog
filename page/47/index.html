<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">224</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/14/Nginx_Cache_integration/">Nginx 缓存集成</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-缓存集成"><a href="#Nginx-缓存集成" class="headerlink" title="Nginx 缓存集成"></a>Nginx 缓存集成</h1><h2 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a>缓存的概念</h2><p>缓存就是数据交换的缓冲区（称作：Cache），当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.371wkgon7280.webp" alt="image"></p>
<p>缓存其实在很多场景中都有用到，比如：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统磁盘缓存</td>
<td>减少磁盘机械操作</td>
</tr>
<tr>
<td>数据库缓存</td>
<td>减少文件系统的IO操作</td>
</tr>
<tr>
<td>应用程序缓存</td>
<td>减少对数据库的查询</td>
</tr>
<tr>
<td>Web 服务器缓存</td>
<td>减少对应用服务器请求次数</td>
</tr>
<tr>
<td>浏览器缓存</td>
<td>减少与后台的交互次数</td>
</tr>
</tbody></table>
<p>缓存的优点</p>
<ul>
<li>减少数据传输，节省网络流量，加快响应速度，提升用户体验</li>
<li>减轻服务器压力</li>
<li>提供服务端的高可用性</li>
</ul>
<p>缓存的缺点</p>
<ul>
<li>数据的不一致</li>
<li>增加成本</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.2itt4ge9erq0.webp" alt="image"></p>
<p>在 <a href="/middleware/Nginx/Nginx_Static_resource_deployment/#静态资源缓存配置">静态资源部署 - 缓存配置</a> 的时候，我们学习了如何在浏览器进行缓存，而本内容学习的是 Nginx。</p>
<p>Nginx 作为 Web 服务器，Nginx 作为 Web 缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个 URL 时，Web 缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个 URL，Web 缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。Web 缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。</p>
<h2 id="Web缓存服务"><a href="#Web缓存服务" class="headerlink" title="Web缓存服务"></a>Web缓存服务</h2><p>Nginx 是从 0.7.48 版开始提供缓存功能。Nginx 是基于 Proxy Store 来实现的，<strong>其原理是把 URL 及相关组合当做 Key，在使用 MD5 算法对 Key 进行哈希化，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中</strong>。它可以支持任意 URL 连接，同时也支持 404/301/302 这样的非200 状态码。Nginx 即可以支持对指定 URL 或者状态码设置过期时间，也可以使用 purge 命令来手动清除指定 URL 的缓存。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.5rf186zoffg0.webp" alt="image"></p>
<h2 id="缓存设置相关指令"><a href="#缓存设置相关指令" class="headerlink" title="缓存设置相关指令"></a>缓存设置相关指令</h2><p>Nginx 的 Web 缓存服务主要是使用 <code>ngx_http_proxy_module</code> 模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module 文档地址</a></p>
<h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h3><p>该指定用于设置缓存文件的存放路径。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_path &lt;path&gt; [levels=number]<br> &lt;keys_zone=zone_name:zone_size&gt; [inactive=time][max_size=size];</td>
<td>—</td>
<td>http</td>
</tr>
</tbody></table>
<p><code>path</code>：缓存路径地址，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/proxy_cache</span><br></pre></td></tr></table></figure>

<p><code>levels</code>: 指定该缓存空间 <code>path</code> 基础上新建的目录，最多可以设置 3 层，每层取 1 到 2 个字母作为目录名，格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">levels=num:num:num   # 三个 num 代表三层，每层目录名分别取 num 个字母</span><br><span class="line">levels=num:num       # 两个 num 代表两层，每层目录名分别取 num 个字母</span><br><span class="line">levels=num           # 一个 num 代表一层，每层目录名分别取 num 个字母</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">levels=1:2   # 缓存空间有两层目录，第一层目录名取 1 个字母，第二层目录名取 2 个字母</span><br></pre></td></tr></table></figure>

<p>字母名从 MD5 加密的值后面往前截取。</p>
<p>举例说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 proxy_cache_key 为 kele，通过 MD5 加密以后的值为 27ce47ea65c1381dbe5175f7c77d8a3a</span></span><br><span class="line">levels=1:2    # 最终的存储路径为 /usr/local/proxy_cache/a/a3，每层截取个数根据 1:2</span><br><span class="line">levels=2:1:2  # 最终的存储路径为 /usr/local/proxy_cache/3a/a/d8，每层截取个数根据 2:1:2</span><br><span class="line">levels=2:2:2  # 最终的存储路径为 /usr/local/proxy_cache/3a/8a/7d，每层截取个数根据 2:2:2</span><br></pre></td></tr></table></figure>

<p>还不理解吗？存储路径在 <code>path</code> 目录基础上再创建新的目录，新的目录名从加密后的值的后面往前面截取。</p>
<p><code>keys_zone</code>：用来为这个存key的缓存区设置名称和指定大小，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys_zone=kele:200m  # 缓存区的名称是 kele，大小为 200M，1M 大概能存储 8000 个 keys</span><br></pre></td></tr></table></figure>

<p><code>inactive</code>：指定的时间内未访问的缓存数据会从缓存中删除，默认情况下，<code>inactive</code> 设置为 10 分钟。如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inactive=1d   # 缓存数据在 1 天内没有被访问就会被删除</span><br></pre></td></tr></table></figure>

<p><code>max_size</code>：设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，默认单位为兆。如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_size=20g    # 最大缓存空间为 20G</span><br></pre></td></tr></table></figure>

<p>配置实例:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">proxy_cache_path</span> /usr/local/proxy_cache keys_zone=kele:<span class="number">200m</span> levels=<span class="number">1</span>:<span class="number">2</span>:<span class="number">1</span> inactive=<span class="number">1d</span> max_size=<span class="number">20g</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时重启 Nginx 配置文件，发现 <code>/usr/local</code> 目录里多出一个目录，名字叫做 proxy_cache。</p>
<h3 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h3><p>该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache &lt;zone_name | off&gt;;</td>
<td>proxy_cache off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>zone_name：指定使用缓存区的名称。</p>
<p>缓存区的名称必须是 <code>proxy_cache_path</code> 里的 <code>keys_zone</code> 生成的缓存名。</p>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>该指令用来设置 Web 缓存的 key 值，Nginx 会根据 key 值利用 MD5 计算处哈希值并缓存起来，作为缓存目录名的参考。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_key &lt;key&gt;;</td>
<td>proxy_cache_key $scheme$proxy_host$request_uri;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>如 kele 由 MD5 计算出来是 27ce47ea65c1381dbe5175f7c77d8a3a</p>
<p>在哪计算出来的？ 前往 <a href="https://md5jiami.bmcx.com/" target="_blank" rel="noopener">MD5 在线加密网站</a></p>
<h3 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a>proxy_cache_valid</h3><p>该指令用来对不同返回状态码的 URL 设置不同的缓存时间。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_valid [code …… ] &lt;time&gt;;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>; <span class="comment"># 为 200 和 302 的响应 URL 设置 10 分钟缓存时间</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;      <span class="comment"># 为 404 的响应 URL 设置 1 分钟缓存时间</span></span><br><span class="line"><span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;      <span class="comment"># 对所有响应状态码的URL都设置 1 分钟缓存时间</span></span><br></pre></td></tr></table></figure>

<h3 id="proxy-cache-min-uses"><a href="#proxy-cache-min-uses" class="headerlink" title="proxy_cache_min_uses"></a>proxy_cache_min_uses</h3><p>该指令用来设置资源被访问多少次后才会被缓存。默认是 1 次。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_min_uses &lt;number&gt;;</td>
<td>proxy_cache_min_uses 1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<h3 id="proxy-cache-methods"><a href="#proxy-cache-methods" class="headerlink" title="proxy_cache_methods"></a>proxy_cache_methods</h3><p>该指令是设置缓存哪些 HTTP 方法的请求资源。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_methods &lt;GET | HEAD | POST&gt;;</td>
<td>proxy_cache_methods GET HEAD;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>默认缓存 HTTP 的 GET 和 HEAD 方法的请求资源，不缓存 POST 方法的请求资源。</p>
<h2 id="缓存设置案例"><a href="#缓存设置案例" class="headerlink" title="缓存设置案例"></a>缓存设置案例</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.4ye8ddxwbng0.webp" alt="image"></p>
<h3 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h3><p><strong>应用服务器的环境准备</strong></p>
<ol>
<li><p>在 <code>192.168.200.146</code> 服务器 A 上的 tomcat 的 webapps 下面添加一个 js 目录，并在 js 目录中添加一个 jquery.js 文件</p>
</li>
<li><p>启动 tomcat</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/tomcat/bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>访问服务器 A 进行测试</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://192.168.200.146:8080/js/jquery.js</span></span><br></pre></td></tr></table></figure>

<p><strong>Nginx 的环境准备</strong></p>
<ol>
<li>准备服务器 B 完成 Nginx 的反向代理配置</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">upstream</span> backend&#123;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">192.168.200.146:8080</span>;   <span class="comment"># 服务器 A 地址</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">listen</span>       <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        	<span class="attribute">proxy_pass</span> http://backend/js/;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>完成 Nginx 缓存配置</li>
</ol>
<p><strong>有注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /usr/local/proxy_cache levels=<span class="number">2</span>:<span class="number">1</span> keys_zone=bing:<span class="number">200m</span> inactive=<span class="number">1d</span> max_size=<span class="number">20g</span>;</span><br><span class="line">    <span class="attribute">upstream</span> backend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:8080</span>;   <span class="comment"># 服务器 A 的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8080</span>;     			<span class="comment"># 监听 8080 端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost; 		<span class="comment"># 监听 localhost 的IP</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;					<span class="comment"># 监听包含 / 的请求</span></span><br><span class="line">            <span class="attribute">proxy_cache</span> bing;    		<span class="comment"># 开启 bing 缓存区，和第 2 行的 keys_zone 对应</span></span><br><span class="line">            <span class="attribute">proxy_cache_key</span> kele;  		<span class="comment"># 缓存的 key 值，会被 MD5 解析成字符串用于生成缓存的目录</span></span><br><span class="line">            <span class="attribute">proxy_cache_min_uses</span> <span class="number">5</span>; 	<span class="comment"># 资源被访问 5 次后才会被缓存</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5d</span>;	<span class="comment"># 为 200 响应 URL 设置 5 天缓存时间</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">30s</span>;  <span class="comment"># 为 404 的响应 URL 设置 30 秒缓存时间</span></span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;	<span class="comment"># 为除了上方的任意响应 URL 设置 1 分钟缓存时间</span></span><br><span class="line">            <span class="attribute">add_header</span> nginx-cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>;  <span class="comment"># 将缓存的状态放到请求头里</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend/js/;  <span class="comment"># 代理 backend，将 /js/ 追加到 backend 模块里的地址后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /usr/local/proxy_cache levels=<span class="number">2</span>:<span class="number">1</span> keys_zone=bing:<span class="number">200m</span> inactive=<span class="number">1d</span> max_size=<span class="number">20g</span>;</span><br><span class="line">    <span class="attribute">upstream</span> backend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_cache</span> bing;</span><br><span class="line">            <span class="attribute">proxy_cache_key</span> kele;</span><br><span class="line">            <span class="attribute">proxy_cache_min_uses</span> <span class="number">5</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">5d</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">30s</span>;</span><br><span class="line">            <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line">            <span class="attribute">add_header</span> nginx-cache <span class="string">"<span class="variable">$upstream_cache_status</span>"</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend/js/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>测试是否缓存成功</li>
</ol>
<p>利用 <code>$upstream_cache_status</code> 的值在控制台(F12)查看是否缓存。</p>
<p>第一次访问 <code>192.168.200.113:8080/jquery.js</code>，如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.3p1azxp6cdy0.webp" alt="image"></p>
<p>因为第一次访问时，正在缓存，所以返回的请求头 MISS 是没有缓存成功。</p>
<p>第二次访问 <code>192.168.200.113:8080/jquery.js</code>，如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.73w7kaxo8r00.webp" alt="image"></p>
<p>HIT 代表成功缓存。</p>
<ol start="4">
<li>测试 404 缓存时间</li>
</ol>
<p>测试 404 缓存时间，我们访问 <code>192.168.200.113:8080/jquery.js111</code>，它会返回 404 页面，并缓存 404 页面，当我们立即访问正确的 <code>192.168.200.113:8080/jquery.js</code>，它依然返回 404 页面，因为 <code>/jquery.js</code> 请求目前被缓存为 404，还没到 30 秒过期，等 30 秒后再访问，就成功了。</p>
<h2 id="缓存的删除"><a href="#缓存的删除" class="headerlink" title="缓存的删除"></a>缓存的删除</h2><p>这里介绍两种方式：</p>
<ul>
<li>删除对应的缓存目录</li>
<li>使用第三方扩展模块</li>
</ul>
<h3 id="删除缓存目录"><a href="#删除缓存目录" class="headerlink" title="删除缓存目录"></a>删除缓存目录</h3><p>假设缓存目录是 <code>/usr/local/proxy_cache/</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/proxy_cache/......</span><br></pre></td></tr></table></figure>

<p>如果想删除某个缓存目录，就在后面加上目录名。如果想删除整个缓存目录，直接删除 <code>/usr/local/proxy_cache/</code> 即可。</p>
<h3 id="ngx-cache-purge删除"><a href="#ngx-cache-purge删除" class="headerlink" title="ngx_cache_purge删除"></a>ngx_cache_purge删除</h3><p>使用第三方扩展模块 <code>ngx_cache_purge</code> 进行删除缓存。</p>
<ol>
<li><p>下载 <code>ngx_cache_purge</code> 模块对应的资源包，并上传到服务器的 <code>/root/nginx/module/</code> 目录下。</p>
<p>这里的资源包是 ngx_cache_purge-2.3.tar.gz</p>
</li>
<li><p>对资源文件进行解压缩</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改文件夹名称为 <code>purge</code>，方便后期配置</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ngx_cache_purge-2.3 purge</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查询 Nginx 的配置参数 <code>configure arguments</code>，并拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>进入 Nginx 的安装包目录，使用 ./configure 进行参数配置，记得加上 <code>nginx -V</code> 查询出来的 <code>configure arguments</code> 参数</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/root/nginx/module/purge  <span class="comment"># 加上之前的 configure arguments 参数</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用 make 进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 Nginx 安装目录的 nginx 二级制可执行文件备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>将编译后的 objs 中的 nginx 拷贝到 nginx 的 sbin 目录下</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>使用 <code>make upgrade</code> 进行升级，记得在安装包目录下执行</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.20.2</span><br><span class="line"></span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>在 Nginx 配置文件中进行如下配置</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">location</span> ~/purge(/.*) &#123;</span><br><span class="line">        <span class="attribute">proxy_cache_purge</span> bing kele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proxy_cache_purge</code> 指令</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_purge &lt;cache&gt; &lt;key&gt;</td>
<td>-</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li><code>cache</code> 是 <code>proxy_cache</code>，详细内容看 <a href="https://notes.youngkbt.cn/nginx/cache-integration/#proxy-cache" target="_blank" rel="noopener">proxy_cache</a></li>
<li><code>key</code> 是 <code>proxy_cache_key</code>，详细内容看 <a href="https://notes.youngkbt.cn/nginx/cache-integration/#proxy-cache-key" target="_blank" rel="noopener">proxy_cache_key</a></li>
</ul>
<h2 id="资源不缓存"><a href="#资源不缓存" class="headerlink" title="资源不缓存"></a>资源不缓存</h2><p>前面咱们已经完成了 Nginx 作为 Web 缓存服务器的使用。但是我们得思考一个问题，<strong>不是所有的数据都适合进行缓存</strong>。比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。</p>
<p>Nginx 也提供了这块的功能设置，需要使用到如下两个指令：</p>
<ul>
<li>proxy_no_cache</li>
<li>proxy_cache_bypass</li>
</ul>
<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>该指令是用来定义不将数据进行缓存的条件，也就是不缓存指定的数据。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_no_cache &lt;string&gt; …… ;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>可设置多个 string。</p>
<p>配置实例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_no_cache</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span> <span class="variable">$arg_comment</span>;</span><br></pre></td></tr></table></figure>

<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>该指令是用来设置不从缓存中获取数据的条件，也就是虽然缓存了指定的资源，但请求过来也不会去获取它，而是去服务器里获取资源。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_cache_bypass &lt;string&gt; …… ;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>可设置多个 string。</p>
<p>配置实例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_bypass</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span> <span class="variable">$arg_comment</span>;</span><br></pre></td></tr></table></figure>

<p>上述两个指令都有一个指定的条件，这个条件可以是多个，<strong>并且多个条件中至少有一个不为空且不等于「0」，则条件满足成立。</strong></p>
<p>上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是 <code>$cookie_nocache</code>、<code>$arg_nocache</code>、<code>$arg_comment</code></p>
<h3 id="常用不缓存变量"><a href="#常用不缓存变量" class="headerlink" title="常用不缓存变量"></a>常用不缓存变量</h3><p>常用不缓存的三个变量分别为：</p>
<ul>
<li><code>$cookie_nocache</code></li>
<li><code>$arg_nocache</code></li>
<li><code>$arg_comment</code></li>
</ul>
<p>这三个变量分别代表的含义是:</p>
<ul>
<li><code>$cookie_nocache</code>：指的是当前请求的 cookie 中 key 为 nocache 的 value 值</li>
<li><code>$arg_nocache</code> 和 <code>$arg_comment</code>：指的是当前请求的参数中属性名为 nocache 和 comment 对应的属性值</li>
</ul>
<p>案例演示:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> params <span class="variable">$cookie_nocache</span> | <span class="variable">$arg_nocache</span> | <span class="variable">$arg_comment</span>；</span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>	<span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">access_log</span> logs/access_params.log params;</span><br><span class="line">        <span class="attribute">add_header</span> Set-Cookie <span class="string">'nocache=888'</span>;</span><br><span class="line">        <span class="attribute">root</span> html;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>192.168.200.133:8081?nocache=999&amp;comment=777</code>，然后去日志查看结果，如图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.695kmtpob840.webp" alt="image"></p>
<p>以后访问的某一个资源如果不想缓存，在 URL 后面加入三个变量中的任意一个或多个即可，只要它们不为空或 0。</p>
<p>这三个变量推荐作为不缓存资源的条件，但并不是只能作为不缓存资源的条件。</p>
<h3 id="案例模板"><a href="#案例模板" class="headerlink" title="案例模板"></a>案例模板</h3><p>设置不缓存资源的配置方案模板：</p>
<ul>
<li>如果访问的是 js 文件，则不会缓存该 js 文件</li>
<li>如果 <code>$nocache</code> <code>$cookie_nocache</code> <code>$arg_nocache</code> <code>$arg_comment</code> 任意不为空或 0，则访问的资源不进行缓存</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>	<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_uri</span> <span class="regexp">~ /.*\.js$)</span>&#123;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$nocache</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">proxy_no_cache</span> <span class="variable">$nocache</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span> <span class="variable">$arg_comment</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_bypass</span> <span class="variable">$nocache</span> <span class="variable">$cookie_nocache</span> <span class="variable">$arg_nocache</span> <span class="variable">$arg_comment</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不会缓存 js 文件呢，看第 5 - 6 行代码。如果访问的文件是 js 文件，则设置 <code>$nocache</code> 为 1，只要它不为 0，则触发第 8 行代码，<code>proxy_no_cache</code> 后面的参数只要有一个不为空或 0，则访问的资源不进行缓存。</p>
<hr>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>proxy_cache_path设置缓存路径，其中有一个inactive参数设置cache设置不活跃缓存的删除时间。<br>proxy_cache_valid设置不同响应码的缓存过期时间。</p>
<p><strong>提出问题</strong></p>
<p>那么这俩参数同时设置，哪个生效呢？</p>
<p>根据上面Stack Overflow的说法。<strong>inactive应该需要设置的比valid中时间长。</strong></p>
<p>注意，inactive时间到了，数据删除。valid过期了数据不会删除。有请求，inactive就刷新计时，valid不变。没请求，inactive和valid都不变。</p>
<p>分析各种情况：</p>
<p><strong>1、inactive设置1m，valid设置1h</strong><br>首先，请求进来，cache出现，两个时间开始倒计时。<br>情况一：不断请求这个cache，inactive不断刷新1m倒计时，直到到达1h，valid过期。这时你去请求了一次，nginx重新去读取服务器数据，刷新valid倒计时。期间数据一直在缓存里。不请求，就再过1m删掉。<br>情况二：两次请求间隔超过了1min，inactive生效，删除了这个cache数据，没了。你再请求，相当于重新去服务器拿了一次数据，inactive和valid倒计时都会重新刷新，不请求，cache里就没有这份数据了</p>
<p><strong>2、inactive设置1m,valid设置1m</strong><br>首先，请求进来，cache出现，两个时间开始倒计时。<br>情况一：1m内不请求，最后inactive生效删掉。不请求就没缓存了，请求了一次，重新从服务器读取一份，两个计时刷新。<br>情况二：1m内请求了一次，inactive时间刷新，但是valid还在计时，所以1m到了后，缓存过期了。你再请求就重新从服务器读取一份，刷新计时。不请求，就等待1m，由inactive生效删除了缓存</p>
<p><strong>3、inactive设置1h，valid设置了1m</strong><br>首先，请求进来，cache出现，两个时间开始倒计时。<br>过了1m，缓存过期，数据在没删掉。不请求，直到1h到，inactive删掉缓存。请求了一次，重新从服务器读取，刷新两个计时。</p>
<p>所以，结论inactive应该需要设置的比valid中时间长。<br>目的是针对，一个长期不使用的缓存数据，把他删掉不占用存储，或者强制刷新。</p>
<ul>
<li>inactive是针对两次请求间隔时间，到时间就删掉不占用内存。</li>
<li>valid是针对持续不断的请求，导致一直缓存，我设置时间强制刷新一下。例如，支付宝每时每刻都有人访问，一直请求，缓存就一直不刷新一直是旧的。</li>
</ul>
<p>inactive和valid是配合使用，不是谁时间短覆盖谁的关系。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/14/Nginx_load_balancing/">Nginx 负载均衡</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h1><p><strong>负载均衡</strong></p>
<p>负载均衡是实际开发必须掌握的技能，Nginx 如何将少数请求跟多台服务器进行沟通，让每一台服务器的请求处理面面俱到？本内容将学习 Nginx 的负载均衡知识。</p>
<h2 id="负载均衡概述"><a href="#负载均衡概述" class="headerlink" title="负载均衡概述"></a>负载均衡概述</h2><p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？这就需要负载均衡来处理。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.5kgql84ikx80.webp" alt="image"></p>
<h2 id="负载均衡原理及处理流程"><a href="#负载均衡原理及处理流程" class="headerlink" title="负载均衡原理及处理流程"></a>负载均衡原理及处理流程</h2><p>系统的扩展可以分为纵向扩展和横向扩展。</p>
<ul>
<li>纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力</li>
<li>横向扩展是通过添加机器来满足大型网站服务的处理能力</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.1xwd1pm6du68.webp" alt="image"></p>
<p>如上图，负载均衡涉及到两个重要的角色分别是「应用集群」和「负载均衡器」。</p>
<ul>
<li>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据</li>
<li>负载均衡器：将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理</li>
</ul>
<h3 id="负载均衡作用"><a href="#负载均衡作用" class="headerlink" title="负载均衡作用"></a>负载均衡作用</h3><ul>
<li>解决服务器的高并发压力，提高应用程序的处理性能</li>
<li>提供故障转移，实现高可用</li>
<li>通过添加或减少服务器数量，增强网站的可扩展性</li>
<li>在负载均衡器上进行过滤，可以提高系统的安全性</li>
</ul>
<h2 id="负载均衡常用处理方式"><a href="#负载均衡常用处理方式" class="headerlink" title="负载均衡常用处理方式"></a>负载均衡常用处理方式</h2><p>先说明，我们常用的是 <a href="/middleware/Nginx/Nginx_load_balancing/#四-七层负载均衡">四/七层负载均衡</a> 方式，前面两个方式可以了解。</p>
<h3 id="用户手动选择"><a href="#用户手动选择" class="headerlink" title="用户手动选择"></a>用户手动选择</h3><p>这种方式比较原始，主要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p>
<p>如下图，用户点击不同的下载方式，就会跳转到不同的下载地址。这是主动式的负载均衡，我们无法控制用户的选择。如果用户全部点击第一个下载方式，那么服务器的压力将非常大。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.2auhoddxb2zo.webp" alt="image"></p>
<h3 id="DNS轮询方式"><a href="#DNS轮询方式" class="headerlink" title="DNS轮询方式"></a>DNS轮询方式</h3><p>DNS：域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换。</p>
<p>大多域名注册商都支持对同一个主机名添加多条 A 记录，这就是 DNS 轮询，DNS 服务器将解析请求按照 A 记录的顺序，随机分配到不同的 IP 上，这样就能完成简单的负载均衡。DNS 轮询的成本非常低，在一些不重要的服务器，被经常使用。</p>
<p>如下图：客户端如果想访问服务器集群，首先去 DNS 服务器获取我们曾经在 DNS 服务器保存的「记录表」，这个「记录表」将会把某个服务器的地址返回给客户端，客户端再根据这个地址，访问指定的服务器。这个「记录表」在开始期间需要我们去 DNS 服务器进行添加。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.b1m3qaeuxsk.webp" alt="image"></p>
<p>「记录表」长什么样，如下图的主机记录 www。这是我为某一个域名添加的 IP 地址，用 2 台服务器来做负载均衡。其中两个记录值都绑定了 <code>www.nginx521.cn</code> 地址。(一个域名可以绑定多个IP地址)</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.3drj9szeeus0.webp" alt="image"></p>
<p>验证:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.nginx521.cn</span><br></pre></td></tr></table></figure>

<p>注意：记得清空本地的 DNS 缓存，如果本地有缓存，无论你怎么 <code>ping</code>，都会 <code>ping</code> 到缓存的服务器地址，无法负载均衡</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure>

<p>目前需要 <code>ping</code> 一次然后清理一次缓存，才能实现负载均衡的轮询效果。</p>
<p>我们发现使用 DNS 来实现轮询，不需要投入过多的成本，虽然 DNS 轮询成本低廉，但是 DNS 负载均衡存在明显的缺点：</p>
<ol>
<li><p>可靠性低</p>
<p>假设一个域名 DNS 轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的 IP 从 DNS 中去掉，但是由于各大宽带接入商将众多的 DNS 存放在缓存中，以节省访问时间，导致 DNS 不会实时更新。所以 DNS 轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p>
</li>
<li><p>负载均衡不均衡</p>
<p>DNS 负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到 IP 地址的映射，这也会导致使用该 DNS 服务器的用户在一定时间内访问的是同一台 Web 服务器，从而引发 Web 服务器减的负载不均衡。</p>
<p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p>
</li>
</ol>
<h3 id="四-七层负载均衡"><a href="#四-七层负载均衡" class="headerlink" title="四/七层负载均衡"></a>四/七层负载均衡</h3><p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection)，叫开放式系统互联模型，这个是由国际标准化组织 ISO 指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.5g3vvj5xa3g0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.6uq265ihol80.webp" alt="image"></p>
<ul>
<li>应用层：为应用程序提供网络服务。</li>
<li>表示层：对数据进行格式化、编码、加密、压缩等操作</li>
<li>会话层：建立、维护、管理会话连接</li>
<li>传输层：建立、维护、管理端到端的连接，常见的有 TCP/UDP</li>
<li>网络层：IP 寻址和路由选择</li>
<li>数据链路层：控制网络层与物理层之间的通信</li>
<li>物理层：比特流传输</li>
</ul>
<p><strong>什么是四层负载均衡</strong></p>
<p>所谓四层负载均衡指的是 OSI 七层模型中的传输层，主要是基于 IP + PORT 的负载均衡</p>
<p>实现四层负载均衡的方式：</p>
<ul>
<li>硬件：F5 BIG-IP、Radware 等，性能好，成本高、无法扩展</li>
<li>软件：LVS、Nginx、Hayproxy 等，性能较好，成本低、可以扩展</li>
</ul>
<p><strong>什么是七层负载均衡</strong></p>
<p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的 URL 或主机 IP 的负载均衡</p>
<p>实现七层负载均衡的方式：</p>
<ul>
<li>软件：Nginx、Hayproxy 等</li>
</ul>
<p><strong>四层和七层负载均衡的区别</strong></p>
<ul>
<li>四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高（四层比七层少，速度块，效率高，但是可能请求丢失等）</li>
<li>四层负载均衡不识别域名，而七层负载均衡识别域名</li>
</ul>
<p>处理四层和七层负载以外，其实还有二层、三层负载均衡，二层是在数据链路层基于 mac 地址来实现负载均衡，三层是在网络层一般采用虚拟 IP 地址的方式实现负载均衡。</p>
<p><strong>实际环境采用的模式：四层负载(LVS) + 七层负载(Nginx)</strong></p>
<h2 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h2><p>Nginx 要实现七层负载均衡需要用到 proxy_pass 代理模块配置。Nginx 默认安装支持这个模块，我们不需要再做任何处理。Nginx 的负载均衡是在 Nginx 反向代理的基础上把用户的请求根据指定的算法分发到一组「upstream 虚拟服务池」。</p>
<h3 id="七层负载均衡指令"><a href="#七层负载均衡指令" class="headerlink" title="七层负载均衡指令"></a>七层负载均衡指令</h3><h4 id="upstream指令"><a href="#upstream指令" class="headerlink" title="upstream指令"></a>upstream指令</h4><p>该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听 TCP 和 Unix socket 的服务器。服务器可以指定不同的权重，默认为 1。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>upstream &lt;name&gt; {…}</td>
<td>—</td>
<td>http</td>
</tr>
</tbody></table>
<h4 id="server指令"><a href="#server指令" class="headerlink" title="server指令"></a>server指令</h4><p>该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者 Unix socket。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>server &lt;name&gt; [paramerters]</td>
<td>—</td>
<td>upstream</td>
</tr>
</tbody></table>
<p>server 后的 name 就是 upstream 后的 name，两者保持一致。</p>
<h3 id="七层负载均衡指令案例"><a href="#七层负载均衡指令案例" class="headerlink" title="七层负载均衡指令案例"></a>七层负载均衡指令案例</h3><p>准备四台服务器，一台用来做负载均衡器，三台用来接收负载均衡器的请求。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.etsfgkwsxaw.webp" alt="image"></p>
<p>因为目前只有两台服务器，所以一台用来做负载均衡器，另外一台用来接收负载均衡器的请求。</p>
<p>服务器设置：这里以三个端口代替三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器 1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 服务器 2</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9002</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 服务器 3</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>   <span class="number">9003</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负载均衡器设置：这是一个 Nginx 代理服务器，让它去负载均衡访问三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9091</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9092</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9093</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;   <span class="comment"># backend 要对应上 upstream 后的值，根据需求修改</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问负载均衡器的地址，如 <code>http://192.168.200.133:8083</code>，它会找到 <code>proxy_pass</code> 后的地址，比如上方，它会根据 backend 找到对应的 upstream 里内地址，替换掉 backend，变成：</p>
<ul>
<li>proxy_pass <code>http://192.168.200.146:9091</code></li>
<li>proxy_pass <code>http://192.168.200.146:9092</code></li>
<li>proxy_pass <code>http://192.168.200.146:9093</code></li>
</ul>
<p>但是它不会全部访问三个服务器地址，而是根据自己的算法（轮询）选择其中一个服务器地址。</p>
<h3 id="七层负载均衡状态"><a href="#七层负载均衡状态" class="headerlink" title="七层负载均衡状态"></a>七层负载均衡状态</h3><p>代理服务器在负责均衡调度中的状态有以下几个：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>down</td>
<td>当前的 server 暂时不参与负载均衡</td>
</tr>
<tr>
<td>backup</td>
<td>预留的备份服务器</td>
</tr>
<tr>
<td>max_fails</td>
<td>允许请求失败的次数</td>
</tr>
<tr>
<td>fail_timeout</td>
<td>经过 max_fails 失败后，服务暂停时间</td>
</tr>
<tr>
<td>max_conns</td>
<td>限制最大的接收连接数</td>
</tr>
</tbody></table>
<h4 id="down"><a href="#down" class="headerlink" title="down"></a>down</h4><p><code>down</code> 指令将该服务器标记为永久不可用，那么负载均衡器将不参与该服务器的负载均衡。</p>
<p>如下，如果不希望负载均衡器以负载均衡来处理 <code>192.168.200.146</code> 服务器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该状态一般会对需要停机维护的服务器进行设置。</p>
<h4 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h4><p><code>backup</code> 指令将该服务器标记为备份服务器，当主服务器不可用时，才用备份服务器来传递请求。</p>
<p>它不同于 down 指令，down 指令将服务器永久禁止，而 backp 指令仅仅临时禁止，当主服务器不可用后，临时禁止的服务器就会站出来。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码中 9001 服务器永久禁止，而 9002 服务器是备份服务器，所以 9003 服务器是主服务器。</p>
<p>此时需要将 9003 端口的访问禁止掉，用它来模拟当唯一对外提供访问的服务宕机以后，backup 的备份服务器就能开始对外提供服务。</p>
<p>为了测试验证，我们需要使用防火墙来进行拦截。</p>
<p>介绍一个工具 <code>firewall-cmd</code>，该工具是 Linux 提供的专门用来操作 firewall 防火墙的。</p>
<p>查询防火墙中指定的端口是否开放</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=9001/tcp</span><br></pre></td></tr></table></figure>

<p>开放一个指定的端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9002/tcp</span><br></pre></td></tr></table></figure>

<p>批量添加开发端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9001-9003/tcp</span><br></pre></td></tr></table></figure>

<p>如何移除一个指定的端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=9003/tcp</span><br></pre></td></tr></table></figure>

<p>重新加载</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>--permanent</code> 表示设置为持久</li>
<li><code>--add-port</code> 表示添加指定端口</li>
<li><code>--remove-port</code> 表示移除指定端口</li>
</ul>
<p>经过测试，禁用掉 9003 端口后，再次访问负载均衡器，它只会请求 9002 端口的服务器(备份服务器)，而恢复 9003 端口，只会请求 9003 端口的服务器。</p>
<h4 id="max-conns"><a href="#max-conns" class="headerlink" title="max_conns"></a>max_conns</h4><p><code>max_conns</code> 指令用来限制同时连接到 upstream 负载上的单个服务器的最大连接数。默认为 0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>max_conns=&lt;number&gt;</td>
<td>0</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> max_conns=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 4 行配置标识 9003 端口的服务器最大能被 2 个客户端请求。</p>
<h4 id="max-fails和fail-timeout"><a href="#max-fails和fail-timeout" class="headerlink" title="max_fails和fail_timeout"></a>max_fails和fail_timeout</h4><p><code>max_fails</code> 指令设置允许请求代理服务器失败的次数，默认为 1。</p>
<p><code>fail_timeout</code> 指令设置经过 max_fails 失败后，服务暂停的时间，默认是 10 秒。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>max_fails=&lt;number&gt;</td>
<td>1</td>
<td>upstream</td>
</tr>
<tr>
<td>fail_timeout=&lt;time&gt;</td>
<td>10 秒</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字</li>
<li>time 是时间，单位为秒</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9001</span> down;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9002</span> backup;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.133:9003</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七层负载均衡策略"><a href="#七层负载均衡策略" class="headerlink" title="七层负载均衡策略"></a>七层负载均衡策略</h3><p>介绍完 Nginx 负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法？</p>
<p>Nginx 的 upstream 支持如下六种方式的分配算法，分别是:</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据 IP 分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据 URL 分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
</tr>
</tbody></table>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>这是 <code>upstream</code> 模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="weight加权-加权轮询"><a href="#weight加权-加权轮询" class="headerlink" title="weight加权[加权轮询]"></a>weight加权[加权轮询]</h4><p><code>weight</code> 指令用来设置服务器的权重，默认为 1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>weight=&lt;number&gt;</td>
<td>1</td>
<td>upstream</td>
</tr>
</tbody></table>
<ul>
<li>number 是大于 0 的数字</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> weight=<span class="number">10</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> weight=<span class="number">5</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> weight=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>当对后端的多台动态应用服务器做负载均衡时，<code>ip_hash</code> 指令能够将某个客户端 IP 的请求通过哈希算法定位到同一台后端服务器上。</p>
<p>这样，当来自某一个 IP 的用户在后端 Web 服务器 A 上登录后，在访问该站点的其他 URL，能保证其访问的还是后端 Web 服务器 A</p>
<p>总结：哪个服务器曾经处理过请求，无论在哪里，相同的请求依然让该服务器处理</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ip_hash;</td>
<td>—</td>
<td>upstream</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	ip_hash;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要额外多说一点的是使用 ip_hash 指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.7a0ysgphfxg0.webp" alt="image"></p>
<h4 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h4><p>最少连接数，把请求转发给连接数较少的后端服务器。</p>
<p>轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，<code>least_conn</code> 这种方式就可以达到更好的负载均衡效果。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	least_conn;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.5vug3q9whrc0.webp" alt="image"></p>
<h4 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h4><p>按访问 URL 的 hash 结果来分配请求，使每个 URL 定向到同一个后端服务器，要配合缓存命中来使用。</p>
<p>当出现同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费时，使用 <code>url_hash</code>，可以使得同一个 URL（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p>
<p>总结：发送相同的请求时，希望只有一个服务器处理该请求，使用 <code>uri_hash</code>。因为 URL 相同，则哈希值(hash)相同，那么哈希值对应的服务器也相同。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">hash</span> &amp;request_uri;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图：文件系统有一个文件，目前只有 web 服务 1 和服务 3 获取了该文件，那么我们想要下载这个文件时，只能找服务 1 或服务 3，这时候就固定一个 URL，该 URL 不允许服务 2 进行处理，那么如何规定哪个服务处理呢？就用到 <code>url_hash</code>。</p>
<p>它会根据 URL 计算处哈希值，由哈希值对应服务，所以固定下载文件的 URL，就固定了一个服务处理。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.utb83x535xc.webp" alt="image"></p>
<h4 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h4><p><code>fair</code> 指令采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。</p>
<p>那么如何使用第三方模块的 fair 负载均衡策略？</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nupstream</span> backend&#123;</span><br><span class="line">	fair;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样直接使用会报错，因为 fair 属于第三方模块实现的负载均衡。需要添加 <code>nginx-upstream-fair</code> 模块，如何添加对应的模块：</p>
<ol>
<li>下载 <code>nginx-upstream-fair</code> 模块，下载地址如下：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gnosek/nginx-upstream-fair</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将下载的文件上传到服务器并进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入安装包目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip nginx-upstream-fair-master.zip</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>我的解压目录在 <code>/opt</code>，所以第 6 步记得指定好模块的路径。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx-upstream-fair-master fair</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/nginx/core/nginx-1.21.6</span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>使用 configure 来配置参数，添加模块，记得加上第（4）步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/opt/fair  <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>通过 make 模板进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译可能会出现如下错误，<code>ngx_http_upstream_srv_conf_t</code> 结构中缺少 <code>default_port</code></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.vj3xrayy84g.webp" alt="image"></p>
<p>解决方案：</p>
<p>在 Nginx 的源码目录（安装包目录）中 <code>src/http/ngx_http_upstream.h</code>，找到 <code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加 <code>default_port</code> 属性</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/nginx/core/nginx-1.21.6/src/http/ngx_http_upstream.h</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_port_t	   default_port</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.1mcquncem2u8.webp" alt="image"></p>
<p>然后再进行 make。</p>
<ol start="9">
<li>将安装目录下的 objs 中的 nginx 拷贝到 sbin 目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6/objs</span><br><span class="line">cp nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>10 .更新nginx</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<p>上面介绍了 Nginx 常用的负载均衡的策略，有人说是 5 种，是把轮询和加权轮询归为一种，也有人说是 6 种。那么在咱们以后的开发中到底使用哪种，这个需要根据实际项目的应用场景来决定的。</p>
<h3 id="七层负载均衡案例"><a href="#七层负载均衡案例" class="headerlink" title="七层负载均衡案例"></a>七层负载均衡案例</h3><h4 id="案例一：对所有请求实现一般轮询规则的负载均衡"><a href="#案例一：对所有请求实现一般轮询规则的负载均衡" class="headerlink" title="案例一：对所有请求实现一般轮询规则的负载均衡"></a>案例一：对所有请求实现一般轮询规则的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例二：对所有请求实现加权轮询规则的负载均衡"><a href="#案例二：对所有请求实现加权轮询规则的负载均衡" class="headerlink" title="案例二：对所有请求实现加权轮询规则的负载均衡"></a>案例二：对所有请求实现加权轮询规则的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span> weight=<span class="number">7</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span> weight=<span class="number">3</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理请求概率：9001 端口 &gt; 9003 端口 &gt; 9002 端口</p>
<h4 id="案例三：对特定资源实现负载均衡"><a href="#案例三：对特定资源实现负载均衡" class="headerlink" title="案例三：对特定资源实现负载均衡"></a>案例三：对特定资源实现负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> videobackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> filebackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9004</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8084</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /video/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://videobackend;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /file/ &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://filebackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送 <code>/video/</code> 请求会被 9001 和 9002 端口的服务器处理。</p>
<p>发送 <code>/file/</code> 请求会被 9003 和 9004 端口的服务器处理。</p>
<h4 id="案例四：对不同域名实现负载均衡"><a href="#案例四：对不同域名实现负载均衡" class="headerlink" title="案例四：对不同域名实现负载均衡"></a>案例四：对不同域名实现负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> frxbackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">upstream</span> bingbackend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9004</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">8085</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://frxbackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">8086</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.bing.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://bingbackend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>www.frx.com</code> 地址的请求由 9001 端口和 9002 端口处理。</p>
<p><code>www.bing.com</code> 地址的请求由 9003 端口和 9004 端口处理。</p>
<h4 id="案例五：实现带有URL重写的负载均衡"><a href="#案例五：实现带有URL重写的负载均衡" class="headerlink" title="案例五：实现带有URL重写的负载均衡"></a>案例五：实现带有URL重写的负载均衡</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend&#123;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line">	<span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /file/ &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^(/file/.*)</span> /server/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>/file/xxx</code> 请求重写为 <code>/server/xxx</code>，然后触发 <code>location /server</code>，实现负载均衡。</p>
<p>此时被负载均衡的服务器地址也会带有 <code>/server</code> 以及后面的参数，如 <code>192.168.200.146:9001/server/xxx</code></p>
<h2 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h2><p>Nginx 在 1.9 之后，增加了一个 stream 模块，用来实现四层协议的转发、代理、负载均衡等。stream 模块的用法跟 http 的用法类似，允许我们配置一组 TCP 或者 UDP 等协议的监听，然后通过 proxy_pass 来转发我们的请求，通过 upstream 添加多个后端服务，实现负载均衡。</p>
<p>四层协议负载均衡的实现，一般都会用到 LVS、HAProxy、F5 等，要么很贵要么配置很麻烦，而 Nginx 的配置相对来说更简单，更能快速完成工作。</p>
<h3 id="添加stream模块的支持"><a href="#添加stream模块的支持" class="headerlink" title="添加stream模块的支持"></a>添加stream模块的支持</h3><p>Nginx 默认是没有编译这个模块的，需要使用到 stream 模块，那么需要在编译的时候加上 <code>--with-stream</code>。</p>
<p>完成添加 <code>--with-stream</code> 的实现步骤：</p>
<ul>
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
<li>拷贝 <code>Nginx -V</code> 的 configure arguments 配置信息</li>
<li>在 Nginx 的安装源码进行配置指定对应模块：<code>./configure --with-stream 加上一步拷贝的configure arguments 配置</code></li>
<li>通过 make 模板进行编译</li>
<li>将 objs 下面的 nginx 移动到 <code>/usr/local/nginx/sbin</code> 下</li>
<li>在源码目录下执行 <code>make upgrade</code> 进行升级，这个可以实现不停机添加新模块的功能</li>
</ul>
<p>添加模块的详细步骤我已经在 <a href>七层负载均衡策略-fair 指令</a>、<a href>静态资源部署-Nginx 模块添加</a>、<a href>反向代理-添加ssl支持</a> 描述过，而你只需要替换模块名字罢了。</p>
<h3 id="四层负载均衡指令"><a href="#四层负载均衡指令" class="headerlink" title="四层负载均衡指令"></a>四层负载均衡指令</h3><p>如果不想在 http 模块使用负载均衡，可以在 steam 模块使用。</p>
<h4 id="stream指令"><a href="#stream指令" class="headerlink" title="stream指令"></a>stream指令</h4><p>该指令提供在其中指定流服务器指令的配置文件上下文。和 http 模块同级。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>stream { … }</td>
<td>—</td>
<td>main</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> backend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="upstream指令-1"><a href="#upstream指令-1" class="headerlink" title="upstream指令"></a>upstream指令</h4><p>该指令和七层负载均衡的 upstream 指令是类似的。</p>
<h3 id="四层负载均衡的案例"><a href="#四层负载均衡的案例" class="headerlink" title="四层负载均衡的案例"></a>四层负载均衡的案例</h3><p>准备两台服务器，这里称为 A 和 B。服务器 A 的 IP 为 <code>192.168.200.146</code>，服务器 B 的IP 为 <code>192.168.200.133</code>，服务器 A 存放 Redis 和 Tomcat，服务器 B 作为负载均衡器，对服务器 A 的端口进行负载均衡处理。</p>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.6yak0csdt880.webp" alt="image"></p>
<h4 id="Redis-配置"><a href="#Redis-配置" class="headerlink" title="Redis 配置"></a>Redis 配置</h4><p>准备 Redis 服务器,在服务器 A 上准备两个 Redis，端口分别是 6379、6378。</p>
<ol>
<li>上传 redis 的安装包 <code>redis-4.0.14.tar.gz</code>，这里上传目录是 <code>/opt</code></li>
<li>将安装包进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-4.0.14.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入redis的安装包</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-4.0.14</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 make 和 install 进行编译和安装，这里的安装路径是 <code>/usr/local/redis/redis01</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis/redis01 install</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>拷贝 redis 配置文件 <code>redis.conf</code> 到 <code>/usr/local/redis/redis01/bin</code> 目录中，因为安装后，目录并没有 redis.conf</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-4.0.14/redis.conf	/usr/<span class="built_in">local</span>/redis/redis01/bin</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改 redis.conf 配置文件，注意：不是添加内容，是修改内容，要自己搜索 bind、port 和 daemonize 进行修改</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0   <span class="comment"># 允许任意地址访问</span></span><br><span class="line">port  6379      <span class="comment"># redis 的端口</span></span><br><span class="line">daemonize yes   <span class="comment"># 后台启动 redis</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 redis01 复制一份为 redis02</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis</span><br><span class="line">cp -r redis01 redis02</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>将 redis02 文件夹中的 redis.conf 进行修改，注意：不是添加内容，是修改内容，要自己搜索 bind、port 和 daemonize 进行修改</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 0.0.0.0   <span class="comment"># 允许任意地址访问</span></span><br><span class="line">port  6378      <span class="comment"># redis 的端口</span></span><br><span class="line">daemonize yes   <span class="comment"># 后台启动 redis</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>分别启动，即可获取两个 Redis 并查看</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p>使用 Nginx 将请求分发到不同的 Redis 服务器上。</p>
<p>安装 Redis 并验证能启动成功后，在另一台服务器 B <code>192.168.200.133</code> 的 Nginx 配置文件添加如下内容：（确保安装了 steam 模块）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> redisbackend&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;   <span class="comment"># 服务器 B 的 6379 端口</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;   <span class="comment"># 服务器 B 的 6378 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> redisbackend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时利用 redis-cli 连接测试</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.cbee2u83yhs.webp" alt="image"></p>
<p>服务器 B 通过负载均衡连接到了服务器 A 的 Redis，只是不知道连接的是 6378 还是 6379 端口，可以在 Redis 添加不一样的数据来测试，这里不演示了。</p>
<h4 id="Tomcat-配置"><a href="#Tomcat-配置" class="headerlink" title="Tomcat 配置"></a>Tomcat 配置</h4><p>准备 Tomcat 服务器 到服务器 A</p>
<ol>
<li>上传 tomcat 的安装包，<code>apache-tomcat-8.5.56.tar.gz</code></li>
<li>将安装包进行解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf apache-tomcat-8.5.56.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 tomcat 的 bin 目录，启动 tomcat</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> apache-tomcat-8.5.56/bin</span><br><span class="line">./startup</span><br></pre></td></tr></table></figure>

<p>服务器 B 的配置文件 nginx.conf 配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">upstream</span> redisbackend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6379</span>;    <span class="comment"># 服务器 B 的 6379 端口</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:6378</span>;    <span class="comment"># 服务器 B 的 6378 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> tomcatbackend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.200.146:8080</span>;   <span class="comment"># 服务器 B 的 8080 端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">81</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> redisbackend; <span class="comment"># redis 的负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>	<span class="number">82</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> tomcatbackend;  <span class="comment"># tomcat 的负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问服务器 B 的地址进行测试：<code>192.168.200.133:82</code>。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/12/Nginx_Reverse_proxy/">Nginx 反向代理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p><strong>引言</strong></p>
<p>Nginx 如何变成一个代理服务器？Nginx 又如何将客户端的请求转发给其他的服务器？本内容将学习 Nginx 的反向代理知识。</p>
<hr>
<h2 id="反向代理概述"><a href="#反向代理概述" class="headerlink" title="反向代理概述"></a>反向代理概述</h2><p>关于正向代理和反向代理，在 <a href="/pages/9551ee/#名词解释">Nginx - 介绍</a> 已经通过一张图详细的介绍过了，简而言之就是正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</p>
<p>Nginx 即可以实现正向代理，也可以实现反向代理。</p>
<p>我们先来通过一个小案例演示下 Nginx 正向代理的简单应用。</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>先提需求：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.53oygoz19gc0.webp" alt="image"></p>
<ol>
<li>服务端的设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">'client send request=&gt;clientIp=<span class="variable">$remote_addr</span> serverIp=<span class="variable">$host</span>'</span>;</span><br><span class="line">	server&#123;</span><br><span class="line">		<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">		<span class="attribute">server_name</span>	localhost;</span><br><span class="line">		<span class="attribute">access_log</span> logs/access.log main;</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">			<span class="attribute">root</span> html;</span><br><span class="line">			<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用客户端访问服务端：<code>http://192.168.200.133</code>，打开日志查看结果</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.16ifxal7swyk.webp" alt="image"></p>
<ol start="3">
<li>代理服务器设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">82</span>;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;   <span class="comment"># 设置 DNS 的 IP，用来解析 proxy_pass 中的域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://<span class="variable">$host</span><span class="variable">$request_uri</span>;   <span class="comment"># proxy_pass 实现正向代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proxy_pass</code> 后面有讲解。</p>
<ol start="4">
<li>客户端配置代理服务器的 IP(192.168.200.146)和 Nginx 配置监听的端口(82)</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yx93qbazra0.webp" alt="image"></p>
<ol start="5">
<li>设置完成后，再次通过浏览器访问服务端</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6litsat09000.webp" alt="image"></p>
<p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是使用了代理，那么服务端能看到的只是代理发送过去的请求，这样就使用 Nginx 实现了正向代理的设置。</p>
<p>但是 Nginx 正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习 Nginx 的反向代理，这是 Nginx 比较重要的一个功能。</p>
<h2 id="反向代理语法配置"><a href="#反向代理语法配置" class="headerlink" title="反向代理语法配置"></a>反向代理语法配置</h2><p>Nginx 反向代理模块的指令是由 <code>ngx_http_proxy_module</code> 模块进行解析，该模块在安装 Nginx 的时候已经自动加载到 Nginx 中了，接下来我们把反向代理中的常用指令一一介绍下：</p>
<ul>
<li>proxy_pass：配置代理的服务器地址</li>
<li>proxy_set_header：转发给被代理服务器时，设置一些请求头信息</li>
<li>proxy_redirect：防止客户端可以看到被代理服务器的地址</li>
</ul>
<p>这里只介绍三个指令，关于反向代理的指令非常多，想要了解更多，请前往 <a href="https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html" target="_blank" rel="noopener">Nginx 反向代理文档</a></p>
<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>该指令用来设置被代理服务器地址，可以是主机名称、IP 地址加端口号形式，没有默认值。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_pass &lt;URL&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<p><code>URL</code>：为要设置的被代理服务器地址，包含传输协议(<code>http</code>、<code>https://</code>)、主机名称或 IP 地址加端口号、URI 等要素。</p>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="attribute">location</span> /server &#123;</span><br><span class="line">    <span class="comment"># 结尾不加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/server/index.html</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结尾加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>准备两台服务器或者按照 Linux 系统的虚拟机，这里是 <code>192.168.200.133</code> 和 <code>192.168.200.146</code>，为了方便，我们称前者为服务器 A，后者为服务器 B。</p>
<ol>
<li>在服务器 A 的 Nginx 配置文件添加如下内容：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端请求服务器 A <code>http://192.168.200.133</code>，它会转发给服务器 B，此时的服务器 A 就是一个代理的角色。</p>
<p>访问服务器 A，我们看到 Nginx 的欢迎界面其实是服务器 B 的 Nginx，可以在服务器 B 的 Nginx 欢迎页面添加新的内容：<code>I am 146</code>，再次访问服务器 A，效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4ai1u3uxs940.webp" alt="image"></p>
<p>总结来说：</p>
<ul>
<li>正向代理相当于在客户端浏览器里直接访问目标域名，但是背地里请求会从配置好的代理服务器发出去，对服务端来说它只知道代理服务器请求了提出了这次请求。</li>
<li>反向代理时相当于在客户端浏览器里直接访问代理服务器，然后代理服务器根据内部配置好的规则选择相应的服务返回给客户端，此时客户端并不清楚毒品的源头是谁，只知道它是从proxy那拿了货。</li>
</ul>
<p><strong>在编写 proxy_pass 的时候，后面的值要不要加 /?</strong></p>
<p>这是看情况的。</p>
<p>接下来通过例子来说明提到的问题：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址加不加斜杠，效果都一样，因为 location 后的 / 会添加在代理地址后面</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址必须加斜杠，因为 location 后的 /server 会添加在代理地址后面，第一个将没有 / 结尾</span></span><br><span class="line">		<span class="comment">#proxy_pass http://192.168.200.146;</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面的 location：当客户端访问 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第一个 proxy_pass 就变成了 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第二个 proxy_pass 就变成了 http://localhost/index.html 效果就不一样了。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个 location（第 4 行代码）：当客户端访问 <code>http://localhost/index.html</code>，两个 <code>proxy_pass</code> 效果是一样的，因为 location 后的 <code>/</code> 会添加在代理地址后面，所以有没有 <code>/</code>，效果都一样。</p>
</li>
<li><p>第一个 location（第 14 行代码）：当客户端访问 <code>http://localhost/server/index.html</code>，这个时候，第一个 proxy_pass 就变成了 <code>http://192.168.200.146/server/index.html</code>，第二个 proxy_pass 就变成了 <code>http://192.168.200.146/index.html</code> 效果就不一样了</p>
<p>如果不以 <code>/</code> 结尾，则 location 后的 <code>/server</code> 会添加在地址后面，所以第一个 proxy_pass 因为没有 <code>/</code> 结尾而被加上 <code>/server</code>，而第二个自带了 <code>/</code> ，所以不会添加 <code>/server</code>。</p>
</li>
</ul>
<p>上面的例子仅仅针对：访问任意请求如 <code>/server</code> 时，想要代理到其他服务器的首页，则加 <code>/</code>，否则你如果真的想访问 <code>/server</code> 下的资源，那么不要加 <code>/</code>。</p>
<p>所以加了 <code>/</code> 后，请求的是服务器根目录下的资源。</p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><p>该指令可以更改 Nginx 服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器。默认值是发送代理服务器的地址和 close。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4bt7qzhbz1i0.webp" alt="image"></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_set_header &lt;field&gt; &lt;value&gt;;</td>
<td>proxy_set_header Host $proxy_host; proxy_set_header Connection close;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p>
<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>被代理服务器：服务器 B <code>192.168.200.146</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$http_username</span>;    <span class="comment"># 获取代理服务器发送过来的 http 请求头的 username 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务器: 服务器 A <code>192.168.200.133</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;           <span class="comment"># 访问 /server 触发代理</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:8080/;  <span class="comment"># 配置服务器 B 的地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> username TOM;  <span class="comment"># 发送 key 为 username，value 为 TOM 的请求头给服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.398ksbw6rv20.webp" alt="image"></p>
<p>客户端访问的是服务器 A，服务器 A 会将请求转发给服务器 B，服务器 B 返回打印 TOM 的页面给服务器 A，服务器 A 最后返回给客户端。</p>
<h3 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h3><p>该指令是用来重置头信息中的『 Location 』和『 Refresh 』的值，防止客户端可以看到被代理服务器的地址。</p>
<p>因为客户端看到的返回结果是『 Location 』和『 Refresh 』的值，所以在到达代理服务器的时，将两个值修改掉，防止客户端直接看到被代理服务器的地址。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_redirect redirect replacement;<br> proxy_redirect default; <br>proxy_redirect off;</td>
<td>proxy_redirect default;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>为什么要用该指令？</strong></p>
</blockquote>
<p>首先说明一下思路：客户端通过代理服务器 A 访问服务器 B 的资源，但是服务器 B 不存在该资源，则会报错。此时我们不希望它直接返回报错页面给客户端，我们希望服务器 B 返回的是它的欢迎页面。那么如何做呢？</p>
<ul>
<li>首先在服务器 B 进行判断是否存在资源，不存在则返回自己的欢迎页面，即重定向到自己的欢迎页面地址并返回，此时浏览器的地址将会发生改变</li>
<li>代理服务器 A 收到服务器 B 的欢迎页面和地址，但是我们不能直接返回给客户端，因为它会暴露服务器 B 的地址，这是重定向的原因</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.a4tptcx6lbk.webp" alt="image"></p>
<ul>
<li>此时用到 <code>proxy_redirect</code> 指令，重置服务器 B 返回过来的『 Location 』和『 Refresh 』值，将两个值改为代理服务器 A 的某个地址</li>
<li>因为改为了代理服务器 A 的某个地址，所以代理服务器 A 根据这个地址又去获取理服务器 B 的欢迎页面地址，返回给客户端</li>
</ul>
<p>很绕，简单总结下：客户端通过 A 找 B 不存在的资源，B 不想返回报错页面，于是重定向到自己的欢迎页面地址并返回给 A，A 收到了页面和地址（正常情况不要接收地址，只接收页面），发现不能暴露 B 的地址，于是修改接收的 B 的地址为自己的某一个地址，这个地址会重新发送请求去获取 B 的欢迎页面地址，然后返回给客户端。</p>
<p>这里要明白 B 返回的是重定向后的欢迎页面，重定向后，浏览器地址栏会变成重定向的地址，所以 A 才会以自己的地址转发获取到 B 的地址，所以最后浏览器显示 A 的地址，看到的却是 B 的欢迎页面。</p>
<p>代码：</p>
<p>服务端 B <code>192.168.200.146</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">302</span> http://192.168.200.146;   <span class="comment">#  2.如果请求的资源不存在，则重定向到服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务端 A <code>192.168.200.133</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;  <span class="comment"># 1.转发给服务器 B</span></span><br><span class="line">		<span class="attribute">proxy_redirect</span> http://192.168.200.146 http://192.168.200.133; <span class="comment"># 3.修改服务器 B 的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 该 server 去请求服务器 B 的欢迎页面</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">192.168.200.133</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;  <span class="comment"># 4.重新发送请求给服务器 B，获取欢迎页面</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行代码，当服务器 B 返回的是 <code>http://192.168.200.146</code>，为了不让它出现在浏览器的地址栏上，我们需要利用 <code>proxy_redirect</code> 将它修改为代理服务器 A 的地址，这个地址会以自己的地址重新访问服务器 B 的欢迎页面，最后返回给客户端。</p>
<p><strong>该指令的三组选项</strong></p>
<ul>
<li><p><code>proxy_redirect redirect replacement;</code></p>
<ul>
<li>redirect：被代理服务器返回的 Location 值</li>
<li>replacement：要替换 Location 的值</li>
</ul>
</li>
<li><p><code>proxy_redirect default;</code></p>
<ul>
<li><p>default：相比较第一组选项，default 仅仅提供了 <code>redirect</code> 和 <code>replacement</code> 的默认值</p>
<p>将本范围 location 块的 uri 变量作为 replacement。</p>
<p>将 proxy_pass 变量作为 redwadairect</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123; </span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;</span><br><span class="line">		<span class="attribute">proxy_redirect</span> default;  <span class="comment"># redirect 是 proxy_pass 的值：http://192.168.200.146:8081/</span></span><br><span class="line">        						 <span class="comment"># replacement 是 location 后的值：/server</span></span><br><span class="line">        <span class="comment"># 等价于：proxy_redirect http://192.168.200.146:8081/ /server</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>proxy_redirect off;</code></p>
<p>关闭 proxy_redirect 的功能</p>
</li>
</ul>
<h2 id="反向代理实战"><a href="#反向代理实战" class="headerlink" title="反向代理实战"></a>反向代理实战</h2><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.59ecpsonzxc0.webp" alt="image"></p>
<p>服务器 1，2，3 存在两种情况</p>
<ul>
<li>第一种情况: 三台服务器的内容不一样</li>
<li>第二种情况: 三台服务器的内容是一样</li>
</ul>
<p>第一种情况</p>
<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容不一样，那我们可以根据用户请求来分发到不同的服务器。</p>
<p>服务器有限，只能以三个端口模拟三台服务器，实际上是一个 IP 对应一个服务器。</p>
<p>代理服务器配置文件内容：</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代理服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8082</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost; </span><br><span class="line">    <span class="attribute">location</span> /server1 &#123;    </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9001/;   <span class="comment"># 代理 server1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server2 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9002/;   <span class="comment"># 代理 server2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server3 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9003/;   <span class="comment"># 代理 server3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="comment"># server1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server2</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9002</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server3</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9003</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容是一样的，该如何处理?</p>
<p>请看负载均衡的相关内容，里面将进行详细的介绍。</p>
</li>
</ul>
<h2 id="斜杠总结"><a href="#斜杠总结" class="headerlink" title="斜杠总结"></a>斜杠总结</h2><p>这里将发送 <code>http://192.168.199.27/frx/xu</code> 请求。</p>
<p><strong>不带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>/xu</td>
</tr>
</tbody></table>
<p>若 Nginx 会将原请求路径原封不动地转交给其他地址，如案例 3 和 4。</p>
<p><code>proxy_pass</code> 的 ip:port 后加了 <code>/</code>，代表去除掉请求和 location 的匹配的字符串，不加则追加全部请求到地址后面。</p>
<p><strong>带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bing/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bingxu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing/xu</td>
</tr>
</tbody></table>
<p><code>proxy_pass</code> 的 ip:port 后加了字符串，Nginx 会将匹配 location 的请求从「原请求路径」中剔除，再不匹配的字符串拼接到 proxy_pass 后生成「新请求路径」，然后将「新请求路径」转交给其他地址。</p>
<p>案例 2 中，<code>proxy_pass</code> 的 ip:port 后接了字符串，因此将 location 的 <code>/frx/</code> 从原请求路径 <code>/frx/xu</code> 中剔除，变为 <code>xu</code>，然后将 <code>xu</code> 拼接到 <code>http://192.168.1.48/bing</code> 后生成了新请求，因此其他地址收到的请求就是 <code>/bingxu</code>。</p>
<h2 id="Nginx安全控制"><a href="#Nginx安全控制" class="headerlink" title="Nginx安全控制"></a>Nginx安全控制</h2><p>关于 Web 服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx 反向代理是如何来提升 Web 服务器的安全呢？</p>
<p>答案是：安全隔离。</p>
<h3 id="什么是安全隔离"><a href="#什么是安全隔离" class="headerlink" title="什么是安全隔离"></a>什么是安全隔离</h3><p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3vhdv63nf9q0.webp" alt="image"></p>
<h3 id="如何使用SSL对流量加密"><a href="#如何使用SSL对流量加密" class="headerlink" title="如何使用SSL对流量加密"></a>如何使用SSL对流量加密</h3><p>翻译成大家能熟悉的说法就是将我们常用的 http 请求转变成 https 请求，那么这两个之间的区别简单的来说两个都是 HTTP 协议，只不过 https 是身披 SSL 外壳的 http.</p>
<p>HTTPS 是一种通过计算机网络进行安全通信的传输协议。它经由 HTTP 进行通信，利用 SSL/TLS 建立全通信，加密数据包，确保数据的安全性。</p>
<ul>
<li>SSL(Secure Sockets Layer)安全套接层</li>
<li>TLS(Transport Layer Security)传输层安全</li>
</ul>
<p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS 和 SSL 在传输层和应用层对网络连接进行加密。</p>
<p>总结来说为什么要使用 https:</p>
<ul>
<li>http 协议是明文传输数据，存在安全问题，而 https 是加密传输，相当于 http + SSL，并且可以防止流量劫持。</li>
</ul>
<p>Nginx 默认不支持 https 开头的协议，如果要想使用 SSL，需要满足一个条件即需要添加一个模块 <code>--with-http_ssl_module</code>，而该模块在编译的过程中又需要 OpenSSL 的支持，OpenSSL 我们在 <a href="/middleware/Nginx/Nginx_install/#nginx环境安装">Nginx 安装</a> 已经准备好了。</p>
<h3 id="添加SSL支持"><a href="#添加SSL支持" class="headerlink" title="添加SSL支持"></a>添加SSL支持</h3><p>完成 <code>--with-http_ssl_module</code> 模块的增量添加。</p>
<ol>
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /root/nginx/core/nginx-<span class="number">1</span>.<span class="number">20</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 configure 来配置参数，添加 <code>ngx_http_ssl_module</code> 模块，记得加上第（2）步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_ssl_module <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 make 模板进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 objs 下面的 nginx 可执行文件移动到 <code>/usr/local/nginx/sbin</code> 下</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.20.2/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在源码目录（安装包目录）下执行 <code>make upgrade</code> 进行升级，这个可以实现不停机添加新模块的功能</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.20.2</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="SSL相关指令"><a href="#SSL相关指令" class="headerlink" title="SSL相关指令"></a>SSL相关指令</h3><p>该模块的指令都是通过 <code>ngx_http_ssl_module</code> 模块来解析的，我们上一步已经添加了。</p>
<p>这里只介绍常用的几个指令，了解更多指令请前往 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html" target="_blank" rel="noopener">ngx_http_ssl_module 模块文档</a>。</p>
<p><code>ssl</code> 指令用来在指定的服务器开启 HTTPS，默认关闭。可以使用 listen 443 ssl，这种方式更通用些。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl &lt;on |off&gt;;</td>
<td>ssl off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>ssl 默认监听的是 443 端口，所以使用下面的指令和 <code>ssl on</code> 效果一致，因为下面的指令能突出 sll 的监听端口，所以建议使用它。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ssl_certificate</code> 指令是为当前这个虚拟主机指定一个带有 PEM 格式证书的证书。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_certificate &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_certificate_key</code> 指令用来指定 PEM secret key 文件的路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ceritificate_key &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_session_cache</code> 指令用来配置用于 SSL 会话的缓存</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_sesion_cache &lt;off | none | [builtin[:size]] [shared:name:size]&gt;</td>
<td>ssl_session_cache none;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>选项介绍：</p>
<ul>
<li><p><code>off</code>：严格禁止使用会话缓存：Nginx 明确告诉客户端会话不能被重用</p>
</li>
<li><p><code>none</code>：禁止使用会话缓存，Nginx 告诉客户端会话可以被重用，但实际上并不在缓存中存储会话参数（任性，言语同意用，行为取消用）</p>
</li>
<li><p><code>builtin</code>：内置 OpenSSL 缓存，仅在一个工作进程中使用。缓存大小在会话中指定。如果未给出大小，则等于 20480 个会话。使用内置缓存可能会导致内存碎片</p>
</li>
<li><p><code>shared</code>：所有工作进程之间共享缓存，缓存的相关信息用 name 和 size 来指定，同 name 的缓存可用于多个虚拟服务器</p>
<p>name 是允许缓存的数据名，size 是允许缓存的数据大小，以字节为单位</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_cache</span> builtin:<span class="number">1000</span> shared:SSL:<span class="number">10m</span>;</span><br></pre></td></tr></table></figure>

<p>10m 的 m 是兆。</p>
<p><code>ssl_session_timeout</code> 指令用于开启 SSL 会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间，默认值超时时间是 5 秒</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_session_timeout &lt;time&gt;;</td>
<td>ssl_session_timeout 5m;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_ciphers</code> 指令指出允许的密码，密码指定为 OpenSSL 支持的格式</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ciphers &lt;ciphers&gt;;</td>
<td>ssl_ciphers HIGH:!aNULL:!MD5;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>可以直接在 Linux 系统上使用 <code>openssl ciphers</code> 查看 OpenSSl 支持的格式</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ciphers</span><br></pre></td></tr></table></figure>

<p><code>ssl_prefer_server_ciphers</code> 指令指定是否服务器密码优先客户端密码，默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_perfer_server_ciphers &lt;on | off&gt;;</td>
<td>ssl_perfer_server_ciphers off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<h3 id="SSL证书生成"><a href="#SSL证书生成" class="headerlink" title="SSL证书生成"></a>SSL证书生成</h3><p><strong>方式一：使用阿里云/腾讯云等第三方服务进行购买免费版</strong></p>
<p>需要购买域名进行证书的绑定，否则证书无法使用。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5p2qyl61ozc0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5l7iqyudol00.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6ci6w9wu24g0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4k9v2b9n6tm0.webp" alt="image"></p>
<p>接着在右边弹窗进行域名绑定，填完写域名和个人信息，进入到验证信息</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.11wx9z7jit3k.webp" alt="image"></p>
<p>点击验证，不成功则去自己的域名解析列表查看，如下，点击添加记录，进行配置，或者已经看到记录类型是 TXT，记录值和上图一样的，则说明成功。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6qcpqete8ic0.webp" alt="image"></p>
<p>提交审核后，点击下载</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.28m5753glfy8.webp" alt="image"></p>
<p>下载 Nginx 服务器的证书</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6kmq7nhonys0.webp" alt="image"></p>
<p>下载压缩包进行加压后，得到 .pem 证书和 .key 证书，把两个证书上传到 Linux，进行配置，往下看。</p>
<p><strong>方式二：使用 OpenSSL 生成证书</strong></p>
<p>这个方式适用于学习阶段，实际开发阶段使用方式一</p>
<ol>
<li>先要确认当前系统是否有安装 OpenSSL</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>

<p>安装下面的命令进行生成（一步一步来）</p>
<ol start="2">
<li>创建 <code>/root/cerr</code> 目录并进入</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/cert</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/cert</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定加密算法和加密方式，生成 <code>server.key</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># genrsa 是加密算法，des3 是加密方式，-out 代表输入长度为 2048 的 server.key</span></span><br><span class="line">openssl genrsa -des3 -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后它会让你注册 server.key 的密码</span></span><br><span class="line"><span class="comment"># 输入密码 ......</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>根据你注册的 server.key 密码，生成 server.csr 文件，生成后它会让你注册你的基本信息，因为是个人的，所以信息随便填写</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里注册你的基本信息，信息随便填写</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.2b4bgtawqb4.webp" alt="image"></p>
<ol start="5">
<li>备份 server.key</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp server.key server.key.org</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>重新生成 server.key 文件，并输入刚才注册的密码</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> server.key.org -out server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会让你重新输入注册密码</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>生成 server.crt 文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最后使用 <code>ll</code> 查看目录下是否生成相应的文件：</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yl8ne2bkre0.webp" alt="image"></p>
<h3 id="SSL实例模板-通用"><a href="#SSL实例模板-通用" class="headerlink" title="SSL实例模板(通用)"></a>SSL实例模板(通用)</h3><p>Nginx 的置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;		<span class="comment"># 开启 SSL 功能</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;     <span class="comment"># 如果是购买的域名，这里加上该域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /root/cert/server.cert; <span class="comment"># 生成的 cert 或者 pem 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /root/cert/server.key; <span class="comment"># 生成的 key 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>; </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; <span class="comment"># 表示使用的加密套件的类型</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;  <span class="comment"># 表示使用的TLS协议的类型</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个模板就是 Nginx 解压目录的 conf 目录下的 nginx.conf 内容。</p>
<p><strong>建议</strong></p>
<p>配置 SSL 证书时候，不要修改原来的 server 模块（<code>listen 80</code> 模块），应该新建一个 server 模块。</p>
<p><strong>解决默认 http 问题。</strong></p>
<p>配置完 SSL 证书还远远不安全。如果直接输入 <code>www.frx.com</code>，会默认加上『 http:// 』 而不是『 https:// 』，如何修改为『 https:// 』呢，我们利用 Rewrite 功能</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.frx.com;   <span class="comment"># 如果是 www.frx.com 发送请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.frx.com<span class="variable">$1</span>;  <span class="comment"># 则改为 https 方式</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理系统调优"><a href="#反向代理系统调优" class="headerlink" title="反向代理系统调优"></a>反向代理系统调优</h2><p>反向代理值 Buffer 和 Cache。</p>
<p>Buffer 翻译过来是「缓冲」，Cache 翻译过来是「缓存」。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6p7uoj5ab0k0.webp" alt="image"></p>
<p>客户端通过代理服务器向被代理服务器获取数据后，代理服务器在获取的数据存储在缓存「瓶子」里，客户端再次获取相同资源时，直接从缓存「瓶子」里获取数据，不需要向被代理服务器获取数据，减轻压力。</p>
<p>相同点:</p>
<ul>
<li>两种方式都是用来提供 IO 吞吐效率，都是用来提升 Nginx 代理的性能。</li>
</ul>
<p>不同点:</p>
<ul>
<li>缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除</li>
<li>缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除</li>
</ul>
<h3 id="Proxy-Buffer-相关指令"><a href="#Proxy-Buffer-相关指令" class="headerlink" title="Proxy Buffer 相关指令"></a>Proxy Buffer 相关指令</h3><ul>
<li><p><code>proxy_buffering</code> 指令用来开启或者关闭代理服务器的缓冲区，默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffering &lt;on | off&gt;;</td>
<td>proxy_buffering on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_buffers</code> 指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>number：缓冲区的个数</li>
<li>size：每个缓冲区的大小，缓冲区的总大小就是 number * size</li>
</ul>
</li>
<li><p><code>proxy_buffer_size</code> 指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与 proxy_buffers 中的 size 一致即可，当然也可以更小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffer_size &lt;size&gt;;</td>
<td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_busy_buffers_size</code> 指令用来限制同时处于 BUSY 状态的缓冲总大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_busy_buffers_size &lt;size&gt;;</td>
<td>proxy_busy_buffers_size 8k | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_temp_path</code> 指令用于当缓冲区存满后，仍未被 Nginx 服务器完全接受，响应数据就会被临时存放在磁盘文件上的该指令设置的文件路径下</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_path &lt;path&gt;;</td>
<td>proxy_temp_path proxy_temp;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>注意 path 最多设置三层。</p>
</li>
<li><p><code>proxy_temp_file_write_size</code> 指令用来设置磁盘上缓冲文件的大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_file_write_size &lt;size&gt;;</td>
<td>proxy_temp_file_write_size 8K | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="网站调优模板-通用"><a href="#网站调优模板-通用" class="headerlink" title="网站调优模板(通用)"></a>网站调优模板(通用)</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_temp_file_write_size</span> <span class="number">128k</span>;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理问题"><a href="#反向代理问题" class="headerlink" title="反向代理问题"></a>反向代理问题</h2><p>反向代理有一个严重的问题，那就是反向代理的网站需要的 css、js、png 等静态文件默认是从 Nginx 里获取，显然一个你的服务器的代理了如淘宝、京东等网站，那么淘宝、京东等网站的静态文件是从你的服务器里获取，但是服务器根本没有，那么我们如何让代理的网站以及网站需要的 css、js、png 等静态文件一同获取呢，添加如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*</span> &#123;							<span class="comment"># 如果不是代理网站的根路径，请自行修改</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8081;   <span class="comment"># 代理的网站地址</span></span><br><span class="line">        <span class="comment"># 将网站的静态文件也代理过来</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/46/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/75/">75</a><a class="extend next" rel="next" href="/page/48/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>