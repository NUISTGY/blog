<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">227</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/10/Nginx_Static_resource_deployment/">Nginx 静态资源部署</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-静态资源部署"><a href="#Nginx-静态资源部署" class="headerlink" title="Nginx 静态资源部署"></a>Nginx 静态资源部署</h1><p><strong>引言</strong></p>
<p>静态资源如何部署？本内容带你了解静态资源相关的操作和内容。</p>
<p>静态资源指令配置、静态资源优化配置、静态资源压缩配置、静态资源缓存配置。</p>
<h2 id="Nginx静态资源概述"><a href="#Nginx静态资源概述" class="headerlink" title="Nginx静态资源概述"></a>Nginx静态资源概述</h2><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个 HTTP 请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。</p>
<p>静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的 html 页面、css 文件、js 文件、图片、视频等资源；</p>
<p>动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p>
<p>Nginx 处理静态资源的内容，我们需要考虑下面这几个问题：</p>
<ul>
<li>静态资源的配置指令</li>
<li>静态资源的配置优化</li>
<li>静态资源的压缩配置指令</li>
<li>静态资源的缓存处理</li>
<li>静态资源的访问控制，包括跨域问题和防盗链问题</li>
</ul>
<h2 id="静态资源指令配置"><a href="#静态资源指令配置" class="headerlink" title="静态资源指令配置"></a>静态资源指令配置</h2><h3 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h3><p>该指令是用来配置监听端口。默认监听 80（root 启动 Nginx） 和 8000（非 root 启动 Nginx） 端口。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>listen &lt;address&gt;[:port] [default_server] …… ;<br> listen &lt;port&gt; [default_server] …… ;</td>
<td>listen *:80 | *:8000</td>
<td>server</td>
</tr>
</tbody></table>
<p><code>listen</code> 指令的设置比较灵活，我们通过几个例子来把常用的设置方式熟悉下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen 127.0.0.1:8000; <span class="comment"># listen localhost:8000 监听指定的IP和端口</span></span><br><span class="line">listen 127.0.0.1;	<span class="comment"># 监听指定IP的所有端口</span></span><br><span class="line">listen 8000;	<span class="comment"># 监听指定端口上的连接</span></span><br><span class="line">listen *:8000;	<span class="comment"># 监听指定端口上的连接</span></span><br></pre></td></tr></table></figure>

<p><code>default_server</code> 属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的 <code>address:port</code>，则会执行默认的 server。如果不指定该标识符，又没有匹配到对应的 <code>address:port</code> 时，默认使用的是第一个 server，所以第一个 server 要好好设置，建议第一个 server 就加上 <code>default_server</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'This is a error request'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问 8080 端口，它会访问第二个 server，如果第二个 server 去掉 <code>default_server</code> ，则默认访问第一个 server。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.2e5c4uo1ghlw.webp" alt="image"></p>
<h3 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h3><p>该指令用来设置虚拟主机服务名称。默认为空。</p>
<p>比如 127.0.0.1、localhost、域名[<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> | <a href="http://www.jd.com]。" target="_blank" rel="noopener">www.jd.com]。</a></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>server_name &lt;name&gt; …… ;</td>
<td>server_name “”;</td>
<td>server</td>
</tr>
</tbody></table>
<ul>
<li>name 可以提供多个中间用空格分隔。</li>
</ul>
<p>关于 server_name 的配置方式有三种，分别是：</p>
<ul>
<li>精确匹配</li>
<li>通配符匹配</li>
<li>正则表达式匹配</li>
</ul>
<blockquote>
<p><strong>配置方式一：精确匹配</strong></p>
</blockquote>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com www.bing.com;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时以 <code>www.frx.com</code> 或者 <code>www.bing.com</code> 域名进行访问，就会跳转到 Nginx 的欢迎页面，前提是你需要拥有该域名，并且该域名和 Nginx 所在的系统 IP 进行绑定。</p>
<p>所以我可以利用 hosts 文件进行「模拟」域名。</p>
<blockquote>
<p>补充小知识点</p>
</blockquote>
<p>hosts 是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联「数据库」，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 hosts 文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。</p>
<p>hosts 文件不同系统的位置：</p>
<ul>
<li>在 windows 的位置：C:\Windows\System32\drivers\etc</li>
<li>在 centos 的位置：/etc/hosts</li>
</ul>
<p>因为域名是要收取一定的费用，所以我们可以使用修改 hosts 文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code> 文件来添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 hosts 文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加内容</span></span><br><span class="line">127.0.0.1 www.frx.com</span><br><span class="line">127.0.0.1 www.bing.com</span><br></pre></td></tr></table></figure>

<ul>
<li>访问测试</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.3nbv3p1703y0.webp" alt="image"></p>
<blockquote>
<p> <strong>配置方式二：使用通配符配置</strong></p>
</blockquote>
<p>server_name 指令支持通配符 *，但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">*.frx.com</span>	<span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="comment"># www.frx.cn abc.frx.cn www.bing.cn www.frx.com</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的配置就会报错，因为 * 不能出现在域名的中间和与其他字符串联使用</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">www.*</span>.cn www.frx.c*</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  .frx.com</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.frx.com</code> 相当于 <code>*..frx.com</code> + <code>frx.com</code></p>
<blockquote>
<p><strong>配置三：使用正则表达式配置</strong></p>
</blockquote>
<p>server_name 指令可以使用正则表达式，并且使用 <code>~</code> 作为正则表达式字符串的开始标记。</p>
<p>常见的正则表达式：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配搜索字符串开始位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配搜索字符串结束位置</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单个字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符，将下一个字符标记为特殊字符</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集，与任意一个指定字符匹配</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围，匹配指定范围内的任何字符</td>
</tr>
<tr>
<td>\w</td>
<td>与以下任意字符匹配 A-Z a-z 0-9 和下划线,等效于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符匹配，等效于[0-9]</td>
</tr>
<tr>
<td>{n}</td>
<td>正好匹配 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少匹配 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配至少 n 次至多 m 次</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次，等效于{0,}</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次，等效于{1,}</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次，等效于{0,1}</td>
</tr>
</tbody></table>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ~^www\.(\w+)\.com$;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 ~ 后面不能加空格</strong>。括号代表可以在 Ngxin 配置文件内获取其中的值，如上方的 (\w+) 的内容可以用 $1 获取到参数，如果有多个括号，依次使用 $2 $3 …… 获取。</p>
<p>比如现在访问 <code>http://www.frx.com</code>，则返回 frx 到页面上，因为frx 被放在 $1 处：<code>return 200 frx</code>。</p>
<p>⚠ 这里进行说明：server_name 配置了 localhost 和配置 IP 或者域名的区别</p>
<p>localhost 是「虚拟 IP」，如果不是本机访问，而是外界访问，那么这个就是无效的，但是为什么学习阶段的时候都不改呢，因为当 Nginx 没有匹配到指定的 <code>server_name</code>，默认找到第一个 server 块，而 Nginx 默认的第一个 server 块就是 localhost，哪怕你把 localhost 改为其他的，如 hello，它也能访问。只是因为在匹配不到的情况下，默认是第一个 service 块，哪怕它确实和访问的 IP 不匹配。</p>
<p>IP 如果和域名进行了绑定，那么在 <code>server_name</code> 中，两者都可以填写，填了域名，最后也是找到 IP，只是因为域名好记住。</p>
<p>知道了区别，在生产环境上，可以给个指定的错误页面。如果匹配不上，则返回友好的提示，如第一个 server 块：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;    <span class="comment"># 匹配不上的时候，也可以填写 localhost</span></span><br><span class="line">    <span class="attribute">return</span> <span class="string">"&lt;h1&gt;不好意思，匹配不到！"</span>;</span><br><span class="line">    <span class="comment"># return 403;   # 也可以直接返回错误码</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.frxcat.fun;    <span class="comment"># 匹配域名访问</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码块只允许域名访问，而不允许 IP 访问，避免其他人把未备案的域名解析到自己的服务器 IP。</p>
<p>当然你也可以不设置错误页面。因为 Nginx 匹配不上时，直接返回它的欢迎界面。</p>
<h3 id="匹配执行顺序"><a href="#匹配执行顺序" class="headerlink" title="匹配执行顺序"></a>匹配执行顺序</h3><p>由于 server_name 指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的 server_name 匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> ~^www\.\w+\.com$;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_after_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">*.frx.com</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_before_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'exact_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> _;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'default_server not found server'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://www.kele.com</code> 的优先级：（访问完后请注释掉处理这个请求的 server）</p>
<ul>
<li>exact_success（第一个是精确匹配，然后注释掉该 server）</li>
<li>wildcard_before_success（第二个是开始匹配符，然后注释掉该 server）</li>
<li>wildcard_after_success（第三个是结尾匹配符，然后注释掉该 server）</li>
<li>regex_success（第四个是正则表达式，然后注释掉该 server）</li>
<li>default_server not found server!!（第五个是默认 server，因为前四个都注释了，所以只能走默认的 server）</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li><p>No1：准确匹配 server_name</p>
</li>
<li><p>No2：通配符在开始时匹配 server_name 成功</p>
</li>
<li><p>No3：通配符在结束时匹配 server_name 成功</p>
</li>
<li><p>No4：正则表达式匹配 server_name 成功</p>
</li>
<li><p>No5：被默认的 default_server 处理，如果没有指定默认找第一个 server</p>
</li>
</ul>
<h3 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h3><p><code>location</code> 指令是用来设置请求的 URI。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>location [ = | ~ | <del>* | ^</del> | @ ] &lt;uri&gt;{…}</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<p>uri 变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么 Nginx 服务器在搜索匹配 location 的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，<strong>如果能匹配到直接访问正则表达式的，匹配不到，就使用刚才匹配度最高（前缀最长的）的那个 location 来处理请求</strong>。</p>
<p>属性介绍:</p>
<p>不带符号，要求必须以指定模式开头，但是不要求精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下访问都是正确的</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=kele</span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>=</code> 是用于不包含正则表达式的 uri，必须与指定的模式精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> =/abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 匹配成功</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=TOM</span><br><span class="line"><span class="comment"># 匹配失败</span></span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>~</code> 是用于表示当前 uri 中包含了正则表达式，并且区分大小写</p>
<p><code>~*</code> 是用于表示当前 uri 中包含了正则表达式，但是是不区分大小写</p>
<p>换句话说，<strong>如果 uri 包含了正则表达式，需要用上述两个符号来标识</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用正则表达式，区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式，不区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~*^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>^~</code> 是用于不包含正则表达式的 uri，功能和不加符号的一致，唯一不同的是，如果请求匹配上了，那么就停止搜索其他模式了。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~/abc</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@</code> 前缀可以用来定义一个命名的 location,该 location 不处理正常的外部请求,一般用来当作标识供内部重定向使用。它们不能嵌套,也不能包含嵌套的 location。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /try &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /error &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> = <span class="variable">@name</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="variable">@name</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"<span class="variable">@name</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时访问 <code>/try</code> 或者 <code>/error</code> 都会返回 <code>@name</code>。</p>
<h3 id="root-alias指令"><a href="#root-alias指令" class="headerlink" title="root/alias指令"></a>root/alias指令</h3><ul>
<li><code>root</code> 指令是设置请求资源的根目录。默认值是 html。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>root &lt;path&gt;;</td>
<td>root html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>path 是 Nginx 服务器接收到请求以后查找资源的根目录路径。</p>
<ul>
<li><code>alias</code> 指令是用来更改 location 的 URI。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>alias &lt;path&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<ul>
<li>path 是修改后的根路径。</li>
</ul>
<p><strong>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li><p>在 <code>/usr/local/nginx/html</code> 目录下创建一个 images 目录,并在目录下放入一张图片 <code>mv.png</code> 图片。</p>
<p>然后进入配置文件，添加如下内容：</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问图片的路径为：<code>http://192.168.91.200/images/mv.png</code></p>
<ol start="2">
<li>如果把root改为alias</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次访问上述地址，页面会出现 404 的错误，查看错误日志会发现是因为地址不对，所以验证了：</p>
<ul>
<li><p>root 的处理结果是：<strong>root 路径 + location 路径</strong>，location 路径包括匹配后面的请求，即包括 /mv.png</p>
<p><code>/usr/local/nginx/html/images/mv.png</code></p>
</li>
</ul>
<ul>
<li>alias 的处理结果是：<strong>使用 alias 路径替换 location 路径</strong>，但是不会替换匹配后面的请求，即不会替换 /mv.png</li>
</ul>
<p>需要在 alias 后面路径改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求。</li>
</ol>
<p>将上述配置修改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问就会出问题，查看错误日志还是路径不对，所以需要把 alias 后面加上 /</p>
<p>小结：</p>
<ul>
<li>root 的处理结果是: root 路径 + location 路径</li>
<li>alias 的处理结果是:使用 alias 路径替换 location 路径</li>
<li>alias 是一个目录别名的定义，root 则是最上层目录的含义</li>
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求<ul>
<li><strong>alias 不支持 location 的 =</strong></li>
</ul>
</li>
</ul>
<p>这里再多言几句，alias 后指定的资源路径，Nginx 就会去这个路径下找资源，「忽略」location 本身的的请求，仅拼接 location 后面的请求。如果你想去拼接 location 本身，就用绝对路径（包括 location）的alias。</p>
<h3 id="index指令"><a href="#index指令" class="headerlink" title="index指令"></a>index指令</h3><p><code>index</code> 指令是设置网站的默认首页。默认是 index.html。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>index &lt;file&gt; …;</td>
<td>index index.html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><code>index</code> 后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会从左往右依次进行查找，找到第一个为止。</p>
<p>举例说明：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">	<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问该 location 的时候，可以通过 <code>http://ip:port/</code> 访问，地址后面如果不添加任何内容，则默认依次访问 index.html 和 index.htm，找到第一个来进行返回。</p>
<h3 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h3><p>error_page 指令是设置网站的错误页面。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>error_page &lt;code&gt; …… [=[response]] &lt;uri&gt;;</td>
<td>—</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>code 是响应码。</p>
<p><strong>当出现对应的响应 code 后，如何来处理？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li>可以指定具体跳转的地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> http://www.frx.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当页面产生 404 时，自动跳转到 <code>http://www.frx.com</code></p>
<ol start="2">
<li>可以指定重定向地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> /50x.html;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生错误页面时，重定向到 /50x.html，然后触发 location，最终访问的是 html 目录下的 50x.html 页面</p>
<ol start="3">
<li>使用 location 的 @ 符合完成错误信息展示</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> <span class="variable">@jump_to_error</span>;</span><br><span class="line">	<span class="attribute">location</span> <span class="variable">@jump_to_error</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">404</span> <span class="string">'Not Found Page...'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选项 <code>=[response]</code> 的作用是用来将相应代码更改为另外一个，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">200</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，当返回 404 找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是 200 而不是 404，这块需要注意下，编写 error_page 后面的内容，404 后面需要加空格，200 前面不能加空格。</p>
<h2 id="静态资源优化配置"><a href="#静态资源优化配置" class="headerlink" title="静态资源优化配置"></a>静态资源优化配置</h2><p>Nginx 对静态资源如何进行优化配置。这里从三个属性配置进行优化：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodeplay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>建议三个都开启。如果想知道为什么，请往下看。</p>
<h3 id="sendﬁle"><a href="#sendﬁle" class="headerlink" title="sendﬁle"></a>sendﬁle</h3><p>该指令是用来开启高效的文件传输模式。默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>sendﬁle &lt;on | off&gt;;</td>
<td>sendﬁle oﬀ;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>请求静态资源的过程：客户端通过网络接口向服务端发送请求，操作系统将这些客户端的请求传递给服务器端应用程序，服务器端应用程序会处理这些请求，请求处理完成以后，操作系统还需要将处理得到的结果通过网络适配器传递回去。</p>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost；</span><br><span class="line">	location / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在 html 目录下有一个 welcome.html 页面，访问地址：<code>http://192.168.91.200/welcome.html</code>。</p>
<p>流程如下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.24hrbukvg0lc.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.5l2efa1uqlo0.webp" alt="image"></p>
<h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h3><p>该指令必须在 sendfile 打开的状态下才会生效，主要是用来提升网络包的传输「效率」。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nopush &lt;on | off&gt;;</td>
<td>tcp_nopush oﬀ;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a>tcp_nodelay</h3><p>该指令必须在 keep-alive 连接开启的情况下才生效，来提高网络包传输的「实时性」。默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nodelay &lt;on | off&gt;;</td>
<td>tcp_nodelay on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.1iu7wmocw0ao.webp" alt="image"></p>
<p><code>tcp_nopush</code> 就像大巴车，等所有旅客占满了座位，才开始发车到景点（客户端），而 <code>tcp_nodelay</code>，上来一个旅客，就马上发车到景点客户端）。</p>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>经过分析，『 tcp_nopush 』和『 tcp_nodelay 』看起来是「互斥的」，那么为什么要将这两个值都打开，这个大家需要知道的是在 Linux2.5.9 以后的版本中两者是可以兼容的，三个指令都开启的好处是，sendfile 可以开启高效的文件传输模式，『 tcp_nopush 』开启可以确保在发送到客户端之前数据包已经充分「填满」，这大大减少了网络开销，并加快了文件发送的速度。然后，当它到达最后一个可能因为没有「填满」而暂停的数据包时，Nginx 会忽略『 tcp_nopush 』参数， 然后，『 tcp_nodelay 』强制套接字发送数据。由此可知，『 tcp_nopush 』可以与『 tcp_nodelay 』一起设置，它比单独配置『 tcp_nodelay 』具有更强的性能。</p>
<p>所以回归开头，我们可以使用如下配置来优化 Nginx 静态资源的处理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个都开启</span></span><br><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<h2 id="静态资源压缩配置"><a href="#静态资源压缩配置" class="headerlink" title="静态资源压缩配置"></a>静态资源压缩配置</h2><p>经过上述内容的优化，我们再次思考一个问题，假如在满足上述优化的前提下，我们传送一个 1M 的数据和一个 10M 的数据那个效率高？答案显而易见，<strong>传输内容小，速度就会快</strong>。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是「压缩」，接下来，我们来学习 Nginx 的静态资源压缩模块。</p>
<p>在 Nginx 的配置文件中可以通过配置 gzip 来对静态资源进行压缩，相关的指令可以配置在 http 块、server 块和 location 块中，Nginx 可以通过对这些指令进行解析和处理：</p>
<ul>
<li><code>ngx_http_gzip_module</code> 模块</li>
<li><code>ngx_http_gzip_static_module</code> 模块</li>
<li><code>ngx_http_gunzip_module</code> 模块</li>
</ul>
<p>接下来我们从以下内容进行学习：</p>
<ul>
<li>Gzip 各模块支持的配置指令</li>
<li>Gzip 压缩功能的配置</li>
<li>Gzip 和 sendfile 的冲突解决</li>
<li>浏览器不支持 Gzip 的解决方案</li>
</ul>
<h3 id="Gzip模块配置指令"><a href="#Gzip模块配置指令" class="headerlink" title="Gzip模块配置指令"></a>Gzip模块配置指令</h3><p>接下来所学习的指令都来自 <code>ngx_http_gzip_module</code> 模块，该模块会在 Nginx 安装的时候内置到 Nginx 的安装环境中，也就是说我们可以直接使用这些指令。</p>
<ul>
<li><code>gzip</code> 指令是用于开启或者关闭 Gzip 功能。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip &lt;on | off&gt;;</td>
<td>gzip off;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>注意：只有该指令为打开状态，下面的指令才有效果</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_types</code> 指令可以根据响应页的 MIME 类型选择性地开启 Gzip 压缩功能。默认是 text/html</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_types &lt;mime-type&gt; …… ;</td>
<td>gzip_types text/html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>所选择的值可以从 mime.types 文件中进行查找，也可以使用 * 代表所有。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_types</span> application/javascript;</span><br><span class="line">	<span class="comment"># * 代表所有</span></span><br><span class="line">	<span class="attribute">gzip_types</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_comp_level</code> 指令是用于设置 Gzip 压缩程度，级别从 1-9，1 表示要是程度最低，要是效率最高，9 刚好相反，压缩程度最高，但是效率最低、最费时间。默认值是 1</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_comp_level &lt;level&gt;;</td>
<td>gzip_comp_level 1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_vary</code> 指令是用于设置使用 Gzip 进行压缩发送是否携带『Vary:Accept-Encoding』头域的响应头部。主要是告诉接收方，所发送的数据经过了 Gzip 压缩处理。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_vary &lt;on | off&gt;;</td>
<td>gzip_vary off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4bsq0xpu9s20.webp" alt="image"></p>
<ul>
<li><code>gzip_buffers</code> 指令是用于处理请求压缩的缓冲区数量和大小</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>gzip_buffers 32 4k | 16 8k;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>其中 number 是指定 Nginx 服务器向系统申请缓存空间个数，size 指的是每个缓存空间的大小。主要实现的是申请 number 个每个大小为 size 的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	  <span class="comment"># 缓存空间大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_disable</code> 指令是针对不同种类客户端发起的请求，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_disable &lt;regex&gt; …… ;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>regex 是根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用 Gzip.该指令一般是用来排除一些明显不支持 Gzip 的浏览器。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br></pre></td></tr></table></figure>

<p><code>gzip_http_version</code> 指令是针对不同的 HTTP 协议版本，可以选择性地开启和关闭 Gzip 功能。默认是 1.1 版本</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_http_version &lt;1.0 | 1.1&gt;;</td>
<td>gzip_http_version 1.1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>该指令是指定使用 Gzip 的 HTTP 最低版本，该指令一般采用默认值即可。</p>
<ul>
<li><code>gzip_min_length</code> 指令是针对传输数据的大小，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_min_length &lt;length&gt;;</td>
<td>gzip_min_length 20;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>Nignx 计量大小的单位：bytes [字节] / kb [千字节] / M [兆]</p>
<p>例如: 1024 / 10k | K / 10m | M</p>
<p>Gzip 压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的话，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用 Gzip 功能，响应页面的大小可以通过头信息中的 <code>Content-Length</code> 来获取。但是如何使用了 Chunk 编码动态压缩，该指令将被忽略。建议设置为 1K 或以上。</p>
<ul>
<li><code>gzip_proxied</code> 指令设置是否对服务端返回的结果进行 Gzip 压缩</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_proxied &lt;off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any&gt;;</td>
<td>gzip_proxied off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>off：关闭 Nginx 服务器对后台服务器返回结果的 Gzip 压缩</li>
<li>expired：如果 header 头中包含 『Expires』头信息，启用压缩</li>
<li>no-cache：如果 header 头中包含 『Cache-Control:no-cache』头信息，启用压缩</li>
<li>no-store：如果 header 头中包含 『Cache-Control:no-store』头信息，启用压缩</li>
<li>private：如果 header 头中包含 『Cache-Control:private』头信息，启用压缩</li>
<li>no_last_modified：如果 header 头中不包含 『Last-Modified』头信息，启用压缩</li>
<li>no_etag：如果 header 头中不包含 『ETag』 头信息，启用压缩</li>
<li>auth：如果 header 头中包含 『Authorization』 头信息，启用压缩</li>
<li>any：无条件启用压缩</li>
</ul>
<h3 id="Gzip压缩功能配置模板"><a href="#Gzip压缩功能配置模板" class="headerlink" title="Gzip压缩功能配置模板"></a>Gzip压缩功能配置模板</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;  			   		 <span class="comment"># 开启 Gzip 功能</span></span><br><span class="line"><span class="attribute">gzip_types</span> *;		   	 	 <span class="comment"># 压缩源文件类型,根据具体的访问资源类型设定</span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;	   		 <span class="comment"># Gzip 压缩级别</span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;          <span class="comment"># 进行压缩响应页面的最小长度，content-length</span></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	         <span class="comment"># 缓存空间大小</span></span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;       <span class="comment"># 指定压缩响应所需要的最低 HTTP 请求版本</span></span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;		         <span class="comment"># 往头信息中添加压缩标识</span></span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>; <span class="comment"># 对 IE6 以下的版本都不进行压缩</span></span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;           <span class="comment"># Nginx 作为反向代理压缩服务端返回数据的条件</span></span><br></pre></td></tr></table></figure>

<p>这些配置在很多地方可能都会用到，所以我们可以将这些内容抽取到一个配置文件中，然后通过 include 指令把配置文件再次加载到 nginx.conf 配置文件中，方法使用。</p>
<p>创建压缩配置文件：<code>nginx_gzip.conf</code>，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> *;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;</span><br></pre></td></tr></table></figure>

<p>在 Nginx 核心配置文件 <code>nginx.conf</code> 进行引入，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> nginx_gzip.conf</span><br></pre></td></tr></table></figure>

<h3 id="Gzip和sendfile共存问题"><a href="#Gzip和sendfile共存问题" class="headerlink" title="Gzip和sendfile共存问题"></a>Gzip和sendfile共存问题</h3><p>前面在讲解 sendfile 的时候，提到过，开启 sendfile 以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是 Gzip 要想对资源压缩，是需要经过用户进程进行操作的。Nginx 设置了Gzip 之后，静态文件的 sendfile 就不起作用了。所以要考虑如何解决两个设置的共存问题。</p>
<p>可以使用 <code>ngx_http_gzip_static_module</code> 模块的 <code>gzip_static</code> 指令来解决。</p>
<h3 id="gzip-static指令"><a href="#gzip-static指令" class="headerlink" title="gzip_static指令"></a>gzip_static指令</h3><p><code>gzip_static</code> 指令用于在检查与访问资源同名的 .gz 文件时，response 中以 Gzip 相关的 header 返回 .gz 文件的内容。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_static &lt;on | off | always&gt;;</td>
<td>gzip_static off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>在配置文件添加上述命令后，会报一个错误：<code>unknown directive &quot;gzip_static&quot;</code>，主要的原因是 Nginx 默认是没有添加 ngx_http_gzip_static_module 模块。如何来添加？</p>
<h3 id="Nginx模块添加"><a href="#Nginx模块添加" class="headerlink" title="Nginx模块添加"></a>Nginx模块添加</h3><ol>
<li>查询当前 Nginx 的配置参数，即查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 Nginx 安装目录下 sbin 目录中的 nginx 二进制文件进行更名备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/nginx/core/nginx-1.21.6</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 configure 来配置参数，添加 <code>ngx_http_gzip_static_module</code> 模块，记得加上第1步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module  <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用 make 命令进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 objs 目录下的 nginx 二进制执行文件移动到 nginx 安装目录下的 sbin 目录中</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.21.6/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>如果不执行第（2）步进行备份，则该步骤会覆盖原来的 nginx 可执行文件</p>
<ol start="8">
<li>在源码目录下执行更新命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="gzip-static测试"><a href="#gzip-static测试" class="headerlink" title="gzip_static测试"></a>gzip_static测试</h3><p>准备好一个 jquery.js 文件，放在 html 目录下</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.576ef03x00c0.webp" alt="image"></p>
<ol>
<li>直接访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.2b8dhabn0cbo.webp" alt="image"></p>
<ol start="2">
<li>使用 Gzip 命令进行压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 html 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩 js 文件</span></span><br><span class="line">gzip jquery.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4ivj1d091pg.webp" alt="image"></p>
<p>可以看出 <code>Content-Length</code> 的大小已经变得非常小。</p>
<h2 id="静态资源缓存配置"><a href="#静态资源缓存配置" class="headerlink" title="静态资源缓存配置"></a>静态资源缓存配置</h2><p>当浏览器请求 Nginx 服务器的资源后，我们可以让这些资源缓存在浏览器里，这样再一次请求相同的资源时，无需请求 Nginx 服务器，直接从浏览器的缓存里获取，减少 Nginx 服务器的压力。</p>
<h3 id="什么是缓存和Web缓存"><a href="#什么是缓存和Web缓存" class="headerlink" title="什么是缓存和Web缓存"></a>什么是缓存和Web缓存</h3><p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 DRAM 技术，而使用昂贵但较快速的 SRAM 技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p>
<p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 URL 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p>
<h3 id="Web缓存的种类"><a href="#Web缓存的种类" class="headerlink" title="Web缓存的种类"></a>Web缓存的种类</h3><p>客户端缓存</p>
<ul>
<li>浏览器缓存</li>
</ul>
<p>服务端缓存</p>
<ul>
<li>Nginx</li>
<li>Redis</li>
<li>Memcached 等</li>
</ul>
<h3 id="为什么要用浏览器缓存"><a href="#为什么要用浏览器缓存" class="headerlink" title="为什么要用浏览器缓存"></a>为什么要用浏览器缓存</h3><ul>
<li>成本最低的一种缓存实现</li>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟，加快页面打开速度</li>
</ul>
<h3 id="浏览器缓存执行流程"><a href="#浏览器缓存执行流程" class="headerlink" title="浏览器缓存执行流程"></a>浏览器缓存执行流程</h3><p>HTTP 协议中和页面缓存相关的字段，我们先来认识下：</p>
<table>
<thead>
<tr>
<th>header</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Expires</td>
<td>缓存过期的日期和时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>设置和缓存相关的配置信息</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源最后修改时间</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值，比如文件的 MD5 值</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.209c4krjzgf4.webp" alt="image"></p>
<ol>
<li>用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送 request 请求来获取数据；</li>
<li>服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回 200 的成功状态码并且在响应头上附上对应资源以及缓存信息；</li>
<li>当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件；</li>
<li>如果没有找到对应的缓存文件，则走第2步；</li>
<li>如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires)；</li>
<li>如果没有过期，则直接从本地缓存中返回数据进行展示（强缓存）；</li>
<li>如果 Expires 过期，接下来需要判断缓存文件是否发生过变化；</li>
<li>判断的标准有两个（都要判断），一个是 ETag(Entity Tag)，一个是 Last-Modified；</li>
<li>判断结果是未发生变化，则服务端返回 304，直接从缓存文件中获取数据（弱缓存）；</li>
<li>如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</li>
</ol>
<h3 id="浏览器缓存相关指令"><a href="#浏览器缓存相关指令" class="headerlink" title="浏览器缓存相关指令"></a>浏览器缓存相关指令</h3><p>Nginx 需要进行缓存相关设置，就需要用到如下的指令。</p>
<h4 id="expires指令"><a href="#expires指令" class="headerlink" title="expires指令"></a>expires指令</h4><p>该指令用来控制页面缓存的作用。可以通过该指令控制 HTTP 应答中的『Expires』和『Cache-Control』</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>expires [modified] &lt;time&gt;; expires &lt;epoch | max | off&gt;;</td>
<td>expires off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li><p>time：可以整数也可以是负数，指定过期时间，单位为 s（秒）。如果是负数，Cache-Control 则为 no-cache，如果为整数或 0，则 Cache-Control 的值为 max-age=time</p>
</li>
<li><p>epoch：指定 Expires 的值为『’1 January,1970,00:00:01 GMT’』，即 1970-01-01 00:00:00 ，Cache-Control 的值 no-cache</p>
<p>因为 Expires（缓存过期时间）是 1970 年，所以不缓存。</p>
</li>
<li><p>max：指定 Expires 的值为『’31 December2037 23:59:59GMT’ 』，即(2037-12-31 23:59:59，Cache-Control 的值为 10 年</p>
<p>因为 Expires（缓存过期时间）是 2037 年，虽然还有 16 年过期，但是最大只能缓存 10 年。</p>
</li>
<li><p>off：默认不缓存</p>
</li>
</ul>
<blockquote>
<p><strong>例子 1</strong></p>
</blockquote>
<p>在配置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|js|css|png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attribute">expires</span> max</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求：<code>http://192.168.91.200/jquery.js</code></p>
<p>查看开发者工具(F12)的 NetWork，如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4x3yczk58lk0.webp" alt="image"></p>
<p>315360000 折算下来正好是 10 年。</p>
<blockquote>
<p><strong>其他格式</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expires</span> <span class="number">30s</span>;  <span class="comment"># 表示把数据缓存 30 秒</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">30m</span>;  <span class="comment"># 表示把数据缓存 30 分</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">10h</span>;  <span class="comment"># 表示把数据缓存 10 小时</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">1d</span>;   <span class="comment"># 表示把数据缓存 1 天</span></span><br></pre></td></tr></table></figure>

<h4 id="add-header指令"><a href="#add-header指令" class="headerlink" title="add_header指令"></a>add_header指令</h4><p>add_header 指令是用来添加指定的响应头和响应值。</p>
<p>add_header 是响应体的指令，不是请求时的指令（比如 expires ），并且 add_header 也有和 expires 一样的功能。</p>
<p>如果 expires 和 add_header 同时开启的情况下，则 add_header 优于 expires 生效。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>add_header &lt;name&gt; &lt;value&gt; [always];</td>
<td>—</td>
<td>location &gt; server &gt; http &gt; ……</td>
</tr>
</tbody></table>
<p>always 可选，代表总是添加。</p>
<p>Cache-Control 作为响应头信息，可以在 Nginx 配置文件设置如下缓存响应指令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Cache-control must-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-cache;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-store;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-transform;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control public;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control private;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control proxy-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-Control max-age=&lt;seconds&gt;;  <span class="comment"># 秒</span></span><br><span class="line"><span class="attribute">add_header</span> Cache-control s-maxage=&lt;seconds&gt;; <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure>

<p>描述：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>no-cache</td>
<td>数据内容不能被缓存，每次请求都重新访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存请求或响应的任何内容，暂存也不可以(临时文件夹中不能暂存该资源)</td>
</tr>
<tr>
<td>no-transform</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>public</td>
<td>可以被任何缓存区缓存，如: 浏览器、服务器、代理服务器等</td>
</tr>
<tr>
<td>private（默认）</td>
<td>只能在浏览器中缓存，只有在第一次请求的时候才访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age=&lt;秒&gt;</td>
<td>过期时间，即以秒为单位的缓存时间</td>
</tr>
<tr>
<td>s-maxage=&lt;秒&gt;</td>
<td>公共缓存服务器响应的最大 Age 值</td>
</tr>
</tbody></table>
<p>值得注意的是：</p>
<ul>
<li>设置了 no-cache 或者 private 后，打开新窗口时会重新访问服务器。若设置 max-age，则缓存期间不访问服务器</li>
<li>设置 private 和正数的 max-age 时，后退时候不会访问服务器</li>
<li>设置 no-cache 和正数的 max-age 时，后退时会访问服务器</li>
</ul>
<h3 id="Nginx服务端缓存"><a href="#Nginx服务端缓存" class="headerlink" title="Nginx服务端缓存"></a>Nginx服务端缓存</h3><p>在 Web 缓存的种类，我们提到了 Ngixn 服务端缓存，而上面仅仅介绍了在浏览器进行缓存，而因为 Ngixn 服务端缓存的内容比较多，所以前往 <strong>Nginx - 缓存集成</strong> 进行学习。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/09/Nginx_Base_Use/">Nginx基本使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-基本使用"><a href="#Nginx-基本使用" class="headerlink" title="Nginx 基本使用"></a>Nginx 基本使用</h1><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.7e2zl4ci9t40.webp" alt="image"></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>进入Nginx的主目录我们可以看到这些文件夹</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master /]<span class="comment"># cd /usr/local/nginx/</span></span><br><span class="line">[root@master nginx]<span class="comment"># ll</span></span><br><span class="line">总用量 0</span><br><span class="line">drwx------ 2 nobody root   6 7月  27 20:35 client_body_temp</span><br><span class="line">drwxr-xr-x 2 root   root 333 7月  27 20:31 conf</span><br><span class="line">drwx------ 2 nobody root   6 7月  27 20:35 fastcgi_temp</span><br><span class="line">drwxr-xr-x 2 root   root  40 7月  27 20:31 html</span><br><span class="line">drwxr-xr-x 2 root   root  58 7月  27 20:35 logs</span><br><span class="line">drwx------ 2 nobody root   6 7月  27 20:35 proxy_temp</span><br><span class="line">drwxr-xr-x 2 root   root  36 7月  27 20:33 sbin</span><br><span class="line">drwx------ 2 nobody root   6 7月  27 20:35 scgi_temp</span><br><span class="line">drwx------ 2 nobody root   6 7月  27 20:35 uwsgi_temp</span><br></pre></td></tr></table></figure>

<p>其中这几个文件夹在刚安装后是没有的，主要用来存放运行过程中的临时文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client_body_temp fastcgi_temp proxy_temp scgi_temp</span><br></pre></td></tr></table></figure>

<ul>
<li>主要目录说明</li>
</ul>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>用来存放配置文件相关</td>
</tr>
<tr>
<td>html</td>
<td>用来存放静态文件的默认目录 html、css等</td>
</tr>
<tr>
<td>sbin</td>
<td>nginx的主程序</td>
</tr>
</tbody></table>
<h2 id="基本运行原理"><a href="#基本运行原理" class="headerlink" title="基本运行原理"></a>基本运行原理</h2><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.5klrdamfdsg0.webp" alt="image"></p>
<h2 id="启动停止命令"><a href="#启动停止命令" class="headerlink" title="启动停止命令"></a>启动停止命令</h2><p>对于 Nginx 的启停在 Linux 系统中也有很多种方式，我们介绍两种方式：</p>
<ul>
<li>Nginx 服务的信号控制</li>
<li>Nginx 的命令行控制</li>
</ul>
<h3 id="服务信号控制"><a href="#服务信号控制" class="headerlink" title="服务信号控制"></a>服务信号控制</h3><p>在了解内容之前，我们首先要考虑一些问题：</p>
<ul>
<li><p>Nginx 中的 master 和 worker 进程?</p>
</li>
<li><p>Nginx 的工作方式?</p>
</li>
<li><p>如何获取进程的 PID?</p>
</li>
<li><p>信号有哪些?</p>
</li>
<li><p>如何通过信号控制 Nginx 的启停等相关操作?</p>
</li>
</ul>
<p>前面在提到 Nginx 的高性能，其实也和它的架构模式有关。Nginx 默认采用的是多进程的方式来工作的，当将 Nginx 启动后，我们通过 <code>ps -ef | grep nginx</code> 命令可以查看到如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master sbin]<span class="comment"># ps -ef| grep nginx</span></span><br><span class="line">root       3564      1  0 13:54 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">nobody     3565   3564  0 13:54 ?        00:00:00 nginx: worker process</span><br><span class="line">root       3567   3483  0 13:54 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<p>从上图中可以看到，Nginx 后台进程中包含一个 master 进程和多个 worker 进程，master 进程主要用来管理 worker 进程，包含接收外界的信息，并将接收到的信号发送给各个 worker 进程，监控 worker 进程的状态。当 worker 进程出现异常退出后，会自动重新启动新的 worker 进程。而 worker 进程则是专门用来处理用户请求的，各个 worker 进程之间是平等的并且相互独立，处理请求的机会也是一样的。</p>
<p>Nginx 的进程模型，我们可以通过下图来说明下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.2i4zuw23isa0.webp" alt="image"></p>
<p>我们现在作为管理员，只需要通过给 master 进程发送信号就可以来控制 Nginx，这个时候我们需要有两个前提条件，一个是要操作的 master 进程，一个是 给 master 进程的信号。</p>
<ol>
<li>要想操作 Nginx 的 master 进程，就需要获取到 master 进程的进程号 PID。获取方式简单介绍两个：</li>
</ol>
<ul>
<li>通过 <code>ps -ef | grep nginx</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>在讲解 Nginx 的 <code>./configure</code> 的配置参数的时候，有一个参数 <code>--pid-path=PATH</code>，它的默认值是 <code>/usr/local/nginx/logs/nginx.pid</code>，所以可以通过查看该文件来获取 Nginx 的 master 进程 PID</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>信号(signal)</li>
</ol>
<table>
<thead>
<tr>
<th>信号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>TERM/INT</td>
<td>立即关闭整个服务（关闭 Nginx）</td>
</tr>
<tr>
<td>QUIT</td>
<td>「优雅」的关闭整个服务（关闭 Nginx）</td>
</tr>
<tr>
<td>HUP</td>
<td>重读配置文件并使用服务对新配置项生效（重启 Nginx）</td>
</tr>
<tr>
<td>USR1</td>
<td>重新打开日志文件，可以用来进行日志切割（重启日志）</td>
</tr>
<tr>
<td>USR2</td>
<td>平滑升级到最新版的 Nginx</td>
</tr>
<tr>
<td>WINCH</td>
<td>所有子进程不在接收处理新连接，相当于给 Work 进程发送 QUIT 指令</td>
</tr>
</tbody></table>
<p>调用命令为 <code>kill -signal PID</code></p>
<blockquote>
<p>signal：即为信号；PID 即为获取到的 master 进程 PID</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -signal PID</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式一：</span></span><br><span class="line"><span class="built_in">kill</span> -TERM PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即关闭当前线程</span></span><br><span class="line"><span class="built_in">kill</span> -TERM `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式一：</span></span><br><span class="line"><span class="built_in">kill</span> -INT PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即关闭当前线程</span></span><br><span class="line"><span class="built_in">kill</span> -INT `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<ol>
<li>发送 TERM/INT 信号给 master 进程，会将 Nginx 服务立即关闭。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master nginx]<span class="comment"># cat logs/nginx.pid</span></span><br><span class="line">3564</span><br><span class="line">[root@master nginx]<span class="comment"># kill  -TERM 3564</span></span><br><span class="line">[root@master nginx]<span class="comment"># ps -ef | grep nginx</span></span><br><span class="line">root       8874   8753  0 15:58 pts/2    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>发送 QUIT 信号给 master 进程，master 进程会控制所有的 work 进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优雅 关闭线程</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 「优雅」关闭当前线程</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发送 HUP 信号给 master 进程，master 进程会把控制旧的 worker 进程不再接收新的请求，等处理完请求后将旧的 worker 进程关闭掉，然后根据<mark>更改Nginx 的配置文件</mark>重新启动新的 worker 进程</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 worker 进程</span></span><br><span class="line"><span class="built_in">kill</span> -HUP PID </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启当前 worker 进程</span></span><br><span class="line"><span class="built_in">kill</span> -HUP `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>发送 USR1 信号给 master 进程，告诉 Nginx 重新开启日志文件。如果日志文件被删除了，可以利用此命令重新打开。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新打开日志文件</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打开当前 Nginx 的日志文件</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>发送 USR2 信号给 master 进程，告诉 master 进程要平滑升级，这个时候，会重新开启对应的 master 进程和 worker 进程，整个系统中将会有两个master 进程，并且新的 master 进程的 PID 会被记录在 <code>/usr/local/nginx/logs/nginx.pid</code>，而之前的旧的 master 进程 PID 会被记录在 <code>/usr/local/nginx/logs/nginx.pid.oldbin</code> 文件中，接着再次发送 QUIT 信号给旧的 master 进程，让其处理完请求后再进行关闭</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启新的进程，但是不删除旧的进程</span></span><br><span class="line"><span class="built_in">kill</span> -USR2 PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新的进程，但是不删除当前进程</span></span><br><span class="line"><span class="built_in">kill</span> -USR2 `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<p>当新进程升级后（完全启动后），再关闭旧的进程，旧进程的 PID 在另一个 <code>nginx.pid.oldbin</code> 文件里</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭旧的线程</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.5dgklob27do0.webp" alt="image"></p>
<ol start="6">
<li>发送 WINCH 信号给 master 进程,让 master 进程控制不让所有的 worker 进程在接收新的请求了，请求处理完后关闭 worker 进程。注意 master 进程不会被关闭掉</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 worker 进程，但是不停止 master 进程</span></span><br><span class="line"><span class="built_in">kill</span> -WINCH PID </span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止当前 worker 进程，但是不停止 master 进程</span></span><br><span class="line"><span class="built_in">kill</span> -WINCH `cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<h3 id="命令行控制"><a href="#命令行控制" class="headerlink" title="命令行控制"></a>命令行控制</h3><p>此方式是通过 Nginx 安装目录下的 sbin 下的可执行文件 nginx(文件名) 来进行对 Nginx 状态的控制，我们可以通过 <code>nginx -h</code> 来查看都有哪些参数可以用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master sbin]<span class="comment"># ./nginx -h</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]</span><br><span class="line">             [-e filename] [-c filename] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span></span><br><span class="line">  -v            : show version and <span class="built_in">exit</span></span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -T            : <span class="built_in">test</span> configuration, dump it and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /usr/<span class="built_in">local</span>/nginx/)</span><br><span class="line">  -e filename   : <span class="built_in">set</span> error <span class="built_in">log</span> file (default: logs/error.log)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: conf/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-? 和 -h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>-v</td>
<td>打印版本号信息并退出</td>
</tr>
<tr>
<td>-V</td>
<td>打印版本号信息和配置信息并退出</td>
</tr>
<tr>
<td>-t</td>
<td>测试 Nginx 的配置文件语法是否正确并退出</td>
</tr>
<tr>
<td>-T</td>
<td>测试 Nginx 的配置文件语法是否正确并列出用到的配置文件信息然后退出</td>
</tr>
<tr>
<td>-q</td>
<td>在配置测试期间过滤掉非错误消息</td>
</tr>
<tr>
<td>-s</td>
<td>signal 信号，后面的命令和服务信号控制功能类似：  <code>stop</code>：快速关闭，类似于 TERM/INT 信号的作用 <code>quit</code>：优雅的关闭，类似于 QUIT 信号的作用 <code>reopen</code>：重新打开日志文件类似于 USR1 信号的作用 <code>reload</code>：重启 Nginx，类似于 HUP 信号的作用</td>
</tr>
<tr>
<td>-p</td>
<td>prefix，指定 Nginx 的默认安装路径，(默认为：/usr/local/nginx/)</td>
</tr>
<tr>
<td>-c</td>
<td>filename，指定 Nginx 的配置文件路径,(默认为：conf/nginx.conf)</td>
</tr>
<tr>
<td>-g</td>
<td>用来补充 Nginx 配置文件，向 Nginx 服务指定启动时应用全局的配置</td>
</tr>
</tbody></table>
<ul>
<li>案例</li>
</ul>
<p>如果觉得每次执行 nginx 指令都必须进入 sbin 目录，则将该指令设置为全局使用。</p>
<ol>
<li>两个查看版本命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本指令 1</span></span><br><span class="line">[root@master sbin]<span class="comment"># nginx -v</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本指令 2</span></span><br><span class="line">[root@master sbin]<span class="comment"># nginx -V</span></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class="line">configure arguments: --prefix=/usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>测试 Nginx 的配置文件语法</li>
</ol>
<p>我们首先要知道配置文件的路径在哪，先执行 <code>-t</code> 进行测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试 Nginx 的配置文件语法</span></span><br><span class="line">[root@master sbin]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果 返回 成功</span></span><br><span class="line">nginx: the configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>

<p>由第 6 行代码可以知道测试成功，第 5 行代码告诉我们配置文件的目录，我们去修改配置文件，然后再进行测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master sbin]<span class="comment"># vim /usr/local/nginx/conf/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###add</span></span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>

<p>重新进行测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试 Nginx 的配置文件语法</span></span><br><span class="line">[root@master sbin]<span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果（失败）</span></span><br><span class="line">nginx: [emerg] unknown directive <span class="string">"HelloWorld"</span> <span class="keyword">in</span> /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf:3</span><br><span class="line">nginx: configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf <span class="built_in">test</span> failed</span><br></pre></td></tr></table></figure>

<p>由第 6 行代码可以知道，配置文件出错了。验证完了，记得将配置文件改回来。</p>
<ol start="3">
<li>指定 Nginx 的默认安装路径</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -p /usr/<span class="built_in">local</span>/nginx/</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>指定 Nginx 的配置文件路径</li>
</ol>
<p>先把配置文件拷贝到另一个目录，然后修改拷贝后的配置文件内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝配置文件</span></span><br><span class="line">cp /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改拷贝后的配置文件内容</span></span><br><span class="line">vim /opt/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># add</span></span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>

<p>测试配置文件的时候，指定拷贝后的配置文件进行测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定配置文件进行测试</span></span><br><span class="line">[root@master nginx]<span class="comment"># nginx -tc /opt/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#返回结果</span></span><br><span class="line">nginx: [emerg] unknown directive <span class="string">"HelloWorld"</span> <span class="keyword">in</span> /opt/nginx.conf:3</span><br><span class="line">nginx: configuration file /opt/nginx.conf <span class="built_in">test</span> failed</span><br></pre></td></tr></table></figure>

<p>说明指定配置文件目录生效，只是文件内容语法不对。</p>
<h2 id="版本升级和新增模块"><a href="#版本升级和新增模块" class="headerlink" title="版本升级和新增模块"></a>版本升级和新增模块</h2><p>如果想对 Nginx 的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的 Nginx 服务，然后开启新的 Nginx 服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到 Nginx 服务器提供的平滑升级功能。这个也是 Nginx 的一大特点，使用这种方式，就可以使 Nginx 在 7 * 24 小时不间断的提供服务了。接下来我们分析下需求：</p>
<blockquote>
<p>需求：Nginx 的版本最开始使用的是 Nginx-1.14.2，由于服务升级，需要将 Nginx 的版本升级到 Nginx-1.16.1,要求 Nginx 不能中断提供服务。</p>
</blockquote>
<p>为了应对上述的需求，这里我们提供两种解决方案:</p>
<ul>
<li>使用 Nginx 服务信号完成 Nginx 的升级</li>
<li>使用 Nginx 安装目录的 make 命令完成升级</li>
</ul>
<p>版本升级其实就是替换可执行文件 nginx。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li>先准备两个版本的 Nginx 分别是 1.14.2 和 1.16.1</li>
<li>使用 Nginx 源码安装的方式将 1.14.2 版本安装成功并正确访问</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压 1.14.2 版本</span></span><br><span class="line">tar -xzf nginx-1.14.2.tar.gz</span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.14.2/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行配置文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将 Nginx 1.16.1 版本进行参数配置和编译，不需要进行安装。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压 1.16.1 版本</span></span><br><span class="line">tar -xzf nginx-1.16.1.tar.gz</span><br><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.16.1/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行配置文件</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅仅编译</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="服务信号进行升级"><a href="#服务信号进行升级" class="headerlink" title="服务信号进行升级"></a>服务信号进行升级</h3><p>第一步:将 1.14.2 版本的 sbin 目录下的 nginx 进行备份</p>
<blockquote>
<p>不是复制一份，是直接修改原来的 nginx。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 sbin 目录下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份为 nginxold 文件</span></span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<p>第二步：将 Nginx 1.16.1 安装目录编译后的 objs 目录下的 nginx 文件，拷贝到原来 <code>/usr/local/nginx/sbin</code> 目录下</p>
<p>如果第一步没有备份，那么将会覆盖 1.14.2 的 nginx 文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 objs 目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝可执行文件到原来的目录</span></span><br><span class="line">cp nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>第三步：发送信号 USR2 给 Nginx 的 1.14.2 版本对应的 master 进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR2 `cat /usr/<span class="built_in">local</span>/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<p>第四步：发送信号 QUIT 给 Nginx 的 1.14.2 版本对应的 master 进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -QUIT `cat /usr/<span class="built_in">local</span>/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>

<h3 id="安装目录的make命令完成升级"><a href="#安装目录的make命令完成升级" class="headerlink" title="安装目录的make命令完成升级"></a>安装目录的make命令完成升级</h3><p>第一步：将 1.14.2 版本的 sbin 目录下的 nginx 进行备份</p>
<blockquote>
<p>不是复制一份，是直接修改原来的 nginx。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 sbin 目录下</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份为 nginxold 文件</span></span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<p>第二步：将 Nginx1.16.1 安装目录编译后的 objs 目录下的 nginx 文件，拷贝到原来 <code>/usr/local/nginx/sbin</code> 目录下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 objs 目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝可执行文件到原来的目录</span></span><br><span class="line">cp nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>第三步：进入到安装目录，执行 <code>make upgrade</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.2hpc905f42a0.webp" alt="image"></p>
<p>第四步：查看是否更新成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<p>在整个过程中，其实 Nginx 是一直对外提供服务的。并且当 Nginx 的服务器启动成功后，我们是可以通过浏览器进行直接访问的，同时我们可以通过更改 html 目录下的页面来修改我们在页面上所看到的内容，那么问题来了，为什么我们要修改 html 目录下的文件，能不能多添加一些页面是 Nginx 的功能更加丰富，还有前面聊到 Nginx 的前端功能又是如何来实现的，这就需要我们对 <a href="/middleware/Nginx/Nginx_Configuration_file">Nginx 的核心配置文件</a> 进行一个详细的学习。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/09/Nginx_install/">Nginx安装</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h1><h2 id="Nginx版本介绍"><a href="#Nginx版本介绍" class="headerlink" title="Nginx版本介绍"></a>Nginx版本介绍</h2><p>Nginx 的官方网站为: <a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org</a></p>
<p>打开源码可以看到如下的页面内容</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.4wlfyfbk53i0.webp" alt="image"></p>
<p>Nginx 的官方下载网站为 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>，当然你也可以之间在首页选中右边的 download 进入版本下载网页。在下载页面我们会看到如下内容：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.3e7olqaurau0.webp" alt="image"></p>
<h2 id="获取Nginx源码"><a href="#获取Nginx源码" class="headerlink" title="获取Nginx源码"></a>获取Nginx源码</h2><p><a href="http://nginx.org/download/" target="_blank" rel="noopener">http://nginx.org/download/</a></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.3cu95u4zd440.webp" alt="image"></p>
<h2 id="准备服务器系统"><a href="#准备服务器系统" class="headerlink" title="准备服务器系统"></a>准备服务器系统</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>虚拟机：VMware WorkStation</li>
<li>Linux 系统：Centos7</li>
<li>上传软件工具：MobaXterm、xsheel,SecureCRT 之一</li>
<li>网络</li>
</ul>
<h3 id="确认CentOS的内核"><a href="#确认CentOS的内核" class="headerlink" title="确认CentOS的内核"></a>确认CentOS的内核</h3><p>准备一个内核为 2.6 及以上版本的操作系统，因为 linux2.6 及以上内核才支持 epoll,而 Nginx 需要解决高并发压力问题是需要用到 epoll，所以我们需要有这样的版本要求。</p>
<p>我们可以使用 <code>uname -a</code> 命令来查询linux的内核版本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux master 3.10.0-1160.el7.x86_64 <span class="comment">#1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<h3 id="确保Centos能联网"><a href="#确保Centos能联网" class="headerlink" title="确保Centos能联网"></a>确保Centos能联网</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p>三种网络模式：桥接、主机、NAT，建议使用虚拟机使用 NAT 模式</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.4ga3snmdtsa0.webp" alt="image"></p>
<p>NAT 模式下，只要主机有网络，则虚拟机也有网络。</p>
<h3 id="确认关闭防火墙"><a href="#确认关闭防火墙" class="headerlink" title="确认关闭防火墙"></a>确认关闭防火墙</h3><p>这一项的要求仅针对于那些对 Linux 系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为把防火墙关闭掉，可以省掉后续 Nginx 使用过程中遇到的诸多问题。</p>
<p>关闭的方式有如下两种:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld      <span class="comment"># 关闭运行的防火墙，系统重新启动后，防火墙将重新打开</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld   <span class="comment"># 永久关闭防火墙，，系统重新启动后，防火墙依然关闭</span></span><br><span class="line">systemctl status firewalld	 <span class="comment"># 查看防火墙状态</span></span><br></pre></td></tr></table></figure>

<p>如果不想关闭防火墙，记得开放 Nginx 的访问端口</p>
<h3 id="确认停用selinux"><a href="#确认停用selinux" class="headerlink" title="确认停用selinux"></a>确认停用selinux</h3><p>selinux(security-enhanced linux)，美国安全局对于强制访问控制的实现，在 Linux2.6 内核以后的版本中，selinux 已经成功内核中的一部分。可以说selinux 是 Linux 史上最杰出的新安全子系统之一。虽然有了 selinux，我们的系统会更安全，但是对于使用 Nginx 或者其他的学习过程中，会有很多设置，所以这块建议大家将 selinux 进行关闭。</p>
<p><code>sestatus</code> 查看状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># sestatus</span></span><br><span class="line">SELinux status:                 disabled</span><br></pre></td></tr></table></figure>

<p>如果查看不是 disabled 状态，我们可以通过修改配置文件来进行设置,修改 <code>SELINUX=disabled</code>，然后重启下系统即可生效。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.1063r7fk4lz4.webp" alt="image"></p>
<h2 id="Nginx环境安装"><a href="#Nginx环境安装" class="headerlink" title="Nginx环境安装"></a>Nginx环境安装</h2><p>Nginx 的安装方式有两种分别是：</p>
<ul>
<li>通过 Nginx 源码<ul>
<li>通过 Nginx 源码简单安装</li>
<li>通过 Nginx 源码复杂安装</li>
</ul>
</li>
<li>通过 yum 安装</li>
</ul>
<p>如果通过 Nginx 源码安装需要提前准备安装好环境，我相信，任何 C 语言编写的软件都离不开这些环境，安装后所有软件都会收益，往下看。</p>
<h3 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h3><p>Nginx 是使用 C 语言编写的程序，因此想要运行 Nginx 就需要安装一个编译工具。GCC 就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了 C 语言。</p>
<p>使用命令 <code>yum install -y gcc</code> 来安装</p>
<p>安装成功后，可以通过 <code>gcc --version</code> 来查看 gcc 是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 gcc</span></span><br><span class="line">yum install -y gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 gcc 版本</span></span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<h3 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h3><p>Nginx 在编译过程中需要使用到 PCRE 库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在 Nginx 的 Rewrite 模块和 Http 核心模块都会使用到 PCRE 正则表达式语法。</p>
<p>可以使用命令 <code>yum install -y pcre pcre-devel</code> 来进行安装</p>
<p>安装成功后，可以通过 <code>rpm -qa pcre pcre-devel</code> 来查看是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 PCRE 和 pcre-devel</span></span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 PCRE 是否安装成功</span></span><br><span class="line">rpm -qa pcre pcre-devel</span><br></pre></td></tr></table></figure>

<h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><p>zlib 库提供了开发人员的压缩算法，在 Nginx 的各个模块中需要使用 gzip 压缩，所以我们也需要提前安装其库及源代码 zlib 和 zlib-devel。</p>
<p>可以使用命令 <code>yum install -y zlib zlib-devel</code> 来进行安装</p>
<p>安装成功后，可以通过 <code>rpm -qa zlib zlib-devel</code> 来查看是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 zlib 和 zlib-devel</span></span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 zlib 和 zlib-devel 是否安装成功</span></span><br><span class="line">rpm -qa zlib zlib-devel</span><br></pre></td></tr></table></figure>

<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p>
<p>SSL：Secure Sockets Layer 安全套接协议的缩写，可以在 Internet 上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在 Nginx 中，如果服务器需要提供安全网页时就需要用到 OpenSSL 库，所以我们需要对 OpenSSL 的库文件及它的开发安装包进行一个安装。</p>
<p>可以使用命令 <code>yum install -y openssl openssl-devel</code> 来进行安装</p>
<p>安装成功后，可以通过 <code>rpm -qa openssl openssl-devel</code> 来查看是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 OpenSSL 库</span></span><br><span class="line">yum install -y openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 OpenSSL 是否安装成功</span></span><br><span class="line">rpm -qa openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="全部安装命令"><a href="#全部安装命令" class="headerlink" title="全部安装命令"></a>全部安装命令</h3><p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p>
<p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code> 进行全部安装。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部安装 GCC、PCRE、zlib、OpenSSL</span></span><br><span class="line">yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看安装版本</span></span><br><span class="line">rpm -qa pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>Nginx 的官方下载网站为 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<h3 id="源码简单安装"><a href="#源码简单安装" class="headerlink" title="源码简单安装"></a>源码简单安装</h3><ol>
<li>进入官网查找需要下载版本的链接地址，然后使用 wget 命令进行下载，这里下载在 <code>/opt</code> 目录下</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.21.6.tar.gz</span><br></pre></td></tr></table></figure>

<p>这里下载的版本是 1.21.6，请根据需求更改版本号。如果 wget 命令下载速度慢，可以先下载到 Windows 系统，再使用工具上传到 Linux 下。</p>
<ol start="2">
<li>建议大家将下载的资源进行包管理，在 <code>/opt</code> 目录下创建 <code>nginx/core</code> 目录，<code>-p</code> 代表允许创建多级目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建指定目录</span></span><br><span class="line">mkdir -p /opt/nginx/core</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到指定目录</span></span><br><span class="line">mv nginx-1.21.6.tar.gz nginx/core</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入指定目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt/nginx/core</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xzf nginx-1.21.6.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进入资源文件中，发现 configure 文件，执行该文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入解压出的目录</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.21.6/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 configure </span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看 nginx 的安装位置</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master sbin]<span class="comment"># whereis nginx</span></span><br><span class="line">nginx: /usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>启动测试。启动文件在安装目录下的 sbin 命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入启动文件的目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 nginx 文件</span></span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p>访问自己 Linux 的 IP 地址，不需要加端口，如果看到如下图，代表成功</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.6xop32js8180.webp" alt="image"></p>
<h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备 GCC 编译器、PCRE 兼容正则表达式库、zlib 压缩库、OpenSSL 安全通信的软件库包，然后才能进行 Nginx 的安装。下面使用 yum 安装，过程更简单。</p>
<ol>
<li>安装 yum-utils</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum  install -y yum-utils</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加 yum 源文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加如下内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 yum 安装 Nginx</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看是否安装成功</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.36wvsdkk9zc0.webp" alt="image"></p>
<ol start="6">
<li>使用 yum 进行安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yun install -y nginx</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看nginx的安装位置</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>启动测试</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nginx</span></span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.38bsees6wz60.webp" alt="image"></p>
<p>访问自己 Linux 的 IP 地址，不需要加端口，如果看到如下图，代表成功</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.6xop32js8180.webp" alt="image"></p>
<h3 id="源码简单安装和yum安装的差异"><a href="#源码简单安装和yum安装的差异" class="headerlink" title="源码简单安装和yum安装的差异"></a>源码简单安装和yum安装的差异</h3><p>这里先介绍一个命令: <code>./nginx -V</code>，通过该命令可以查看到所安装 Nginx 的版本及相关配置信息。</p>
<p>简单安装的配置信息查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master sbin]<span class="comment"># ./nginx -V</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class="line">configure arguments: --prefix=/usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<p>yum 安装的配置信息查看：（这里截取 1.16.1 版本的 图片）</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.os75hg8w3gg.webp" alt="image"></p>
<p>可以看出 yum 安装的参数非常多，如果想源码简单安装也有这些参数，这涉及到源码复杂安装，往下看。</p>
<p>执行 <code>tar -zxvf nginx-1.16.1.tar.gz</code> 对下载的资源进行解压缩后，进入压缩后的目录，可以看到如下结构</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.320qb912jy00.webp" alt="image"></p>
<p>内容解释：</p>
<table>
<thead>
<tr>
<th>内容名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>存放的是编译相关的脚本</td>
</tr>
<tr>
<td>CHANGES</td>
<td>版本变更记录</td>
</tr>
<tr>
<td>CHANGES.ru</td>
<td>俄罗斯文的版本变更记录</td>
</tr>
<tr>
<td>conf</td>
<td>Nginx 默认的配置文件</td>
</tr>
<tr>
<td>configure</td>
<td>Nginx 软件的自动脚本程序,是一个比较重要的文件，作用如下： 1、检测环境及根据环境检测结果生成 C 代码 2、生成编译代码需要的 Makefile 文件</td>
</tr>
<tr>
<td>contrib</td>
<td>存放的是几个特殊的脚本文件，其中 README 中对脚本有着详细的说明</td>
</tr>
<tr>
<td>html</td>
<td>存放的是 Nginx 自带的两个 html 页面，访问 Nginx 的首页和错误页面</td>
</tr>
<tr>
<td>LICENSE</td>
<td>许可证的相关描述文件</td>
</tr>
<tr>
<td>man</td>
<td>Nginx 的 man 手册</td>
</tr>
<tr>
<td>README</td>
<td>Nginx 的阅读指南</td>
</tr>
<tr>
<td>src</td>
<td>Nginx 的源代码</td>
</tr>
</tbody></table>
<h3 id="源码复杂安装"><a href="#源码复杂安装" class="headerlink" title="源码复杂安装"></a>源码复杂安装</h3><p>这种方式和简单的安装配置不同的地方在第一步，通过 <code>./configure</code> 来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p>
<ul>
<li>PATH：是和路径相关的配置信息</li>
<li>with：是启动模块，默认是关闭的</li>
<li>without：是关闭模块，默认是开启的</li>
</ul>
<p>我们先来认识一些简单的路径配置已经通过这些配置来完成一个简单的编译：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>–prefix=PATH</td>
<td>指向 Nginx 的安装目录</td>
<td>/usr/local/nginx</td>
</tr>
<tr>
<td>–sbin-path=PATH</td>
<td>指向(执行)程序文件(nginx)的路径</td>
<td>&lt;安装目录&gt;/sbin/nginx</td>
</tr>
<tr>
<td>–modules-path=PATH</td>
<td>指向 Nginx 动态模块安装目录</td>
<td>&lt;安装目录&gt;//modules</td>
</tr>
<tr>
<td>–conf-path=PATH</td>
<td>指向配置文件(nginx.conf)的路径</td>
<td>&lt;安装目录&gt;/conf/nginx.conf</td>
</tr>
<tr>
<td>–error-log-path=PATH</td>
<td>指向错误日志文件的路径</td>
<td>&lt;安装目录&gt;/logs/error.log</td>
</tr>
<tr>
<td>–http-log-path=PATH</td>
<td>指向访问日志文件的路径</td>
<td>&lt;安装目录&gt;/logs/access.log</td>
</tr>
<tr>
<td>–pid-path=PATH</td>
<td>指向 Nginx 启动后进行ID的文件路径</td>
<td>&lt;安装目录&gt;/logs/nginx.pid</td>
</tr>
<tr>
<td>–lock-path=PATH</td>
<td>指向 Nginx 锁文件的存放路径</td>
<td>&lt;安装目录&gt;/logs/nginx.lock</td>
</tr>
</tbody></table>
<p>源码复杂安装命令如下：（先进入解压目录）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入解压目</span></span><br><span class="line"><span class="built_in">cd</span> ~/nginx/core</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">--sbin-path=/usr/<span class="built_in">local</span>/nginx/sbin/nginx \</span><br><span class="line">--modules-path=/usr/<span class="built_in">local</span>/nginx/modules \</span><br><span class="line">--conf-path=/usr/<span class="built_in">local</span>/nginx/conf/nginx.conf \</span><br><span class="line">--error-log-path=/usr/<span class="built_in">local</span>/nginx/logs/error.log \</span><br><span class="line">--http-log-path=/usr/<span class="built_in">local</span>/nginx/logs/access.log \</span><br><span class="line">--pid-path=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid \</span><br><span class="line">--lock-path=/usr/<span class="built_in">local</span>/nginx/logs/nginx.lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行编译和安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>在使用上述命令之前，需要将之前服务器已经安装的 Nginx 进行卸载。</p>
<h2 id="Nginx卸载"><a href="#Nginx卸载" class="headerlink" title="Nginx卸载"></a>Nginx卸载</h2><p>简单安装后如果想要卸载，步骤分为三步骤：</p>
<p>步骤一：需要将 Nginx 的进程关闭（要在 安装目录的 sbin 目录下）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure>

<p>步骤二：将安装的 Nginx 进行删除</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<p>步骤三：进入解压目录，将安装包之前编译的环境清除掉</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入解压目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt/nginx/core</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除环境</span></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<h2 id="Nginx目录结构分析"><a href="#Nginx目录结构分析" class="headerlink" title="Nginx目录结构分析"></a>Nginx目录结构分析</h2><p>在使用 Nginx 之前，我们先对安装好的 Nginx 目录文件进行一个分析，在这块给大家介绍一个工具 tree，通过 tree 我们可以很方面的去查看 Centos 系统上的文件目录结构，当然，如果想使用 tree 工具，就得先通过 <code>yum install -y tree</code> 来进行安装，安装成功后，可以通过执行 <code>tree /usr/local/nginx</code> (tree 后面跟的是 Nginx 的安装目录)，获取的结果如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@master /]<span class="comment"># tree /usr/local/nginx</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx</span><br><span class="line">├── client_body_temp</span><br><span class="line">├── conf</span><br><span class="line">│   ├── fastcgi.conf</span><br><span class="line">│   ├── fastcgi.conf.default</span><br><span class="line">│   ├── fastcgi_params</span><br><span class="line">│   ├── fastcgi_params.default</span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.conf</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params</span><br><span class="line">│   ├── scgi_params.default</span><br><span class="line">│   ├── uwsgi_params</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── fastcgi_temp</span><br><span class="line">├── html</span><br><span class="line">│   ├── 50x.html</span><br><span class="line">│   └── index.html</span><br><span class="line">├── logs</span><br><span class="line">│   ├── access.log</span><br><span class="line">│   ├── error.log</span><br><span class="line">│   └── nginx.pid</span><br><span class="line">├── proxy_temp</span><br><span class="line">├── sbin</span><br><span class="line">│   ├── nginx</span><br><span class="line">│   └── nginx.old</span><br><span class="line">├── scgi_temp</span><br><span class="line">└── uwsgi_temp</span><br><span class="line"></span><br><span class="line">9 directories, 22 files</span><br></pre></td></tr></table></figure>

<p> CGI(Common Gateway Interface)通用网关【接口】，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用 CGI【程序】处理及相应结果给客户端的一种标准规范。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>文件名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td></td>
<td>Nginx 所有配置文件目录</td>
</tr>
<tr>
<td></td>
<td>fastcgi.conf</td>
<td>fastcgi相关配置文件</td>
</tr>
<tr>
<td></td>
<td>fastcgi.conf.default</td>
<td>fastcgi.conf 的备份文件</td>
</tr>
<tr>
<td></td>
<td>fastcgi_params</td>
<td>fastcgi 的参数文件</td>
</tr>
<tr>
<td></td>
<td>fastcgi_params.default</td>
<td>fastcgi 的参数备份文件</td>
</tr>
<tr>
<td></td>
<td>scgi_params</td>
<td>scgi 的参数文件</td>
</tr>
<tr>
<td></td>
<td>scgi_params.default</td>
<td>scgi 的参数备份文件</td>
</tr>
<tr>
<td></td>
<td>uwsgi_params</td>
<td>uwsgi 的参数文件</td>
</tr>
<tr>
<td></td>
<td>uwsgi_params.default</td>
<td>uwsgi 的参数备份文件</td>
</tr>
<tr>
<td></td>
<td>mime.types</td>
<td><strong>记录的是 HTTP 协议中的 Content-Type 的值和文件后缀名的对应关系</strong></td>
</tr>
<tr>
<td></td>
<td>mime.types.default</td>
<td>mime.types 的备份文件</td>
</tr>
<tr>
<td></td>
<td>nginx.conf</td>
<td><strong>这是 Nginx 的核心配置文件，这个文件非常重要，也是我们即将要学习的重点</strong></td>
</tr>
<tr>
<td></td>
<td>nginx.conf.default</td>
<td>nginx.conf 的备份文件</td>
</tr>
<tr>
<td></td>
<td>koi-utf、koi-win、win-utf</td>
<td>这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</td>
</tr>
<tr>
<td>html</td>
<td></td>
<td>存放 Nginx 自带的两个静态的 html 页面</td>
</tr>
<tr>
<td></td>
<td>50x.html</td>
<td>访问失败后的失败页面</td>
</tr>
<tr>
<td></td>
<td>index.html</td>
<td>成功访问的默认首页</td>
</tr>
<tr>
<td>logs</td>
<td></td>
<td>记录入门的文件，当 Nginx 服务器启动后，这里面会有 access.log error.log 和 nginx.pid 三个文件出现</td>
</tr>
<tr>
<td></td>
<td>access.log</td>
<td><strong>访问日志，每次访问成功都会进行记录</strong></td>
</tr>
<tr>
<td></td>
<td>error.log</td>
<td><strong>错误日志，每次访问失败都会进行记录</strong></td>
</tr>
<tr>
<td></td>
<td>nginx.pid</td>
<td>启动 Nginx 后，系统生成一个进程 PID，这个文件记录这个 PID</td>
</tr>
<tr>
<td>sbin</td>
<td></td>
<td>是存放执行程序文件 nginx</td>
</tr>
<tr>
<td></td>
<td>nginx</td>
<td>用来控制 Nginx 的启动和停止等相关的命令。<strong>注意：该文件名就叫 nginx</strong></td>
</tr>
</tbody></table>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/49/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><span class="page-number current">50</span><a class="page-number" href="/page/51/">51</a><span class="space">&hellip;</span><a class="page-number" href="/page/76/">76</a><a class="extend next" rel="next" href="/page/51/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>