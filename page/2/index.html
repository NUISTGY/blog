<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">225</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">82</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/26/IO-传统BIO下网络编程/">IO模型-基于BIO的Java网络编程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IO/">IO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>一个 InetAddress 类的对象就代表一个 IP 地址对象</p>
<p>成员方法：</p>
<ul>
<li><code>static InetAddress getLocalHost()</code>：获得本地主机 IP 地址对象</li>
<li><code>static InetAddress getByName(String host)</code>：根据 IP 地址字符串或主机名获得对应的 IP 地址对象</li>
<li><code>String getHostName()</code>：获取主机名</li>
<li><code>String getHostAddress()</code>：获得 IP 地址字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取本机地址对象</span></span><br><span class="line">        InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip.getHostName());<span class="comment">//DESKTOP-NNMBHQR</span></span><br><span class="line">        System.out.println(ip.getHostAddress());<span class="comment">//192.168.11.1</span></span><br><span class="line">        <span class="comment">// 2.获取域名ip对象</span></span><br><span class="line">        InetAddress ip2 = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());<span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.getHostAddress());<span class="comment">//14.215.177.38</span></span><br><span class="line">        <span class="comment">// 3.获取公网IP对象。</span></span><br><span class="line">        InetAddress ip3 = InetAddress.getByName(<span class="string">"182.61.200.6"</span>);</span><br><span class="line">        System.out.println(ip3.getHostName());<span class="comment">//182.61.200.6</span></span><br><span class="line">        System.out.println(ip3.getHostAddress());<span class="comment">//182.61.200.6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.判断是否能通： ping  5s之前测试是否可通</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">5000</span>)); <span class="comment">// ping百度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>UDP（User Datagram Protocol）协议的特点：</p>
<ul>
<li>面向无连接的协议，发送端只管发送，不确认对方是否能收到，速度快，但是不可靠，会丢失数据</li>
<li>尽最大努力交付，没有拥塞控制</li>
<li>基于数据包进行数据传输，发送数据的包的大小限制 <strong>64KB</strong> 以内</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
</ul>
<p>UDP 协议的使用场景：在线视频、网络语音、电话</p>
<h4 id="实现UDP"><a href="#实现UDP" class="headerlink" title="实现UDP"></a>实现UDP</h4><p>UDP 协议相关的两个类：</p>
<ul>
<li>DatagramPacket（数据包对象）：用来封装要发送或要接收的数据，比如：集装箱</li>
<li>DatagramSocket（发送对象）：用来发送或接收数据包，比如：码头</li>
</ul>
<p><strong>DatagramPacket</strong>：</p>
<ul>
<li><p>DatagramPacket 类：</p>
<p><code>public new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：创建发送端数据包对象 </p>
<ul>
<li>buf：要发送的内容，字节数组</li>
<li>length：要发送内容的长度，单位是字节</li>
<li>address：接收端的IP地址对象</li>
<li>port：接收端的端口号</li>
</ul>
<p><code>public new DatagramPacket(byte[] buf, int length)</code>：创建接收端的数据包对象</p>
<ul>
<li>buf：用来存储接收到内容        </li>
<li>length：能够接收内容的长度</li>
</ul>
</li>
<li><p>DatagramPacket 类常用方法：</p>
<ul>
<li><code>public int getLength()</code>：获得实际接收到的字节个数</li>
<li><code>public byte[] getData()</code>：返回数据缓冲区</li>
</ul>
</li>
</ul>
<p><strong>DatagramSocket</strong>：</p>
<ul>
<li>DatagramSocket 类构造方法：<ul>
<li><code>protected DatagramSocket()</code>：创建发送端的 Socket 对象，系统会随机分配一个端口号</li>
<li><code>protected DatagramSocket(int port)</code>：创建接收端的 Socket 对象并指定端口号</li>
</ul>
</li>
<li>DatagramSocket 类成员方法：<ul>
<li><code>public void send(DatagramPacket dp)</code>：发送数据包</li>
<li><code>public void receive(DatagramPacket p)</code>：接收数据包</li>
<li><code>public void close()</code>：关闭数据报套接字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===启动客户端==="</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个集装箱对象，用于封装需要发送的数据包!</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="string">"我学Java"</span>.getBytes();</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer,bubffer.length,InetAddress.getLoclHost,<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个码头对象</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">// 3.开始发送数据包对象</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==启动服务端程序=="</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个接收客户都端的数据包对象（集装箱）</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, bubffer.length);</span><br><span class="line">        <span class="comment">// 2.创建一个接收端的码头对象</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 3.开始接收</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// 4.从集装箱中获取本次读取的数据量</span></span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        <span class="comment">// 5.输出数据</span></span><br><span class="line">        <span class="comment">// String rs = new String(socket.getData(), 0, len)</span></span><br><span class="line">        String rs = <span class="keyword">new</span> String(buffer , <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 6.服务端还可以获取发来信息的客户端的IP和端口。</span></span><br><span class="line">        String ip = packet.getAddress().getHostAdress();</span><br><span class="line">        <span class="keyword">int</span> port = packet.getPort();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>TCP/IP (Transfer Control Protocol) 协议，传输控制协议</p>
<p>TCP/IP 协议的特点：</p>
<ul>
<li>面向连接的协议，提供可靠交互，速度慢</li>
<li>点对点的全双工通信</li>
<li>通过<strong>三次握手</strong>建立连接，连接成功形成数据传输通道；通过<strong>四次挥手</strong>断开连接</li>
<li>基于字节流进行数据传输，传输数据大小没有限制</li>
</ul>
<p>TCP 协议的使用场景：文件上传和下载、邮件发送和接收、远程登录</p>
<p>注意：<strong>TCP 不会为没有数据的 ACK 超时重传</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/三次握手.png" alt="三次握手" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/四次挥手.png" alt="四次挥手" style="zoom: 67%;">

<p>推荐阅读：<a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener">https://yuanrengu.com/2020/77eef79f.html</a></p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>TCP 通信也叫 <strong>Socket 网络编程</strong>，只要代码基于 Socket 开发，底层就是基于了可靠传输的 TCP 通信</p>
<p>双向通信：Java Socket 是全双工的，在任意时刻，线路上存在 <code>A -&gt; B</code> 和 <code>B -&gt; A</code> 的双向信号传输，即使是阻塞 IO，读和写也是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>TCP 协议相关的类：</p>
<ul>
<li>Socket：一个该类的对象就代表一个客户端程序。</li>
<li>ServerSocket：一个该类的对象就代表一个服务器端程序。</li>
</ul>
<p>Socket 类：</p>
<ul>
<li><p>构造方法：</p>
<ul>
<li><p><code>Socket(InetAddress address,int port)</code>：创建流套接字并将其连接到指定 IP 指定端口号</p>
</li>
<li><p><code>Socket(String host, int port)</code>：根据 IP 地址字符串和端口号创建客户端 Socket 对象</p>
<p>注意事项：<strong>执行该方法，就会立即连接指定的服务器，连接成功，则表示三次握手通过</strong>，反之抛出异常</p>
</li>
</ul>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>OutputStream getOutputStream()</code>：获得字节输出流对象</li>
<li><code>InputStream getInputStream()</code>：获得字节输入流对象</li>
<li><code>void shutdownInput()</code>：停止接受</li>
<li><code>void shutdownOutput()</code>：停止发送数据，终止通信</li>
<li><code>SocketAddress getRemoteSocketAddress()</code>：返回套接字连接到的端点的地址，未连接返回 null</li>
</ul>
</li>
</ul>
<p>ServerSocket 类：</p>
<ul>
<li><p>构造方法：<code>public ServerSocket(int port)</code></p>
</li>
<li><p>常用 API：<code>public Socket accept()</code>，<strong>阻塞等待</strong>接收一个客户端的 Socket 管道连接请求，连接成功返回一个 Socket 对象</p>
<p>三次握手后 TCP 连接建立成功，服务器内核会把连接从 SYN 半连接队列（一次握手时在服务端建立的队列）中移出，移入 accept 全连接队列，等待进程调用 accept 函数时把连接取出。如果进程不能及时调用 accept 函数，就会造成 accept 队列溢出，最终导致建立好的 TCP 连接被丢弃</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-TCP三次握手.png" style="zoom:67%;">

</li>
</ul>
<p><strong>相当于</strong>客户端和服务器建立一个数据管道（虚连接，不是真正的物理连接），管道一般不用 close</p>
<h4 id="实现TCP"><a href="#实现TCP" class="headerlink" title="实现TCP"></a>实现TCP</h4><h5 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h5><p>客户端的开发流程：</p>
<ol>
<li>客户端要请求于服务端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输出流</li>
<li>通过字节输出流给服务端写出数据</li>
</ol>
<p>服务端的开发流程：</p>
<ol>
<li>用 ServerSocket 注册端口</li>
<li>接收客户端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输入流</li>
<li>从字节输入流中读取客户端发来的数据</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/TCP-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png" alt></p>
<ul>
<li>如果输出缓冲区空间不够存放主机发送的数据，则会被阻塞，输入缓冲区同理</li>
<li>缓冲区不属于应用程序，属于内核</li>
<li>TCP 从输出缓冲区读取数据会加锁阻塞线程</li>
</ul>
<h5 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h5><p>需求一：客户端发送一行数据，服务端接收一行数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">        ps.println(<span class="string">"我是客户端"</span>);</span><br><span class="line">        ps.flush();<span class="comment">//一般不关闭IO流</span></span><br><span class="line">        System.out.println(<span class="string">"客户端发送完毕~~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">if</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求二：客户端可以反复发送数据，服务端可以反复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求三：实现一个服务端可以同时接收多个客户端的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8080</span>);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> socket.getOutputStream();</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(os);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----服务端启动----"</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">             Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span></span><br><span class="line">            <span class="keyword">new</span> ServerReaderThread(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    privat Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerReaderThread</span><span class="params">(Socket socket)</span></span>&#123;<span class="keyword">this</span>.socket = socket;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = socket.getInputStream();</span><br><span class="line">           	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is))</span><br><span class="line">           )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sout(socket.getRemoteSocketAddress() + <span class="string">":"</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            sout(socket.getRemoteSocketAddress() + <span class="string">"下线了~~~~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述缺点：</p>
<ul>
<li>一个客户端对应一个线程，容易导致资源耗尽</li>
<li>在客户端接入但并未发送消息的情况下，线程空等，浪费资源</li>
</ul>
<h3 id="伪异步"><a href="#伪异步" class="headerlink" title="伪异步"></a>伪异步</h3><h5 id="伪异步-1"><a href="#伪异步-1" class="headerlink" title="伪异步"></a>伪异步</h5><p>一个客户端要一个线程，并发越高系统瘫痪的越快，可以在服务端引入线程池，使用线程池来处理与客户端的消息通信</p>
<ul>
<li><p>优势：不会引起系统的死机，可以控制并发线程的数量</p>
</li>
<li><p>劣势：同时可以并发的线程将受到限制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//创建一个线程池，如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接...."</span>);</span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程名字 = "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/26/IO-Java中的NIO/">IO模型-Java中的NIO</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NIO/">NIO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>NIO的介绍</strong>：</p>
<p>Java NIO（New IO、Java non-blocking IO），从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API，NIO 支持面向缓冲区的、基于通道的 IO 操作，以更加高效的方式进行文件的读写操作</p>
<ul>
<li>NIO 有三大核心部分：<strong>Channel（通道），Buffer（缓冲区），Selector（选择器）</strong></li>
<li>NIO 是非阻塞 IO，传统 IO 的 read 和 write 只能阻塞执行，线程在读写 IO 期间不能干其他事情，比如调用 socket.accept()，如果服务器没有数据传输过来，线程就一直阻塞，而 NIO 中可以配置 Socket 为非阻塞模式</li>
<li>NIO 可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来，根据实际情况可以分配 20 或者 80 个线程来处理，不像之前的阻塞 IO 那样分配 1000 个</li>
</ul>
<p>NIO 和 BIO 的比较：</p>
<ul>
<li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多</p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</p>
<table>
<thead>
<tr>
<th>NIO</th>
<th>BIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向缓冲区（Buffer）</td>
<td>面向流（Stream）</td>
</tr>
<tr>
<td>非阻塞（Non Blocking IO）</td>
<td>阻塞IO(Blocking IO)</td>
</tr>
<tr>
<td>选择器（Selectors）</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>NIO 三大核心部分：Channel (通道)、Buffer (缓冲区)、Selector (选择器)</p>
<ul>
<li><p>Buffer 缓冲区</p>
<p>缓冲区本质是一块可以写入数据、读取数据的内存，<strong>底层是一个数组</strong>，这块内存被包装成 NIO Buffer 对象，并且提供了方法用来操作这块内存，相比较直接对数组的操作，Buffer 的 API 更加容易操作和管理</p>
</li>
<li><p>Channel 通道</p>
<p>Java NIO 的通道类似流，不同的是既可以从通道中读取数据，又可以写数据到通道，流的读写通常是单向的，通道可以非阻塞读取和写入通道，支持读取或写入缓冲区，也支持异步地读写</p>
</li>
<li><p>Selector 选择器</p>
<p>Selector 是一个 Java NIO 组件，能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入，这样一个单独的线程可以管理多个 channel，从而管理多个网络连接，提高效率</p>
</li>
</ul>
<p>NIO 的实现框架：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO%E6%A1%86%E6%9E%B6.png" alt></p>
<ul>
<li>每个 Channel 对应一个 Buffer</li>
<li>一个线程对应 Selector ， 一个 Selector 对应多个 Channel（连接）</li>
<li>程序切换到哪个 Channel 是由事件决定的，Event 是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 是一个内存块 ， 底层是一个数组</li>
<li>数据的读取写入是通过 Buffer 完成的 , BIO 中要么是输入流，或者是输出流，不能双向，NIO 的 Buffer 是可以读也可以写， flip() 切换 Buffer 的工作模式</li>
</ul>
<p>Java NIO 系统的核心在于：通道和缓冲区，通道表示打开的 IO 设备（例如：文件、 套接字）的连接。若要使用 NIO 系统，获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，用于特定基本数据类型的容器，用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer.png" alt></p>
<p><strong>Buffer 底层是一个数组</strong>，可以保存多个相同类型的数据，根据数据类型不同 ，有以下 Buffer 常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer </p>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul>
<li><p>容量（capacity）：作为一个内存块，Buffer 具有固定大小，缓冲区容量不能为负，并且创建后不能更改</p>
</li>
<li><p>限制 （limit）：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写），缓冲区的限制不能为负，并且不能大于其容量。写入模式，limit 等于 buffer 的容量；读取模式下，limit 等于写入的数据量</p>
</li>
<li><p>位置（position）：<strong>下一个要读取或写入的数据的索引</strong>，缓冲区的位置不能为负，并且不能大于其限制</p>
</li>
<li><p>标记（mark）与重置（reset）：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的位置，可以通过调用 reset() 方法恢复到这个 position</p>
</li>
<li><p>位置、限制、容量遵守以下不变式： <strong>0 &lt;= position &lt;= limit &lt;= capacity</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer操作.png" style="zoom:67%;">

</li>
</ul>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><code>static XxxBuffer allocate(int capacity)</code>：创建一个容量为 capacity 的 XxxBuffer 对象</p>
<p>Buffer 基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Buffer clear()</td>
<td>清空缓冲区，不清空内容，将位置设置为零，限制设置为容量</td>
</tr>
<tr>
<td>public Buffer flip()</td>
<td>翻转缓冲区，将缓冲区的界限设置为当前位置，position 置 0</td>
</tr>
<tr>
<td>public int capacity()</td>
<td>返回 Buffer的 capacity 大小</td>
</tr>
<tr>
<td>public final int limit()</td>
<td>返回 Buffer 的界限 limit 的位置</td>
</tr>
<tr>
<td>public Buffer limit(int n)</td>
<td>设置缓冲区界限为 n</td>
</tr>
<tr>
<td>public Buffer mark()</td>
<td>在此位置对缓冲区设置标记</td>
</tr>
<tr>
<td>public final int position()</td>
<td>返回缓冲区的当前位置 position</td>
</tr>
<tr>
<td>public Buffer position(int n)</td>
<td>设置缓冲区的当前位置为n</td>
</tr>
<tr>
<td>public Buffer reset()</td>
<td>将位置 position 重置为先前 mark 标记的位置</td>
</tr>
<tr>
<td>public Buffer rewind()</td>
<td>将位置设为为 0，取消设置的 mark</td>
</tr>
<tr>
<td>public final int remaining()</td>
<td>返回当前位置 position 和 limit 之间的元素个数</td>
</tr>
<tr>
<td>public final boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>public static ByteBuffer wrap(byte[] array)</td>
<td>将一个字节数组包装到缓冲区中</td>
</tr>
<tr>
<td>abstract ByteBuffer asReadOnlyBuffer()</td>
<td>创建一个新的只读字节缓冲区</td>
</tr>
<tr>
<td>public abstract ByteBuffer compact()</td>
<td>缓冲区当前位置与其限制（如果有）之间的字节被复制到缓冲区的开头</td>
</tr>
</tbody></table>
<p>Buffer 数据操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract byte get()</td>
<td>读取该缓冲区当前位置的单个字节，然后位置 + 1</td>
</tr>
<tr>
<td>public ByteBuffer get(byte[] dst)</td>
<td>读取多个字节到字节数组 dst 中</td>
</tr>
<tr>
<td>public abstract byte get(int index)</td>
<td>读取指定索引位置的字节，不移动 position</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(byte b)</td>
<td>将给定单个字节写入缓冲区的当前位置，position+1</td>
</tr>
<tr>
<td>public final ByteBuffer put(byte[] src)</td>
<td>将 src 字节数组写入缓冲区的当前位置</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(int index, byte b)</td>
<td>将指定字节写入缓冲区的索引位置，不移动 position</td>
</tr>
</tbody></table>
<p>提示：”\n”，占用两个字节</p>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<ul>
<li>写入数据到 Buffer</li>
<li>调用 flip()方法，转换为读取模式</li>
<li>从 Buffer 中读取数据</li>
<li>调用 buffer.clear() 方法清除缓冲区（不是清空了数据，只是重置指针）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String str = <span class="string">"seazean"</span>;</span><br><span class="line">		<span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">		ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		System.out.println(<span class="string">"-----------------allocate()----------------"</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//0</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">    buffer.put(str.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"-----------------put()----------------"</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//7</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">"-----------------flip()----------------"</span>);</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">        buffer.get(dst);</span><br><span class="line">        System.out.println(dst.length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//5. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">      	System.out.println(<span class="string">"-----------------clear()----------------"</span>);</span><br><span class="line">      	System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">      	System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">      	System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="粘包拆包"><a href="#粘包拆包" class="headerlink" title="粘包拆包"></a>粘包拆包</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔，但这些数据在接收时，被进行了重新组合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello,world\n</span></span><br><span class="line"><span class="comment">// I'm zhangsan\n</span></span><br><span class="line"><span class="comment">// How are you?\n</span></span><br><span class="line">------ &gt; 黏包，半包</span><br><span class="line"><span class="comment">// Hello,world\nI'm zhangsan\nHo</span></span><br><span class="line"><span class="comment">// w are you?\n</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">"Hello,world\nI'm zhangsan\nHo"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">"w are you?\nhaha!\n"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">int</span> oldLimit = source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据数据的长度设置缓冲区</span></span><br><span class="line">            ByteBuffer target = ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            <span class="comment">// debugAll(target); 访问 buffer 的方法</span></span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问过的数据复制到开头</span></span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Byte Buffer 有两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）</p>
<p>Direct Memory 优点：</p>
<ul>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，使用 native 函数直接分配堆外内存</li>
<li><strong>读写性能高</strong>，读写频繁的场合可能会考虑使用直接内存</li>
<li>大大提高 IO 性能，避免了在 Java 堆和 native 堆来回复制数据</li>
</ul>
<p>直接内存缺点：</p>
<ul>
<li>不能使用内核缓冲区 Page Cache 的缓存优势，无法缓存最近被访问的数据和使用预读功能</li>
<li>分配回收成本较高，不受 JVM 内存回收管理</li>
<li>可能导致 OutOfMemoryError 异常：OutOfMemoryError: Direct buffer memory</li>
<li>回收依赖 System.gc() 的调用，但这个调用 JVM 不保证执行、也不保证何时执行，行为是不可控的。程序一般需要自行管理，成对去调用 malloc、free</li>
</ul>
<p>应用场景：</p>
<ul>
<li>传输很大的数据文件，数据的生命周期很长，导致 Page Cache 没有起到缓存的作用，一般采用直接 IO 的方式</li>
<li>适合频繁的 IO 操作，比如网络并发场景</li>
</ul>
<p>数据流的角度：</p>
<ul>
<li>非直接内存的作用链：本地 IO → 内核缓冲区→ 用户（JVM）缓冲区 →内核缓冲区 → 本地 IO</li>
<li>直接内存是：本地 IO → 直接内存 → 本地 IO</li>
</ul>
<p>JVM 直接内存图解：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存直接缓冲区.png" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存非直接缓冲区.png" style="zoom:50%;">



<h4 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h4><p>堆外内存不受 JVM GC 控制，可以使用堆外内存进行通信，防止 GC 后缓冲区位置发生变化的情况</p>
<p>NIO 使用的 SocketChannel 也是使用的堆外内存，源码解析：</p>
<ul>
<li><p>SocketChannel#write(java.nio.ByteBuffer) → SocketChannelImpl#write(java.nio.ByteBuffer)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         var3 = IOUtil.write(<span class="keyword">this</span>.fd, var1, -<span class="number">1L</span>, nd);</span><br><span class="line">     &#125; <span class="keyword">while</span>(var3 == -<span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IOUtil#write(java.io.FileDescriptor, java.nio.ByteBuffer, long, sun.nio.ch.NativeDispatcher)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="keyword">long</span> var2, NativeDispatcher var4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 【判断是否是直接内存，是则直接写出，不是则封装到直接内存】</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        <span class="comment">// 从堆内buffer拷贝到堆外buffer</span></span><br><span class="line">        ByteBuffer var8 = Util.getTemporaryDirectBuffer(var7);</span><br><span class="line">        var8.put(var1);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 从堆外写到内核缓冲区</span></span><br><span class="line">		<span class="keyword">int</span> var9 = writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读操作相同</p>
</li>
</ul>
<h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><p>直接内存创建 Buffer 对象：<code>static XxxBuffer allocateDirect(int capacity)</code></p>
<p>DirectByteBuffer 源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123; </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配直接内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存赋值</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建回收函数</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分配和回收原理</strong>：</p>
<ul>
<li>使用了 Unsafe 对象的 allocateMemory 方法完成直接内存的分配，setMemory 方法完成赋值</li>
<li>ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory 来释放直接内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存分配的底层原理：Unsafe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_27</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>FileChannel 提供 map 方法返回 MappedByteBuffer 对象，把文件映射到内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射，完成映射后对物理内存的操作会被<strong>同步</strong>到硬盘上</p>
<p>FileChannel 中的成员属性：</p>
<ul>
<li><p>MapMode.mode：内存映像文件访问的方式，共三种：</p>
<ul>
<li><code>MapMode.READ_ONLY</code>：只读，修改得到的缓冲区将导致抛出异常</li>
<li><code>MapMode.READ_WRITE</code>：读/写，对缓冲区的更改最终将写入文件，但此次修改对映射到同一文件的其他程序不一定是可见</li>
<li><code>MapMode.PRIVATE</code>：私用，可读可写，但是修改的内容不会写入文件，只是 buffer 自身的改变</li>
</ul>
</li>
<li><p><code>public final FileLock lock()</code>：获取此文件通道的排他锁</p>
</li>
</ul>
<p>MappedByteBuffer，可以让文件在直接内存（堆外内存）中进行修改，这种方式叫做<strong>内存映射</strong>，可以直接调用系统底层的缓存，没有 JVM 和 OS 之间的复制操作，提高了传输效率，作用：</p>
<ul>
<li><strong>可以用于进程间的通信，能达到共享内存页的作用</strong>，但在高并发下要对文件内存进行加锁，防止出现读写内容混乱和不一致性，Java 提供了文件锁 FileLock，但在父/子进程中锁定后另一进程会一直等待，效率不高</li>
<li>读写那些太大而不能放进内存中的文件，<strong>分段映射</strong></li>
</ul>
<p>MappedByteBuffer 较之 ByteBuffer 新增的三个方法：</p>
<ul>
<li><code>final MappedByteBuffer force()</code>：缓冲区是 READ_WRITE 模式下，对缓冲区内容的修改<strong>强制写入文件</strong></li>
<li><code>final MappedByteBuffer load()</code>：将缓冲区的内容载入物理内存，并返回该缓冲区的引用</li>
<li><code>final boolean isLoaded()</code>：如果缓冲区的内容在物理内存中，则返回真，否则返回假</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读写模式</span></span><br><span class="line">        RandomAccessFile ra = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">// 获取对应的通道</span></span><br><span class="line">        FileChannel channel = ra.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1	FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2	0: 文件映射时的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3	5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        buffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'H'</span>);</span><br><span class="line">        buffer.put(<span class="number">3</span>, (<span class="keyword">byte</span>) <span class="string">'9'</span>);</span><br><span class="line">        buffer.put(<span class="number">5</span>, (<span class="keyword">byte</span>) <span class="string">'Y'</span>);	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        ra.close();</span><br><span class="line">        System.out.println(<span class="string">"修改成功~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从硬盘上将文件读入内存，要经过文件系统进行数据拷贝，拷贝操作是由文件系统和硬件驱动实现。通过内存映射的方法访问硬盘上的文件，拷贝数据的效率要比 read 和 write 系统调用高：</p>
<ul>
<li>read() 是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝</li>
<li>mmap() 也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到共享内存，只进行了一次数据拷贝</li>
</ul>
<p>注意：mmap 的文件映射，在 Full GC 时才会进行释放，如果需要手动清除内存映射文件，可以反射调用 sun.misc.Cleaner 方法</p>
<p>参考文章：<a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">https://www.jianshu.com/p/f90866dcbffc</a></p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>通道（Channel）：表示 IO 源与目标打开的连接，Channel 类似于传统的流，只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer <strong>进行交互</strong></p>
<ol>
<li><p>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
</li>
<li><p>BIO 中的 Stream 是单向的，NIO 中的 Channel 是双向的，可以读操作，也可以写操作</p>
</li>
<li><p>Channel 在 NIO 中是一个接口：<code>public interface Channel extends Closeable{}</code></p>
</li>
</ol>
<p>Channel 实现类：</p>
<ul>
<li><p>FileChannel：用于读取、写入、映射和操作文件的通道，<strong>只能工作在阻塞模式下</strong></p>
<ul>
<li>通过 FileInputStream 获取的 Channel 只能读</li>
<li>通过 FileOutputStream 获取的 Channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
</li>
<li><p>DatagramChannel：通过 UDP 读写网络中的数据通道</p>
</li>
<li><p>SocketChannel：通过 TCP 读写网络中的数据</p>
</li>
<li><p>ServerSocketChannel：可以<strong>监听</strong>新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</p>
<p>提示：ServerSocketChanne 类似 ServerSocket、SocketChannel 类似 Socket</p>
</li>
</ul>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p>获取 Channel 方式：</p>
<ul>
<li>对支持通道的对象调用 <code>getChannel()</code> 方法</li>
<li>通过通道的静态方法 <code>open()</code> 打开并返回指定通道</li>
<li>使用 Files 类的静态方法 <code>newByteChannel()</code> 获取字节通道</li>
</ul>
<p>Channel 基本操作：<strong>读写都是相对于内存来看，也就是缓冲区</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract int read(ByteBuffer dst)</td>
<td>从 Channel 中读取数据到 ByteBuffer，从 position 开始储存</td>
</tr>
<tr>
<td>public final long read(ByteBuffer[] dsts)</td>
<td>将 Channel 中的数据分散到 ByteBuffer[]</td>
</tr>
<tr>
<td>public abstract int write(ByteBuffer src)</td>
<td>将 ByteBuffer 中的数据写入 Channel，从 position 开始写出</td>
</tr>
<tr>
<td>public final long write(ByteBuffer[] srcs)</td>
<td>将 ByteBuffer[] 到中的数据聚集到 Channel</td>
</tr>
<tr>
<td>public abstract long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long newPosition)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>public abstract long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
</tbody></table>
<p><strong>SelectableChannel 的操作 API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SocketChannel accept()</td>
<td>如果通道处于非阻塞模式，没有请求连接时此方法将立即返回 NULL，否则将阻塞直到有新的连接或发生 I/O 错误，<strong>通过该方法返回的套接字通道将处于阻塞模式</strong></td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops)</td>
<td>将通道注册到选择器上，并指定监听事件</td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops, Object att)</td>
<td>将通道注册到选择器上，并在当前通道<strong>绑定一个附件对象</strong>，Object 代表可以是任何类型</td>
</tr>
</tbody></table>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> 		<span class="comment">// 1、字节输出流通向目标文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        <span class="comment">// 2、得到字节输出流对应的通道  【FileChannel】</span></span><br><span class="line">        FileChannel channel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、分配缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="string">"hello,黑马Java程序员！"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4、把缓冲区切换成写出模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">"写数据到文件中！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        <span class="comment">// 2、需要得到文件字节输入流的文件通道</span></span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义一个缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、读取数据到缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 5、读取出缓冲区中的数据并输出即可</span></span><br><span class="line">        String rs = <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,buffer.remaining());</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>Channel 的方法：<strong>sendfile 实现零拷贝</strong></p>
<ul>
<li><p><code>abstract long transferFrom(ReadableByteChannel src, long position, long count)</code>：从给定的可读字节通道将字节传输到该通道的文件中</p>
<ul>
<li>src：源通道</li>
<li>position：文件中要进行传输的位置，必须是非负的 </li>
<li>count：要传输的最大字节数，必须是非负的 </li>
</ul>
</li>
<li><p><code>abstract long transferTo(long position, long count, WritableByteChannel target)</code>：将该通道文件的字节传输到给定的可写字节通道。</p>
<ul>
<li>position：传输开始的文件中的位置; 必须是非负的 </li>
<li>count：要传输的最大字节数; 必须是非负的 </li>
<li>target：目标通道 </li>
</ul>
</li>
</ul>
<p>文件复制的两种方式：</p>
<ol>
<li>Buffer</li>
<li>使用上述两种方法</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"C:\\壁纸.jpg"</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\壁纸new.jpg"</span>);</span><br><span class="line">        <span class="comment">// 得到一个字节字节输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        <span class="comment">// 得到一个字节输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="comment">// 得到的是文件通道</span></span><br><span class="line">        FileChannel isChannel = fis.getChannel();</span><br><span class="line">        FileChannel osChannel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 必须先清空缓冲然后再写入数据到缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 开始读取一次数据</span></span><br><span class="line">            <span class="keyword">int</span> flag = isChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(flag == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 把数据写出到</span></span><br><span class="line">            osChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">"复制完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">   	 	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">   	 	FileChannel isChannel = fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data03.txt"</span>);</span><br><span class="line">    	FileChannel osChannel = fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">    	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">    	FileChannel isChannel = fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data04.txt"</span>);</span><br><span class="line">    	FileChannel osChannel = fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分散聚集"><a href="#分散聚集" class="headerlink" title="分散聚集"></a>分散聚集</h4><p>分散读取（Scatter ）：是指把 Channel 通道的数据读入到多个缓冲区中去</p>
<p>聚集写入（Gathering ）：是指将多个 Buffer 中的数据聚集到 Channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"data01.txt"</span>);</span><br><span class="line">        FileChannel isChannel = is.getChannel();</span><br><span class="line">        <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"data02.txt"</span>);</span><br><span class="line">        FileChannel osChannel = fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义多个缓冲区做数据分散</span></span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        ByteBuffer[] buffers = &#123;buffer1 , buffer2&#125;;</span><br><span class="line">        <span class="comment">// 4、从通道中读取数据分散到各个缓冲区</span></span><br><span class="line">        isChannel.read(buffers);</span><br><span class="line">        <span class="comment">// 5、从每个缓冲区中查询是否有数据读取到了</span></span><br><span class="line">        <span class="keyword">for</span>(ByteBuffer buffer : buffers)&#123;</span><br><span class="line">            buffer.flip();<span class="comment">// 切换到读数据模式</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buffer.array() , <span class="number">0</span> , buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、聚集写入到通道</span></span><br><span class="line">        osChannel.write(buffers);</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">"文件复制~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>选择器（Selector） 是 SelectableChannle 对象的<strong>多路复用器</strong>，Selector 可以同时监控多个通道的状况，利用 Selector 可使一个单独的线程管理多个 Channel，<strong>Selector 是非阻塞 IO 的核心</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Selector.png" alt></p>
<ul>
<li>Selector 能够检测多个注册的通道上是否有事件发生（多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，就获取事件然后针对每个事件进行相应的处理，就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><p>创建 Selector：<code>Selector selector = Selector.open();</code></p>
<p>向选择器注册通道：<code>SelectableChannel.register(Selector sel, int ops, Object att)</code></p>
<ul>
<li>参数一：选择器，指定当前 Channel 注册到的选择器</li>
<li>参数二：选择器对通道的监听事件，监听的事件类型用四个常量表示<ul>
<li>读 : SelectionKey.OP_READ （1）</li>
<li>写 : SelectionKey.OP_WRITE （4）</li>
<li>连接 : SelectionKey.OP_CONNECT （8）</li>
<li>接收 : SelectionKey.OP_ACCEPT （16）</li>
<li>若不止监听一个事件，使用位或操作符连接：<code>int interest = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>
</ul>
</li>
<li>参数三：可以关联一个附件，可以是任何对象</li>
</ul>
<p><strong>Selector API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Selector open()</td>
<td>打开选择器</td>
</tr>
<tr>
<td>public abstract void close()</td>
<td>关闭此选择器</td>
</tr>
<tr>
<td>public abstract int select()</td>
<td><strong>阻塞</strong>选择一组通道准备好进行 I/O 操作的键</td>
</tr>
<tr>
<td>public abstract int select(long timeout)</td>
<td><strong>阻塞</strong>等待 timeout 毫秒</td>
</tr>
<tr>
<td>public abstract int selectNow()</td>
<td>获取一下，<strong>不阻塞</strong>，立刻返回</td>
</tr>
<tr>
<td>public abstract Selector wakeup()</td>
<td>唤醒正在阻塞的 selector</td>
</tr>
<tr>
<td>public abstract Set<selectionkey> selectedKeys()</selectionkey></td>
<td>返回此选择器的选择键集</td>
</tr>
</tbody></table>
<p>SelectionKey API:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract void cancel()</td>
<td>取消该键的通道与其选择器的注册</td>
</tr>
<tr>
<td>public abstract SelectableChannel channel()</td>
<td>返回创建此键的通道，该方法在取消键之后仍将返回通道</td>
</tr>
<tr>
<td>public final Object attachment()</td>
<td>返回当前 key 关联的附件</td>
</tr>
<tr>
<td>public final boolean isAcceptable()</td>
<td>检测此密钥的通道是否已准备好接受新的套接字连接</td>
</tr>
<tr>
<td>public final boolean isConnectable()</td>
<td>检测此密钥的通道是否已完成或未完成其套接字连接操作</td>
</tr>
<tr>
<td>public final boolean isReadable()</td>
<td>检测此密钥的频道是否可以阅读</td>
</tr>
<tr>
<td>public final boolean isWritable()</td>
<td>检测此密钥的通道是否准备好进行写入</td>
</tr>
</tbody></table>
<p>基本步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取通道</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//2.切换非阻塞模式</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3.绑定连接</span></span><br><span class="line">ssChannel.bin(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="comment">//4.获取选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">//5.将通道注册到选择器上，并且指定“监听接收事件”</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<h3 id="NIO实现"><a href="#NIO实现" class="headerlink" title="NIO实现"></a>NIO实现</h3><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li><p>SelectableChannel_API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final SelectableChannel configureBlocking(boolean block)</td>
<td>设置此通道的阻塞模式</td>
</tr>
<tr>
<td>public final SelectionKey register(Selector sel, int ops)</td>
<td>向给定的选择器注册此通道，并选择关注的的事件</td>
</tr>
</tbody></table>
</li>
<li><p>SocketChannel_API：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public static SocketChannel open()</td>
<td>打开套接字通道</td>
</tr>
<tr>
<td align="left">public static SocketChannel open(SocketAddress remote)</td>
<td>打开套接字通道并连接到远程地址</td>
</tr>
<tr>
<td align="left">public abstract boolean connect(SocketAddress remote)</td>
<td>连接此通道的到远程地址</td>
</tr>
<tr>
<td align="left">public abstract SocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getLocalAddress()</td>
<td>返回套接字绑定的本地套接字地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getRemoteAddress()</td>
<td>返回套接字连接的远程套接字地址</td>
</tr>
</tbody></table>
</li>
<li><p>ServerSocketChannel_API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ServerSocketChannel open()</td>
<td>打开服务器套接字通道</td>
</tr>
<tr>
<td>public final ServerSocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址，并配置套接字以监听连接</td>
</tr>
<tr>
<td>public abstract SocketChannel accept()</td>
<td>接受与此通道套接字的连接，通过此方法返回的套接字通道将处于阻塞模式</td>
</tr>
</tbody></table>
<ul>
<li>如果 ServerSocketChannel 处于非阻塞模式，如果没有挂起连接，则此方法将立即返回 null</li>
<li>如果通道处于阻塞模式，如果没有挂起连接将无限期地阻塞，直到有新的连接或发生 I/O 错误</li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>服务端 ：</p>
<ol>
<li><p>获取通道，当客户端连接服务端时，服务端会通过 <code>ServerSocketChannel.accept</code> 得到 SocketChannel </p>
</li>
<li><p>切换非阻塞模式</p>
</li>
<li><p>绑定连接</p>
</li>
<li><p>获取选择器</p>
</li>
<li><p>将通道注册到选择器上，并且指定监听接收事件</p>
</li>
<li><p><strong>轮询式</strong>的获取选择器上已经准备就绪的事件</p>
</li>
</ol>
<p>客户端：</p>
<ol>
<li>获取通道：<code>SocketChannel sc = SocketChannel.open(new InetSocketAddress(HOST, PORT))</code></li>
<li>切换非阻塞模式</li>
<li>分配指定大小的缓冲区：<code>ByteBuffer buffer = ByteBuffer.allocate(1024)</code></li>
<li>发送数据给服务端</li>
</ol>
<p>37 行代码，如果判断条件改为 !=-1，需要客户端 close 一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 2、切换为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3、绑定连接的端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4、获取选择器Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 5、将通道都注册到选择器上去，并且开始指定监听接收事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		<span class="comment">// 6、使用Selector选择器阻塞等待轮已经就绪好的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"----开始新一轮的时间处理----"</span>);</span><br><span class="line">            <span class="comment">// 7、获取选择器中的所有注册的通道中已经就绪好的事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 8、开始遍历这些准备好的事件</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = it.next();<span class="comment">// 提取当前这个事件</span></span><br><span class="line">                <span class="comment">// 9、判断这个事件具体是什么</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 10、直接获取当前接入的客户端通道</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">// 11 、切换成非阻塞模式</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     ByteBuffer buffer = ByteBuffer.allocate(16);</span></span><br><span class="line"><span class="comment">                	 // 将一个 byteBuffer 作为附件【关联】到 selectionKey 上</span></span><br><span class="line"><span class="comment">                	 SelectionKey scKey = sc.register(selector, 0, buffer);</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 12、将本客户端通道注册到选择器</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 13、获取当前选择器上的读就绪事件</span></span><br><span class="line">                    SelectableChannel channel = key.channel();</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) channel;</span><br><span class="line">                    <span class="comment">// 14、读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 获取关联的附件</span></span><br><span class="line">                    <span class="comment">// ByteBuffer buffer = (ByteBuffer) key.attachment();</span></span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress() + <span class="string">":"</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buffer.clear();<span class="comment">// 清除之前的数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 删除当前的 selectionKey，防止重复操作</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 2、切换成非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 3、分配指定缓冲区大小</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、发送数据给服务端</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">"请说："</span>);</span><br><span class="line">            String msg = sc.nextLine();</span><br><span class="line">            buffer.put((<span class="string">"Client："</span> + msg).getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/25/IO-同步异步阻塞非阻塞/">IO模型-同步异步、阻塞非阻塞</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IO/">IO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步描述的是消息通信的机制。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当一个request发送出去以后，会得到一个response，这整个过程就是一个同步调用的过程。哪怕response为空，或者response的返回特别快，但是针对这一次请求而言就是一个同步的调用。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>当一个request发送出去以后，没有得到想要的response，而是通过后面的callback、状态或者通知的方式获得结果。</p>
<p>可以这么理解，对于异步请求分两步：</p>
<ul>
<li><p>a. 调用方发送request没有返回对应的response（可能是一个空的response）</p>
</li>
<li><p>b. 服务提供方将response处理完成以后通过callback的方式通知调用方。</p>
</li>
</ul>
<p>对于a而言是同步操作（调用方请求服务方），对于b而言也是同步操作（服务方回掉调用方）。从请求的目的（调用方发送一个request，希望获得对应的response）来看，这两个步骤拆分开来没有任何意义，需要结合起来看，而这整个过程就是一次异步请求。异步请求有一个最典型的特点：<strong>需要callback、状态或者通知的方式</strong>来告知调用方结果。</p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞描述的是程序在等待调用结果（消息，返回值）时的状态。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>阻塞调用是指调用方发出request的线程因为某种原因（如：等待系统资源）被服务方挂起，当服务方得到response后就唤醒挂起线程，并将response返回给调用方。</p>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>非阻塞调用是指调用方发出request的线程在没有等到结果时不会被挂起，直到得到response后才返回。</p>
<p>阻塞和非阻塞最大的区别就是看调用方线程是否会被挂起。</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="https://i.imgloc.com/2023/06/25/VIvk5U.png" alt="同步阻塞"><br><img src="https://i.imgloc.com/2023/06/25/VIvWrp.png" alt="异步阻塞"><br><img src="https://i.imgloc.com/2023/06/25/VIvCZv.png" alt="同步非阻塞"><br><img src="https://i.imgloc.com/2023/06/25/VIvlO3.png" alt="异步非阻塞"></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
</blockquote>
<ol>
<li>老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</li>
<li>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀<del>~</del>的噪音。</li>
<li>老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</li>
<li>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了</li>
</ol>
<p><strong>所谓同步异步，只是对于水壶而言。</strong><br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
<p><strong>所谓阻塞非阻塞，仅仅对于老张而言。</strong><br>立等的老张，阻塞；看电视的老张，非阻塞。</p>
<p>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/75/">75</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>