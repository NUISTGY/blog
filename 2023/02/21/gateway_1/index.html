<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Gateway—微服务界的Nginx"><meta name="keywords" content="SpringCloud,Nginx,Gateway"><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Gateway—微服务界的Nginx | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Gateway和nginx区别"><span class="toc-number">1.</span> <span class="toc-text">一、Gateway和nginx区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Gateway-路由规则"><span class="toc-number">2.</span> <span class="toc-text">二、Gateway 路由规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-路由"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Predicate"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-过滤器"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、声明路由的几种方式"><span class="toc-number">3.</span> <span class="toc-text">三、声明路由的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-代码声明路由"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 代码声明路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-配置文件来声明路由"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 配置文件来声明路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-动态路由"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 动态路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Gateway-的Predicate"><span class="toc-number">4.</span> <span class="toc-text">四、Gateway 的Predicate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过时间匹配"><span class="toc-number">4.1.</span> <span class="toc-text">通过时间匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-Cookie-匹配"><span class="toc-number">4.2.</span> <span class="toc-text">通过 Cookie 匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-Host-匹配"><span class="toc-number">4.3.</span> <span class="toc-text">通过 Host 匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过请求方式匹配"><span class="toc-number">4.4.</span> <span class="toc-text">通过请求方式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过请求路径匹配"><span class="toc-number">4.5.</span> <span class="toc-text">通过请求路径匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过请求参数匹配"><span class="toc-number">4.6.</span> <span class="toc-text">通过请求参数匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过请求-ip-地址进行匹配"><span class="toc-number">4.7.</span> <span class="toc-text">通过请求 ip 地址进行匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合使用"><span class="toc-number">4.8.</span> <span class="toc-text">组合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过滤器使用"><span class="toc-number">5.</span> <span class="toc-text">过滤器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路由过滤器的种类"><span class="toc-number">5.1.</span> <span class="toc-text">路由过滤器的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#请求头过滤器"><span class="toc-number">5.1.1.</span> <span class="toc-text">请求头过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认过滤器"><span class="toc-number">5.1.2.</span> <span class="toc-text">默认过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">5.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局过滤器作用"><span class="toc-number">5.2.</span> <span class="toc-text">全局过滤器作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义全局过滤器"><span class="toc-number">5.2.1.</span> <span class="toc-text">自定义全局过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤器执行顺序"><span class="toc-number">5.3.</span> <span class="toc-text">过滤器执行顺序</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">225</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">83</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">46</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Gateway—微服务界的Nginx</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Gateway/">Gateway</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><script src="/assets/js/APlayer.min.js"> </script><p><img src="https://i.328888.xyz/2023/02/21/glq4d.png" alt></p>
<h2 id="一、Gateway和nginx区别"><a href="#一、Gateway和nginx区别" class="headerlink" title="一、Gateway和nginx区别"></a>一、Gateway和nginx区别</h2><p>Spring Cloud Gateway（简称 Gateway）。它在微服务架构中扮演的角色是“微服务网关”。</p>
<p>Nginx 和 Gateway 在微服务体系中的分工是不一样的。Gateway 作为更底层的微服务网关，通常是作为外部 Nginx 网关和内部微服务系统之间的桥梁，起了这么一个承上启下的作用。</p>
<p>Gateway 叫“微服务网关”，就说明它自己就是一个微服务。换句话说，它也是 Nacos 服务注册中心的一员。既然 Gateway 能连接到 Nacos，那么就意味着它可以轻松获取到 Nacos 中所有服务的注册表。这样一来，Gateway 就可以根据本地的路由规则，将请求精准无误地送达到每个微服务组件中。</p>
<p>使用 Gateway 有一个显而易见的好处，那就是<strong>高可扩展性</strong>。当你对后台的微服务集群做扩容或缩容的时候，Gateway 可以从 Nacos 注册中心轻松获取所有服务节点的变动，不需要任何额外的配置，一切都在无感知的情况下自然而然地发生。如果使用其他技术方案，你可能还需要花些力气修改 VIP Pool 中的节点列表，将新增的机器手动添加到列表中，还要把移除的机器从列表中删除。</p>
<p>Gateway 的另一个优点就是<strong>高度可定制化</strong>。它提供了一种对开发人员非常友好的方式，可以让你通过 Java 代码去定制各种复杂的路由逻辑，还可以使用 Filter 对请求进行加工。</p>
<h2 id="二、Gateway-路由规则"><a href="#二、Gateway-路由规则" class="headerlink" title="二、Gateway 路由规则"></a>二、Gateway 路由规则</h2><p>Gateway 的路由规则主要有三个部分，分别是路由、谓词和过滤器。我这里画了一张图来表示 Gateway 的路由结构。</p>
<p><img src="https://static001.geekbang.org/resource/image/9a/d2/9acbdyy94fa0415700f465df3b6558d2.jpg?wh=1920x937" alt="img"></p>
<h3 id="2-1-路由"><a href="#2-1-路由" class="headerlink" title="2.1 路由"></a>2.1 路由</h3><p><strong>路由是 Gateway 的一个基本单元</strong>，每个路由都有一个目标地址，这个目标地址就是当前路由规则要调用的目标服务。那么一条路由规则在什么情况下会去调用目标服务呢？这就要看路由的谓词设置了。</p>
<h3 id="2-2-Predicate"><a href="#2-2-Predicate" class="headerlink" title="2.2 Predicate"></a>2.2 Predicate</h3><p><strong>所谓谓词，实际上是路由的判断规则</strong>，一个路由中可以添加多个谓词的组合。如果一个服务请求满足某个路由里设置的所有的谓词规则，那么就说明这个请求是当前路由的心动女神，这时候 Gateway 就会把请求转发到路由中设置的目标地址。</p>
<p>打个比方，你可以为某个路由设置一条谓词规则，约定访问路径的匹配规则为 <code>Path=/bingo/*</code>，在这种情况下只有以 <code>/bingo</code>打头的请求才会被当前路由选中。</p>
<h3 id="2-3-过滤器"><a href="#2-3-过滤器" class="headerlink" title="2.3 过滤器"></a>2.3 过滤器</h3><p>Gateway 在把请求转发给目标地址的过程中，把这个任务全权委托给了 Filter（过滤器）来处理。我用一幅图为你比划一下 Filter 做了什么事儿。</p>
<p><img src="https://static001.geekbang.org/resource/image/3a/19/3ae2c7a6f304aaee9be20e1c6bd9cf19.jpg?wh=1920x982" alt="img"></p>
<p>Gateway 组件使用了一种 FilterChain 的模式对请求进行处理，每一个服务请求（Request）在发送到目标服务之前都要被一串 FilterChain 处理。同理，在 Gateway 接收服务响应（Response）的过程中也会被 FilterChain 处理一把。</p>
<p>Gateway 的过滤器主要分为两种，一种是 GlobalFilter，也就是“<strong>全局过滤器</strong>”；另一种是 GatewayFilter，也就是对指定路由生效的“<strong>局部过滤器</strong>”。</p>
<p>全局过滤器继承自 GlobalFilter 接口，它的作用大多是“例行公事”，也就是一些底层能力的支持。比如，RouteToRequestUrlFilter 这个全局过滤器就是用来解析“目标服务地址”的。</p>
<p>除此之外，Gateway 还有一系列用来做路径转发、请求跨域、WebSocket、WebClient 和 Loadbalancer 功能支持的全局过滤器。如果你想深入了解，可以参考 GatewayAutoConfiguration 的源码，这个类是 Gateway 的自动装配器，里面包含了大量 GlobalFilter 的声明。就算你不做任何配置，项目在初始化的时候也会把一大家子全局过滤器添加到上下文中。</p>
<p>GatewayFilter 也就是局部过滤器，它的功能可就多了。Gateway 提供了一系列的内置过滤器，可以实现对 Request/Response 的修改、请求路径修改、调用重试、限流等等功能。当然了，你也可以通过 Gateway 的扩展接口实现一个自定义过滤器并应用到路由规则中。</p>
<h2 id="三、声明路由的几种方式"><a href="#三、声明路由的几种方式" class="headerlink" title="三、声明路由的几种方式"></a>三、声明路由的几种方式</h2><p>路由是 Gateway 中的一条基本转发规则。网关在启动的时候，必须将这些路由规则加载到上下文中，它才能正确处理服务转发请求。那么网关可以从哪些地方加载路由呢？</p>
<p>Gateway 提供了三种方式来加载路由规则，分别是 Java 代码、yaml 文件和动态路由。</p>
<h3 id="3-1-代码声明路由"><a href="#3-1-代码声明路由" class="headerlink" title="3.1 代码声明路由"></a>3.1 代码声明路由</h3><p>第一种加载方式是 Java 代码声明路由，它是可读性和可维护性最好的方式。你可以使用一种链式编程的 Builder 风格来构造一个 route 对象，比如在下面的例子里，相信就算我不解释，你也能看明白这段代码做的事情。它声明了两个路由，根据 path 的匹配规则将请求转发到不同的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">declare</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> builder.routes()</span><br><span class="line">               .route(route -&gt; route</span><br><span class="line">                       .path(<span class="string">"/gateway/customer/**"</span>)</span><br><span class="line">                       .filters(f -&gt; f.stripPrefix(<span class="number">1</span>)</span><br><span class="line">                       .uri(<span class="string">"lb://customer-serv"</span>)</span><br><span class="line">               ).route(route -&gt; route</span><br><span class="line">                       .path(<span class="string">"/gateway/producer/**"</span>)</span><br><span class="line">                       .filters(f -&gt; f.stripPrefix(<span class="number">1</span>))</span><br><span class="line">                       .uri(<span class="string">"lb://producer-serv"</span>)</span><br><span class="line">               ).build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-配置文件来声明路由"><a href="#3-2-配置文件来声明路由" class="headerlink" title="3.2 配置文件来声明路由"></a>3.2 配置文件来声明路由</h3><p>第二种方式是通过配置文件来声明路由，你可以在 application.yml 文件中组装路由规则。我把前面定义的 Java 路由规则改写成了 yml 版，你可以参考一下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">id001</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://customer-serv</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/gateway/customer/**</span></span><br><span class="line"><span class="attr">          filters:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">StripPrefix=2</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">        - id:</span> <span class="string">id002</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://producer-serv</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/gateway/producer/**</span></span><br><span class="line"><span class="attr">          filters:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<p>不管是 Java 版还是 yml 版，它们都是通过“hardcode”的方式声明的静态路由规则，这些 Route 只会在项目启动后被加载一次。如果你想要在 Gateway 运行期更改路由逻辑，那么就要使用第三种方式：动态路由加载。</p>
<h3 id="3-3-动态路由"><a href="#3-3-动态路由" class="headerlink" title="3.3 动态路由"></a>3.3 动态路由</h3><p>动态路由也有不同的实现方式。如果你在项目中集成了 actuator 服务，那么就可以通过 Gateway 对外开放的 actuator 端点在运行期对路由规则做增删改查。但这种修改只是临时性的，项目重新启动后就会被打回原形，因为这些动态规则并没有持久化到任何地方。</p>
<p>动态路由还有另一种实现方式，是我比较推荐的，那就是借助 Nacos 配置中心来存储路由规则。Gateway 通过监听 Nacos Config 中的文件变动，就可以动态获取 Nacos 中配置的规则，并在本地生效了。</p>
<h2 id="四、Gateway-的Predicate"><a href="#四、Gateway-的Predicate" class="headerlink" title="四、Gateway 的Predicate"></a>四、Gateway 的Predicate</h2><p>说白了 Predicate 就是为了实现一组匹配规则，方便让请求过来找到对应的 Route 进行处理，接下来我们接下 Spring Cloud GateWay 内置几种 Predicate 的使用。</p>
<h3 id="通过时间匹配"><a href="#通过时间匹配" class="headerlink" title="通过时间匹配"></a>通过时间匹配</h3><p>Predicate 支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发。比如我们现在设置只有在 2019 年 1 月 1 日才会转发到我的网站，在这之前不进行转发，我就可以这样配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">time_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">After=2018-01-20T06:06:06+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p>Spring 是通过 ZonedDateTime 来对时间进行的对比，ZonedDateTime 是 Java 8 中日期时间功能里，用于表示带时区的日期与时间信息的类，ZonedDateTime 支持通过时区来设置时间，中国的时区是：<code>Asia/Shanghai</code>。</p>
<p>After Route Predicate 是指在这个时间之后的请求都转发到目标地址。上面的示例是指，请求时间在 2018 年 1 月 20 日 6 点 6 分 6 秒之后的所有请求都转发到地址<code>http://ityouknow.com</code>。<code>+08:00</code>是指时间和 UTC 时间相差八个小时，时间地区为<code>Asia/Shanghai</code>。</p>
<p>添加完路由规则之后，访问地址<code>http://localhost:8080</code>会自动转发到<code>http://ityouknow.com</code>。</p>
<p>Before Route Predicate 刚好相反，在某个时间之前的请求的请求都进行转发。我们把上面路由规则中的 After 改为 Before，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">after_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Before=2018-01-20T06:06:06+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p>就表示在这个时间之前可以进行路由，在这时间之后停止路由，修改完之后重启项目再次访问地址<code>http://localhost:8080</code>，页面会报 404 没有找到地址。</p>
<p>除过在时间之前或者之后外，Gateway 还支持限制路由请求在某一个时间段范围内，可以使用 Between Route Predicate 来实现。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">after_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Between=2018-01-20T06:06:06+08:00[Asia/Shanghai],</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-20</span><span class="attr">T06:06:06+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p>这样设置就意味着在这个时间段内可以匹配到此路由，超过这个时间段范围则不会进行匹配。通过时间匹配路由的功能很酷，可以用在限时抢购的一些场景中。</p>
<h3 id="通过-Cookie-匹配"><a href="#通过-Cookie-匹配" class="headerlink" title="通过 Cookie 匹配"></a>通过 Cookie 匹配</h3><p>Cookie Route Predicate 可以接收两个参数，一个是 Cookie name , 一个是正则表达式，路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">cookie_route</span></span><br><span class="line"><span class="attr">         uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">         predicates:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">Cookie=ityouknow,</span> <span class="string">kee.e</span></span><br></pre></td></tr></table></figure>

<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080 --cookie "ityouknow=kee.e"</span><br></pre></td></tr></table></figure>

<p>则会返回页面代码，如果去掉<code>--cookie &quot;ityouknow=kee.e&quot;</code>，后台汇报 404 错误。</p>
<p>Header Route Predicate 和 Cookie Route Predicate 一样，也是接收 2 个参数，一个 header 中属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">header_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080  -H "X-Request-Id:666666"</span><br></pre></td></tr></table></figure>

<p>则返回页面代码证明匹配成功。将参数<code>-H &quot;X-Request-Id:666666&quot;</code>改为<code>-H &quot;X-Request-Id:neo&quot;</code>再次执行时返回 404 证明没有匹配。</p>
<h3 id="通过-Host-匹配"><a href="#通过-Host-匹配" class="headerlink" title="通过 Host 匹配"></a>通过 Host 匹配</h3><p>Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用<code>.</code>号作为分隔符。它通过参数中的主机地址作为匹配规则。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.ityouknow.com</span></span><br></pre></td></tr></table></figure>

<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080  -H "Host: www.ityouknow.com" </span><br><span class="line">curl http://localhost:8080  -H "Host: md.ityouknow.com"</span><br></pre></td></tr></table></figure>

<p>经测试以上两种 host 均可匹配到 host_route 路由，去掉 host 参数则会报 404 错误。</p>
<h3 id="通过请求方式匹配"><a href="#通过请求方式匹配" class="headerlink" title="通过请求方式匹配"></a>通过请求方式匹配</h3><p>可以通过是 POST、GET、PUT、DELETE 等不同的请求方式来进行路由。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">method_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br></pre></td></tr></table></figure>

<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl 默认是以 GET 的方式去请求</span></span><br><span class="line">curl http://localhost:8080</span><br></pre></td></tr></table></figure>

<p>测试返回页面代码，证明匹配到路由，我们再以 POST 的方式请求测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl 默认是以 GET 的方式去请求</span></span><br><span class="line">curl -X POST http://localhost:8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 404 没有找到，证明没有匹配上路由</span></span><br></pre></td></tr></table></figure>

<h3 id="通过请求路径匹配"><a href="#通过请求路径匹配" class="headerlink" title="通过请求路径匹配"></a>通过请求路径匹配</h3><p>Path Route Predicate 接收一个匹配路径的参数来判断是否走路由。这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p>
<p>处理的:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/foo/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果请求路径符合要求，则此路由将匹配，例如：/foo/1 或者 /foo/bar。</p>
<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/foo/1</span><br><span class="line">curl http://localhost:8080/foo/xx</span><br><span class="line">curl http://localhost:8080/boo/xx</span><br></pre></td></tr></table></figure>

<p>经过测试第一和第二条命令可以正常获取到页面返回值，最后一个命令报 404，证明路由是通过指定路由来匹配。</p>
<h3 id="通过请求参数匹配"><a href="#通过请求参数匹配" class="headerlink" title="通过请求参数匹配"></a>通过请求参数匹配</h3><p>Query Route Predicate 支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">query_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=smile</span></span><br></pre></td></tr></table></figure>

<p>这样配置，只要请求中包含 smile 属性的参数即可匹配路由。</p>
<p>使用 curl 测试，命令行输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:8080?smile=x&amp;id=2</span><br></pre></td></tr></table></figure>

<h3 id="通过请求-ip-地址进行匹配"><a href="#通过请求-ip-地址进行匹配" class="headerlink" title="通过请求 ip 地址进行匹配"></a>通过请求 ip 地址进行匹配</h3><p>Predicate 也支持通过设置某个 ip 区间号段的请求才会路由，RemoteAddr Route Predicate 接受 cidr 符号 (IPv4 或 IPv6) 字符串的列表(最小大小为 1)，例如 192.168.0.1/16 (其中 192.168.0.1 是 IP 地址，16 是子网掩码)。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br></pre></td></tr></table></figure>

<p>可以将此地址设置为本机的 ip 地址进行测试。</p>
<p>果请求的远程地址是 192.168.1.10，则此路由将匹配。</p>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>上面为了演示各个 Predicate 的使用，我们是单个单个进行配置测试，其实可以将各种 Predicate 组合起来一起使用。</p>
<p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">       - id:</span> <span class="string">host_foo_path_headers_to_httpbin</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">http://ityouknow.com</span></span><br><span class="line"><span class="attr">        predicates:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Host=**.foo.org</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/headers</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=foo,</span> <span class="string">ba.</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Query=baz</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">Cookie=chocolate,</span> <span class="string">ch.p</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">After=2018-01-20T06:06:06+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p>各种 Predicates 同时存在于同一个路由时，请求必须同时满足所有的条件才被这个路由匹配。</p>
<blockquote>
<p>一个请求满足多个路由的谓词条件时，请求只会被首个成功匹配的路由转发</p>
</blockquote>
<h2 id="过滤器使用"><a href="#过滤器使用" class="headerlink" title="过滤器使用"></a>过滤器使用</h2><h3 id="路由过滤器的种类"><a href="#路由过滤器的种类" class="headerlink" title="路由过滤器的种类"></a>路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p>
<p><img src="https://i.328888.xyz/2023/02/21/glL2J.png" alt></p>
<h4 id="请求头过滤器"><a href="#请求头过滤器" class="headerlink" title="请求头过滤器"></a>请求头过滤器</h4><p>下面我们以AddRequestHeader 为例来讲解。</p>
<blockquote>
<p>需求：给所有进入userservice的请求添加一个请求头：Truth=gy is freaking awesome!<br>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">user-service</span> </span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">lb://userservice</span> </span><br><span class="line"><span class="attr">        predicates:</span> </span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/user/**</span> </span><br><span class="line"><span class="attr">        filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">gy</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>

<h4 id="默认过滤器"><a href="#默认过滤器" class="headerlink" title="默认过滤器"></a>默认过滤器</h4><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">      - id:</span> <span class="string">user-service</span> </span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">lb://userservice</span> </span><br><span class="line"><span class="attr">        predicates:</span> </span><br><span class="line"><span class="bullet">        -</span> <span class="string">Path=/user/**</span></span><br><span class="line"><span class="attr">      default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">gy</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>过滤器的作用是什么？</p>
<ul>
<li><p>对路由的请求或响应做加工处理，比如添加请求头</p>
</li>
<li><p>配置在路由下的过滤器只对当前路由的请求生效</p>
</li>
</ul>
<p>defaultFilters的作用是什么？</p>
<ul>
<li>对所有路由都生效的过滤器</li>
</ul>
<h3 id="全局过滤器作用"><a href="#全局过滤器作用" class="headerlink" title="全局过滤器作用"></a>全局过滤器作用</h3><blockquote>
<p>在Gateway过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p>
<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p>
</blockquote>
<p>定义方式是实现GlobalFilter接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在filter中编写自定义逻辑，可以实现下列功能：</p>
<ul>
<li>登录状态判断</li>
<li>权限校验</li>
<li>请求限流等</li>
</ul>
<h4 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h4><blockquote>
<p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p>
</blockquote>
<ul>
<li>参数中是否有authorization，</li>
<li>authorization参数值是否为admin</li>
</ul>
<p>如果同时满足则放行，否则拦截</p>
<p><strong>实现</strong></p>
<p>在gateway中定义一个过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gy.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        String auth = params.getFirst(<span class="string">"authorization"</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h3><blockquote>
<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p>
</blockquote>
<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li>
<li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GeYu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuistgy.github.io/2023/02/21/gateway_1/">https://nuistgy.github.io/2023/02/21/gateway_1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuistgy.github.io">Yu's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a><a class="post-meta__tags" href="/tags/Gateway/">Gateway</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5befa2f76de7c6b5" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/02/21/Feign异常处理/"><i class="fa fa-chevron-left">  </i><span>Feign 远程调用异常处理</span></a></div><div class="next-post pull-right"><a href="/2023/02/20/@Primary注解/"><span>Spring之@Primary注解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://pic.syst.eu.org/WechatIMG8673.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>