<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM-记忆集和跨代引用"><meta name="keywords" content="JVM"><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>JVM-记忆集和跨代引用 | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#记忆集"><span class="toc-number">1.</span> <span class="toc-text">记忆集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跨代引用"><span class="toc-number">2.</span> <span class="toc-text">跨代引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是跨代引用？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是跨代引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨代引用所带来的问题"><span class="toc-number">2.2.</span> <span class="toc-text">跨代引用所带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决这个问题"><span class="toc-number">2.3.</span> <span class="toc-text">如何解决这个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#跨代引用假说"><span class="toc-number">2.3.1.</span> <span class="toc-text">跨代引用假说</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案"><span class="toc-number">2.3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卡表"><span class="toc-number">2.4.</span> <span class="toc-text">卡表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#写屏障"><span class="toc-number">2.4.1.</span> <span class="toc-text">写屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#卡表元素如何维护？"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">卡表元素如何维护？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何在对象赋值的一刻去更新卡表？"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">如何在对象赋值的一刻去更新卡表？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#写屏障带来的性能问题"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">写屏障带来的性能问题</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">223</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">82</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">45</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">JVM-记忆集和跨代引用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM/">JVM</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 5 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><script src="/assets/js/APlayer.min.js"> </script><h2 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h2><p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-G1记忆集.png" style="zoom:67%;">

<ul>
<li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li>
<li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li>
</ul>
<p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p>
<ul>
<li>字长精度</li>
<li>对象精度</li>
<li>卡精度(卡表)</li>
</ul>
<p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p>
<p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p>
<ul>
<li>CSet of Young Collection</li>
<li>CSet of Mix Collection</li>
</ul>
<h2 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h2><h3 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h3><p>新生代中的对象持有了老年代中的对象的引用 或 老年代中的对象持有了新生代中对象的引用。</p>
<h3 id="跨代引用所带来的问题"><a href="#跨代引用所带来的问题" class="headerlink" title="跨代引用所带来的问题"></a>跨代引用所带来的问题</h3><p>当进行一次只局限于新生代区域内的垃圾回收(Minor GC)，但是新生代中的对象完全有可能被老年代中的对象所引用。为了找出这个区域中的存活对象，不得不在固定的GC Roots之外，在额外的遍历整个老年代中的对象，来确保可达性分析结果的准确性，反之也是一样，这样就会给内存回收带来很大的负担。</p>
<h3 id="如何解决这个问题"><a href="#如何解决这个问题" class="headerlink" title="如何解决这个问题"></a>如何解决这个问题</h3><h4 id="跨代引用假说"><a href="#跨代引用假说" class="headerlink" title="跨代引用假说"></a>跨代引用假说</h4><p>存在相互引用关系的两个对象应该是倾向于同生共死的。举个例子，如果新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在垃圾收集时同样得以存活，进而在年龄到达阈值后进入老年代中，这时候跨代引用也随之被消除。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>依据这条假说，只有少量对象才会存在跨代引用的问题。因此没有必要为了少量的跨代引用而去扫描整个老年代，也没有必要浪费空间去专门记录没一个对象是否存在及存在哪些跨代引用，只需要在新生代上建立一个全局的数据结构，这个数据结构将老年代划分为若干个小块，每次都只记录老年代中的哪一块内存存在跨代引用。此后每当发生Minor GC时，只有包含了跨代引用的那一小块内存才会被加入到GC Roots中进行扫描。</p>
<p>上述数据结构就被称之为记忆集，可以简单理解为一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。记忆集的记录精度可以分为不同级别，下面展示三种记录精度：</p>
<ul>
<li><p>字长精度：每个记录精确到机器字长，该字包含跨代指针</p>
</li>
<li><p>对象精度：每个记录精确到一个对象，该对象的字段中含有跨代指针</p>
</li>
<li><p>卡精度：每个记录精确到一块内存区域，该区域中含有跨代指针</p>
</li>
</ul>
<blockquote>
<p>其中，第三种卡精度所指的是一种被称之为卡表的实现方式。</p>
</blockquote>
<h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>卡表最简单的形式可以只是一个字节数组。</p>
<p><code>CARD_TABLE[this address &gt;&gt; 9] = 0;</code></p>
<p>字节组CARD_TABLE的每一个元素都对应着其标示的内存区域中一块特定大小的内存块，这个内存块被称之为”卡页”。一般来说，卡页大小都是2的N次幂的字节数，从上述代码中可以看出Hotspot中使用的卡页是2的9次幂，即512字节。</p>
<p>一个卡页内存中通常包含不止一个对象，只要卡页内某个对象的字段存在跨代指针，那就将对应卡表数组对应位置上的元素标示为1，称之为Dirty，没有则标示为0，称之为Clean。在垃圾收集时，只需要筛选出卡表中变脏的元素，就能够找到对应卡页内存块中包含的跨代指针，将其加入到GC Roots中一并扫描。</p>
<p><a href="https://imgloc.com/i/Vw4QPb" target="_blank" rel="noopener"><img src="https://i.imgloc.com/2023/06/07/Vw4QPb.md.png" alt></a></p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><h5 id="卡表元素如何维护？"><a href="#卡表元素如何维护？" class="headerlink" title="卡表元素如何维护？"></a>卡表元素如何维护？</h5><p>当有其他分代区域中的对象引用了本区域的对象时，其对应的卡表元素就应该变脏，变脏的时间点原则上应该发生在引用类型字段被赋值的那一刻。</p>
<h5 id="如何在对象赋值的一刻去更新卡表？"><a href="#如何在对象赋值的一刻去更新卡表？" class="headerlink" title="如何在对象赋值的一刻去更新卡表？"></a>如何在对象赋值的一刻去更新卡表？</h5><p>假设是解释执行的字节码，虚拟机负责每条字节码指令的执行，有充分的时间介入；但是在编译执行的场景中，经过即时编译后得到的代码已经是纯粹的指令流了，这就必须要找到一个在机器码层面的手段，将维护卡表的动作放到没一个赋值操作中。</p>
<p>在HotSpot虚拟机中是通过写屏障技术来维护卡表的。写屏障可以看做是虚拟机层面上对于<strong>“引用类型字段赋值”</strong>这个动作的AOP切面，在引用对象赋值时会产生一个环绕式通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的写屏障叫做写前屏障，在赋值后的写屏障叫做写后屏障。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 引用字段赋值操作    </span></span><br><span class="line">	*field = new_value;    </span><br><span class="line">	<span class="comment">// 写后屏障，在这里完成卡表状态更新    </span></span><br><span class="line">	post_write_barrier(field, new_value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="写屏障带来的性能问题"><a href="#写屏障带来的性能问题" class="headerlink" title="写屏障带来的性能问题"></a>写屏障带来的性能问题</h5><p>应用写屏障后，虚拟机就会为所有的赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表的操作，无论更新的是老年代对新生代对象的引用，每次只要对引用进行了赋值操作，就会判断是否需要更新卡表，从而产生额外的开销，不过这个开销与MinorGC时扫描整个老年代的代价要低的多。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GeYu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuistgy.github.io/2023/06/07/JVM-记忆集和跨代引用/">https://nuistgy.github.io/2023/06/07/JVM-记忆集和跨代引用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuistgy.github.io">Yu's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5befa2f76de7c6b5" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/06/07/JVM-对象标记/"><i class="fa fa-chevron-left">  </i><span>JVM-对象标记</span></a></div><div class="next-post pull-right"><a href="/2023/06/06/JVM-三种垃圾回收策略/"><span>JVM-三种垃圾回收策略</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>