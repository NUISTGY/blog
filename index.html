<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://images5.alphacoders.com/423/423529.jpg"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">225</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">82</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/10/12/RabbitMQ基础/">RabbitMQ基础</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-10-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/RabbitMQ/">RabbitMQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/分布式/">分布式</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p>
<p>我们先来看看什么是同步通讯和异步通讯。如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1686983181054-f2bcce85-1fce-412f-95cd-1ae829f8406f.png#averageHue=%239dce6d&clientId=uf9c47826-2719-4&from=paste&height=613&id=u84c8f02e&originHeight=760&originWidth=1695&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=112976&status=done&style=none&taskId=u779e4d59-c9a8-4b1f-a49f-59c578c4ccd&title=&width=1367.3949141495996" alt="image.png"><br>解读：</p>
<ul>
<li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li>
<li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li>
</ul>
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p>
<p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p>
<p>同步调用的方式我们已经学过了，之前的OpenFeign调用就是。但是：</p>
<ul>
<li>异步调用又该如何实现？</li>
<li>哪些业务适合用异步调用来实现呢？</li>
</ul>
<h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1.同步调用"></a>1.1.同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？<br>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989758652-29a64761-c029-4ec4-91aa-f1fc85de086c.jpeg" alt><br>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p>
<ul>
<li>支付服务需要先调用用户服务完成余额扣减</li>
<li>然后支付服务自己要更新支付流水单的状态</li>
<li>然后支付服务调用交易服务，更新业务订单状态为已支付</li>
</ul>
<p>三个步骤依次执行。<br>这其中就存在3个问题：<br><strong>第一</strong>，<strong>拓展性差</strong><br>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。<br>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？<br>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？</p>
<p>最终你的支付业务会越来越臃肿：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686984472076-c05b2155-3346-40f5-b85e-5961caa998ab.jpeg" alt><br>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p>
<p><strong>第二</strong>，<strong>性能下降</strong><br>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989760653-42e1ae3e-677b-4f27-b55a-eaa259f03ad3.jpeg" alt><br>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</p>
<p><strong>第三，级联失败</strong><br>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的<strong>级联失败</strong>问题。</p>
<p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧。</p>
<p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p>
<p>综上，同步调用的方式存在下列问题：</p>
<ul>
<li>拓展性差</li>
<li>性能下降</li>
<li>级联失败</li>
</ul>
<p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p>
<h2 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2.异步调用"></a>1.2.异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p>
<ul>
<li>消息发送者：投递消息的人，就是原来的调用方</li>
<li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li>
<li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990662733-65b0eac8-f65f-4024-a581-6d5761c4c5a4.jpeg" alt></p>
<p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。</p>
<p>还是以余额支付业务为例：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686990257816-4f0b5ddd-7618-4095-b797-25b92f0bf2a5.jpeg" alt><br>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p>
<p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1686989956210-7c1f451c-0368-4602-b02e-a66f2c0f6deb.jpeg" alt><br>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p>
<p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p>
<p>综上，异步调用的优势包括：</p>
<ul>
<li>耦合度更低</li>
<li>性能更好</li>
<li>业务拓展性强</li>
<li>故障隔离，避免级联失败</li>
</ul>
<p>当然，异步通信也并非完美无缺，它存在下列缺点：</p>
<ul>
<li>完全依赖于Broker的可靠性、安全性和性能</li>
<li>架构复杂，后期维护和调试麻烦</li>
</ul>
<h2 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3.技术选型"></a>1.3.技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.<br>目比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司/社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p>
<h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">Messaging that just works — RabbitMQ</a></p>
<h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1.安装"></a>2.1.安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure>

<p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939432832-7ee45271-f96c-43fa-b0f5-8c01bcdf289f.png#averageHue=%23f8f2f2&clientId=uf6195e90-5366-4&from=paste&height=169&id=u6c039f48&originHeight=188&originWidth=747&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15874&status=done&style=none&taskId=ub0c7a06c-2f63-4bc5-98d6-da0bfc75c32&title=&width=669.5798176232812" alt="image.png"></p>
<p>可以看到在安装命令中有两个映射的端口：</p>
<ul>
<li>15672：RabbitMQ提供的管理控制台的端口</li>
<li>5672：RabbitMQ的消息发送处理接口</li>
</ul>
<p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。" target="_blank" rel="noopener">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</a><br>登录后即可看到管理控制台总览页面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137883587-56417f79-a649-43a5-be88-2ff777d3cd25.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=707&id=u7d848ee1&originHeight=876&originWidth=1572&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=83168&status=done&style=none&taskId=ub505f8cf-075f-462b-bce3-e0df935715d&title=&width=1268.168026574142" alt="image.png"></p>
<p>RabbitMQ对应的架构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687136827222-52374724-79c9-4738-b53f-653cc0805d22.png#averageHue=%23e8d7b3&clientId=u6a529863-cf4b-4&from=paste&height=495&id=ub8dd8df6&originHeight=614&originWidth=1458&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=104273&status=done&style=none&taskId=uc0c132a5-73a3-4024-819f-61241da2511&title=&width=1176.2016429676203" alt="image.png"><br>其中包含几个概念：</p>
<ul>
<li><code>**publisher**</code>：生产者，也就是发送消息的一方</li>
<li><code>**consumer**</code>：消费者，也就是消费消息的一方</li>
<li><code>**queue**</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li>
<li><code>**exchange**</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li>
<li><code>**virtual host**</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li>
</ul>
<p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p>
<h2 id="2-2-收发消息"><a href="#2-2-收发消息" class="headerlink" title="2.2.收发消息"></a>2.2.收发消息</h2><h3 id="2-2-1-交换机"><a href="#2-2-1-交换机" class="headerlink" title="2.2.1.交换机"></a>2.2.1.交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687137953880-08aa9694-6a1e-4337-8bde-5757ec3c33f8.png#averageHue=%23f7f6f6&clientId=u6a529863-cf4b-4&from=paste&height=605&id=u413741e2&originHeight=750&originWidth=1264&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60217&status=done&style=none&taskId=u8611b86c-aa50-46d9-855f-8307a318079&title=&width=1019.6974463038903" alt="image.png"><br>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138031622-ccce4612-954f-42c0-9291-73cf19915e39.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=487&id=u9d211d96&originHeight=604&originWidth=947&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38263&status=done&style=none&taskId=ue134ec0e-ad83-465f-a1b2-97cb7667d75&title=&width=763.9663620647026" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=ubca84480&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925" alt="image.png"><br>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p>
<h3 id="2-2-2-队列"><a href="#2-2-2-队列" class="headerlink" title="2.2.2.队列"></a>2.2.2.队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138308409-be6e1649-af03-4ee7-bee3-8518fd0dca03.png#averageHue=%23f9f8f7&clientId=u6a529863-cf4b-4&from=paste&height=417&id=u398bfe43&originHeight=517&originWidth=1157&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35084&status=done&style=none&taskId=u3b2b568c-e113-4abf-971c-2aea7bfaa4b&title=&width=933.3781213398743" alt="image.png"><br>命名为<code>hello.queue1</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255044231-4b0e0339-c1ab-468a-8a72-9ae1b184594c.png#averageHue=%23f9f6f6&clientId=u1711eaf3-9387-4&from=paste&height=548&id=uf3cb4af4&originHeight=679&originWidth=1163&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=51428&status=done&style=none&taskId=u71f9590b-0cc5-4727-bd4c-65b353c4df7&title=&width=938.2184573191648" alt="image.png"><br>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255204405-523f8053-e414-45f3-99c3-b66de152f79e.png#averageHue=%23f6f5f4&clientId=u1711eaf3-9387-4&from=paste&height=359&id=u956d1947&originHeight=445&originWidth=1074&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=39049&status=done&style=none&taskId=u1eb8bf9f-f74b-4238-a33e-796c4280e78&title=&width=866.4201402930207" alt="image.png"><br>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！<br>怎么回事呢？<br>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p>
<h3 id="2-2-3-绑定关系"><a href="#2-2-3-绑定关系" class="headerlink" title="2.2.3.绑定关系"></a>2.2.3.绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255547460-d87943cd-4309-4778-8e9e-374167a97e45.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=481&id=u04a61731&originHeight=596&originWidth=1022&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=34676&status=done&style=none&taskId=u0ce69958-400b-4c37-89ea-adf0b369080&title=&width=824.4705618058354" alt="image.png"><br>相同的方式，将hello.queue2也绑定到改交换机。<br>最终，绑定结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255624712-7bd850b1-95fd-4d98-8243-57d1779de935.png#averageHue=%23f7f4f4&clientId=u1711eaf3-9387-4&from=paste&height=385&id=u82198db4&originHeight=477&originWidth=978&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=28098&status=done&style=none&taskId=u1394f18f-c109-4688-9eb1-effec6a43fb&title=&width=788.9747646243708" alt="image.png"></p>
<h3 id="2-2-4-发送消息"><a href="#2-2-4-发送消息" class="headerlink" title="2.2.4.发送消息"></a>2.2.4.发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687138163403-839087fe-66f7-4710-a866-210aa0282be8.png#averageHue=%23f9f6f6&clientId=u6a529863-cf4b-4&from=paste&height=616&id=GyhjT&originHeight=763&originWidth=1092&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46085&status=done&style=none&taskId=u5f176fff-eda8-457c-94cd-bb7d6bbd997&title=&width=880.9411482308925" alt="image.png"><br>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255725782-fd5e2550-3572-48c0-9ec0-60786e33a3b1.png#averageHue=%23f5f4f3&clientId=u1711eaf3-9387-4&from=paste&height=319&id=u97a4707c&originHeight=395&originWidth=1051&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=38484&status=done&style=none&taskId=u4d68c013-3032-4d2b-83a0-571c3335780&title=&width=847.8655190390733" alt="image.png"><br>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255765034-69e67460-1535-48b3-8537-da383c498141.png#averageHue=%23f8f7f7&clientId=u1711eaf3-9387-4&from=paste&height=473&id=ua850c29b&originHeight=586&originWidth=974&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35281&status=done&style=none&taskId=u668d2c9f-54a9-4427-adc4-e121a960025&title=&width=785.7478739715103" alt="image.png"><br>可以看到消息到达队列了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687255798153-dda9b729-a3a0-415c-9167-48c525c75800.png#averageHue=%23f9f7f7&clientId=u1711eaf3-9387-4&from=paste&height=466&id=u66fa5450&originHeight=578&originWidth=762&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=33500&status=done&style=none&taskId=u665361c6-23b2-4fc4-b1a9-fdf6c880545&title=&width=614.7226693699085" alt="image.png"><br>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p>
<h2 id="2-3-数据隔离"><a href="#2-3-数据隔离" class="headerlink" title="2.3.数据隔离"></a>2.3.数据隔离</h2><h3 id="2-3-1-用户管理"><a href="#2-3-1-用户管理" class="headerlink" title="2.3.1.用户管理"></a>2.3.1.用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151143347-f7e2aaff-0a14-4022-8d50-582ee75e2998.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=450&id=u2a51a990&originHeight=558&originWidth=1580&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=55212&status=done&style=none&taskId=u18a12c4e-be8d-4ccb-a14a-415a21db44a&title=&width=1274.621807879863" alt="image.png"><br>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p>
<ul>
<li><code>Name</code>：<code>itheima</code>，也就是用户名</li>
<li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li>
<li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li>
</ul>
<p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p>
<ul>
<li>给每个项目创建独立的运维账号，将管理权限分离。</li>
<li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li>
</ul>
<p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151725993-05fe9bd1-8f8b-468d-8456-eac36278bea2.png#averageHue=%23f7f5f5&clientId=uc5430584-57f9-4&from=paste&height=609&id=ua32ca0ae&originHeight=755&originWidth=1569&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=70298&status=done&style=none&taskId=u4f4ed00c-b8dd-4ffd-8a83-75d03c11fb5&title=&width=1265.7478585844967" alt="image.png"><br>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687151853554-e671a696-e9c0-4ff5-9caf-31b39e1a17f5.png#averageHue=%23f7f5f4&clientId=uc5430584-57f9-4&from=paste&height=353&id=ueeaf90c6&originHeight=437&originWidth=927&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=31497&status=done&style=none&taskId=u74d79385-5602-447d-8beb-ed20ec36022&title=&width=747.8319088004005" alt="image.png"><br>别急，接下来我们就来授权。</p>
<h3 id="2-3-2-virtual-host"><a href="#2-3-2-virtual-host" class="headerlink" title="2.3.2.virtual host"></a>2.3.2.virtual host</h3><p>我们先退出登录：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152245922-8438490f-d094-4db1-88fa-a2d916d46a97.png#averageHue=%23f6f5f5&clientId=uc5430584-57f9-4&from=paste&height=374&id=u12c0492e&originHeight=463&originWidth=1571&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=50699&status=done&style=none&taskId=u830f1745-a0ed-4202-9849-7653ebae4c2&title=&width=1267.3613039109268" alt="image.png"><br>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152310566-2531b1c8-b362-47c7-ba81-1b7c1880c18b.png#averageHue=%23f5f4f3&clientId=uc5430584-57f9-4&from=paste&height=409&id=uf51820c2&originHeight=507&originWidth=1565&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=60462&status=done&style=none&taskId=ud7655191-c9d5-4801-9669-55b47348861&title=&width=1262.5209679316363" alt="image.png"><br>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。<br> 我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152363999-edb47263-f303-4ee8-a80d-be55d6b0ed37.png#averageHue=%23f6f5f4&clientId=uc5430584-57f9-4&from=paste&height=553&id=ufc5bd4a7&originHeight=685&originWidth=1555&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=67199&status=done&style=none&taskId=u38a5fe38-fcb5-4163-bee4-ddffaba416b&title=&width=1254.4537412994853" alt="image.png"><br>创建完成后如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152448758-d0a05827-10ac-459b-a92f-495304dddf89.png#averageHue=%23f5f5f4&clientId=uc5430584-57f9-4&from=paste&height=232&id=ue38b9ba4&originHeight=287&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=24622&status=done&style=none&taskId=ue5f326dc-340c-46e0-83d5-84a19fef1d9&title=&width=798.655436582952" alt="image.png"><br>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687152695194-6c2dda94-43c4-4ee9-b95c-ca9d8504cd0c.png#averageHue=%23f7f4f4&clientId=ud5bd9b1f-141b-4&from=paste&height=349&id=u0cf22cf3&originHeight=432&originWidth=890&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30925&status=done&style=none&taskId=u1b04bdb9-ab59-41d9-b2bb-e5f5a0cca59&title=&width=717.9831702614417" alt="image.png"></p>
<p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153236457-ca138f25-b351-4095-8855-aa0df42fae65.png#averageHue=%23f7f5f4&clientId=ud5bd9b1f-141b-4&from=paste&height=223&id=u0989d284&originHeight=277&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=35060&status=done&style=none&taskId=u6ab4f38a-ad0d-48bd-ace7-7f0281755d1&title=&width=1168.1344163354693" alt="image.png"><br>然后再次查看queues选项卡，会发现之前的队列已经看不到了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687153307085-0157ac47-2d89-4f32-ab9a-d513b0e19f25.png#averageHue=%23f9f6f6&clientId=ud5bd9b1f-141b-4&from=paste&height=431&id=u151b88b9&originHeight=534&originWidth=1443&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48526&status=done&style=none&taskId=u7ef6af14-7e3c-4988-8721-80965a310f6&title=&width=1164.1008030193937" alt="image.png"><br>这就是基于<code>virtual host</code>的隔离效果。</p>
<h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAmqp的官方地址：<br><a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener">Spring AMQP</a><br>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息</li>
</ul>
<p>这一章我们就一起学习一下，如何利用SpringAMQP实现对RabbitMQ的消息收发。</p>
<h2 id="3-1-导入Demo工程"><a href="#3-1-导入Demo工程" class="headerlink" title="3.1.导入Demo工程"></a>3.1.导入Demo工程</h2><p>在课前资料给大家提供了一个Demo工程，方便我们学习SpringAMQP的使用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689939402093-e0e0a3d4-84ed-40b5-bedc-0884fcb4ae64.png#averageHue=%23f9f9f8&clientId=uf6195e90-5366-4&from=paste&height=169&id=u1dad7a09&originHeight=188&originWidth=752&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=15464&status=done&style=none&taskId=u1668b30b-b977-4fc3-89ba-6c2e029e374&title=&width=674.0616102445883" alt="image.png"><br>将其复制到你的工作空间，然后用Idea打开，项目结构如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687156248415-3fe7ae5b-302b-4a35-a520-b2419e616862.png#averageHue=%23f9fbf8&clientId=ud5bd9b1f-141b-4&from=paste&height=253&id=u53ed8a5e&originHeight=314&originWidth=664&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=30988&status=done&style=none&taskId=u5ab16e5b-840d-4511-b27b-07f42a60f4c&title=&width=535.6638483748284" alt="image.png"><br>包括三部分：</p>
<ul>
<li>mq-demo：父工程，管理项目依赖</li>
<li>publisher：消息的发送者</li>
<li>consumer：消息的消费者</li>
</ul>
<p>在mq-demo这个父工程中，已经配置好了SpringAMQP相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此，子工程中就可以直接使用SpringAMQP了。</p>
<h2 id="3-2-快速入门"><a href="#3-2-快速入门" class="headerlink" title="3.2.快速入门"></a>3.2.快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261777988-23fff732-dcfa-499a-a8a1-a66328fe05e7.jpeg" alt><br>也就是：</p>
<ul>
<li>publisher直接发送消息到队列</li>
<li>消费者监听并处理队列中的消息</li>
</ul>
<p>:warning:<strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。</p>
<p>为了方便测试，我们现在控制台新建一个队列：simple.queue<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687171932026-33eace5d-c0f2-4070-8742-fe8b34c6c749.png#averageHue=%23f9f8f8&clientId=u0fe93ba5-a0ba-4&from=paste&height=602&id=uec08e673&originHeight=746&originWidth=1219&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=53932&status=done&style=none&taskId=ubdce29f2-6d3c-45cc-8b7f-64627bcf68c&title=&width=983.3949264592106" alt="image.png"><br>添加成功：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687172012283-e19d8da6-8944-4f51-a40b-a15f0814b015.png#averageHue=%23f7f6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=u61761e6f&originHeight=502&originWidth=1187&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=40787&status=done&style=none&taskId=uaf3c44d8-727d-4f46-8ae6-46245932d99&title=&width=957.5798012363273" alt="image.png"><br>接下来，我们就可以利用Java代码收发消息了。</p>
<h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">"simple.queue"</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">"hello, spring amqp!"</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开控制台，可以看到消息已经发送到队列中：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173164620-51a78ccb-b2a1-474b-8147-076f4b8cee12.png#averageHue=%23f8f7f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=431&id=u34a6c895&originHeight=534&originWidth=1267&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=43690&status=done&style=none&taskId=u6fd3cf33-b6c0-42a6-91f3-e263e176174&title=&width=1022.1176142935356" alt="image.png"><br>接下来，我们再来实现消息接收。</p>
<h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"simple.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"spring 消费者接收到消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687173574481-792b9a3c-bcab-4f96-9d09-206cccdd1456.png#averageHue=%23f7f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=405&id=ua133b5cf&originHeight=502&originWidth=1805&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=226083&status=done&style=none&taskId=u72073b8f-ef3f-4ec4-af3e-4187138ca2a&title=&width=1456.134407103261" alt="image.png"></p>
<h2 id="3-3-WorkQueues模型"><a href="#3-3-WorkQueues模型" class="headerlink" title="3.3.WorkQueues模型"></a>3.3.WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3.jpeg" alt></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p>
<p>接下来，我们就来模拟这样的场景。<br>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687179664222-3e226588-63e3-4275-a9e2-cce5c8e93d4c.png#averageHue=%23f5f2f1&clientId=u0fe93ba5-a0ba-4&from=paste&height=321&id=u96998af1&originHeight=398&originWidth=1180&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41883&status=done&style=none&taskId=ubcca08d6-3211-435a-ae7c-10fcf4daafe&title=&width=951.9327425938216" alt="image.png"></p>
<h3 id="3-3-1-消息发送"><a href="#3-3-1-消息发送" class="headerlink" title="3.3.1.消息发送"></a>3.3.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">"simple.queue"</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">"hello, message_"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-消息接收"><a href="#3-3-2-消息接收" class="headerlink" title="3.3.2.消息接收"></a>3.3.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"work.queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到消息：【"</span> + msg + <span class="string">"】"</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"work.queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">"消费者2........接收到消息：【"</span> + msg + <span class="string">"】"</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p>
<ul>
<li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li>
<li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li>
</ul>
<h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a>3.3.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>最终结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br></pre></td></tr></table></figure>

<p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p>
<ul>
<li>消费者1很快完成了自己的25条消息</li>
<li>消费者2却在缓慢的处理自己的25条消息。</li>
</ul>
<p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p>
<h3 id="3-3-4-能者多劳"><a href="#3-3-4-能者多劳" class="headerlink" title="3.3.4.能者多劳"></a>3.3.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    listener:</span></span><br><span class="line"><span class="attr">      simple:</span></span><br><span class="line"><span class="attr">        prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>

<p>再次测试，发现结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2</span>........接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br></pre></td></tr></table></figure>

<p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p>
<h3 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5.总结"></a>3.3.5.总结</h3><p>Work模型的使用：</p>
<ul>
<li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li>
<li>通过设置prefetch来控制消费者预取的消息数量</li>
</ul>
<h2 id="3-4-交换机类型"><a href="#3-4-交换机类型" class="headerlink" title="3.4.交换机类型"></a>3.4.交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：<br><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/27967491/1687264784359-de7cbc4a-ec60-461d-a6a4-3474ba52e0d0.jpeg" alt><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li>
<li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li>
<li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li>
<li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<p>交换机的类型有四种：</p>
<ul>
<li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li>
<li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li>
<li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li>
<li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li>
</ul>
<p>课堂中，我们讲解前面的三种交换机模式。</p>
<h2 id="3-5-Fanout交换机"><a href="#3-5-Fanout交换机" class="headerlink" title="3.5.Fanout交换机"></a>3.5.Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181415478-ea4bb17b-48bf-4303-9242-27703efb39d8.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=389&id=u41b3ec34&originHeight=482&originWidth=1598&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=84491&status=done&style=none&taskId=u0db849d5-c734-41f3-87c2-d1fe9ec7575&title=&width=1289.1428158177346" alt="image.png"></p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  生产者发送的消息，只能发送到交换机</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息</li>
</ul>
<p>我们的计划是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182474076-2b479229-56a6-4163-93c4-a6a7187f3dbe.png#averageHue=%23f9f4f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=248&id=ue59e0d8c&originHeight=308&originWidth=1314&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48827&status=done&style=none&taskId=u7d52896e-f59b-494d-bb25-b376c96414e&title=&width=1060.0335794646453" alt="image.png"></p>
<ul>
<li>创建一个名为<code>hmall.fanout</code>的交换机，类型是<code>Fanout</code></li>
<li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li>
</ul>
<h3 id="3-5-1-声明队列和交换机"><a href="#3-5-1-声明队列和交换机" class="headerlink" title="3.5.1.声明队列和交换机"></a>3.5.1.声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946886137-0bcb8641-faf1-4bea-b553-4b3bb96d224c.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=380&id=ub435a220&originHeight=424&originWidth=1117&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=31069&status=done&style=none&taskId=uf02d05dd-b916-4d37-b2f4-dba06eff8a9&title=&width=1001.2324716000069" alt="image.png"><br>在创建一个队列<code>fanout.queue2</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689946949922-c4e442c3-568b-4164-a327-74e30aa9b9d0.png#averageHue=%23f8f6f5&clientId=uf6195e90-5366-4&from=paste&height=380&id=u452ddf31&originHeight=424&originWidth=916&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=29357&status=done&style=none&taskId=u657c70e9-017c-4339-98e0-2d408950262&title=&width=821.0644082234613" alt="image.png"><br>然后再创建一个交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948003779-ea99bac6-6b84-48f3-9760-a719ba5f0c2e.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=359&id=ud456637e&originHeight=401&originWidth=886&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22862&status=done&style=none&taskId=uba3f2a17-5520-43f0-abd4-2eec22a7c3a&title=&width=794.1736524956187" alt="image.png"><br>然后绑定两个队列到交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947064113-23e123ec-a601-4af4-a44f-70f7b4ef4063.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=527&id=u2d63999d&originHeight=588&originWidth=978&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34267&status=done&style=none&taskId=uc512438d-9693-44f1-9c35-33917ddbced&title=&width=876.6386367276695" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947695506-5346b816-61c7-4bfe-a28d-db261b3598c5.png#averageHue=%23f8f7f7&clientId=uf6195e90-5366-4&from=paste&height=537&id=u17bcbe41&originHeight=599&originWidth=985&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34532&status=done&style=none&taskId=u17b49cc4-004f-4e31-bd46-bdef7fe19a1&title=&width=882.9131463974993" alt="image.png"></p>
<h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">"hmall.fanout"</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">"hello, everyone!"</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">""</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-消息接收"><a href="#3-5-3-消息接收" class="headerlink" title="3.5.3.消息接收"></a>3.5.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.queue1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到Fanout消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"fanout.queue2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者2接收到Fanout消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-总结"><a href="#3-5-4-总结" class="headerlink" title="3.5.4.总结"></a>3.5.4.总结</h3><p>交换机的作用是什么？</p>
<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，消息丢失</li>
<li>FanoutExchange的会将消息路由到每个绑定的队列</li>
</ul>
<h2 id="3-6-Direct交换机"><a href="#3-6-Direct交换机" class="headerlink" title="3.6.Direct交换机"></a>3.6.Direct交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182404437-027a5191-b037-4033-baab-6bafd998161d.png#averageHue=%23fbf5f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=uf5b6a678&originHeight=533&originWidth=1686&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=93278&status=done&style=none&taskId=ud6ffb209-4207-40a6-a7ab-4977cab3b5d&title=&width=1360.1344101806637" alt="image.png"><br>在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><strong>案例需求如图</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182519270-885589ec-7f4a-492a-ab78-cddf109121cc.png#averageHue=%23fbf6f6&clientId=u0fe93ba5-a0ba-4&from=paste&height=430&id=u4dde4f59&originHeight=533&originWidth=1362&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=64401&status=done&style=none&taskId=u62c673b4-a71b-40bf-af49-a8c1a4df0de&title=&width=1098.7562672989704" alt="image.png"></p>
<ol>
<li>声明一个名为<code>hmall.direct</code>的交换机</li>
<li>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></li>
<li>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></li>
<li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 </li>
<li>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息 </li>
</ol>
<h3 id="3-6-1-声明队列和交换机"><a href="#3-6-1-声明队列和交换机" class="headerlink" title="3.6.1.声明队列和交换机"></a>3.6.1.声明队列和交换机</h3><p>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code>，这里不再展示过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689947864231-5ace5d74-fdac-4a2a-9f92-180df06fe4ad.png#averageHue=%23f2f0ef&clientId=uf6195e90-5366-4&from=paste&height=403&id=u292b8851&originHeight=450&originWidth=1157&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=56948&status=done&style=none&taskId=uf110e543-1005-4b1a-b23e-d8529df3c0c&title=&width=1037.0868125704637" alt="image.png"><br>然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948033525-e6ea1134-c2ef-4b80-86b2-b364c1301335.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=367&id=u0964090b&originHeight=409&originWidth=871&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=22938&status=done&style=none&taskId=u127085fa-3898-488f-afef-52a7cbf9e2d&title=&width=780.7282746316974" alt="image.png"><br>然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948151280-bed1019d-7d60-455b-95b8-754e266edf50.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=523&id=uf5aa7079&originHeight=583&originWidth=942&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=35339&status=done&style=none&taskId=u31d3c033-0a9a-446f-9ebc-a90405ba47d&title=&width=844.3697298542583" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948181033-6b1e6556-0110-4ed8-a2cb-8bc2dd388903.png#averageHue=%23f8f6f6&clientId=uf6195e90-5366-4&from=paste&height=522&id=u4e6a2147&originHeight=582&originWidth=874&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34608&status=done&style=none&taskId=u274e41ea-73f2-4da5-bc23-fed091d234d&title=&width=783.4173502044816" alt="image.png"></p>
<p>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略，最终结果：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948243879-c97a0e6f-807a-4bc3-ad53-032c378008f3.png#averageHue=%23f4f4f3&clientId=uf6195e90-5366-4&from=paste&height=515&id=ufb0f0d5d&originHeight=575&originWidth=834&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=37957&status=done&style=none&taskId=uaae894e6-bc07-4e01-bf1f-53561ffd05a&title=&width=747.5630092340249" alt="image.png"></p>
<h3 id="3-6-2-消息接收"><a href="#3-6-2-消息接收" class="headerlink" title="3.6.2.消息接收"></a>3.6.2.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"direct.queue1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到direct.queue1的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"direct.queue2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者2接收到direct.queue2的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-消息发送"><a href="#3-6-3-消息发送" class="headerlink" title="3.6.3.消息发送"></a>3.6.3.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">"hmall.direct"</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！"</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">"red"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用的red这个key，所以两个消费者都收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182883516-906024ce-6ade-4dcd-8b4e-2b0cfc1bd03a.png#averageHue=%23f7f9f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=136&id=uc0e2efee&originHeight=168&originWidth=1410&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=85796&status=done&style=none&taskId=u4ab862c3-bb61-4a97-87d8-ac463218ab2&title=&width=1137.4789551332954" alt="image.png"><br>我们再切换为blue这个key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">"hmall.direct"</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">"最新报道，哥斯拉是居民自治巨型气球，虚惊一场！"</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">"blue"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现，只有消费者1收到了消息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687182898732-afba28a8-c57e-4ccb-a330-9e3315879b31.png#averageHue=%23f7f9f4&clientId=u0fe93ba5-a0ba-4&from=paste&height=175&id=udcac360f&originHeight=217&originWidth=1237&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=99781&status=done&style=none&taskId=ua85a2eca-9806-4a15-997d-ee3c73528b6&title=&width=997.9159343970824" alt="image.png"></p>
<h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给哪个队列</li>
<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>
</ul>
<h2 id="3-7-Topic交换机"><a href="#3-7-Topic交换机" class="headerlink" title="3.7.Topic交换机"></a>3.7.Topic交换机</h2><h3 id="3-7-1-说明"><a href="#3-7-1-说明" class="headerlink" title="3.7.1.说明"></a>3.7.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。<br>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p>
<p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p>
<p>通配符规则：</p>
<ul>
<li><code>#</code>：匹配一个或多个词</li>
<li><code>*</code>：匹配不多不少恰好1个词</li>
</ul>
<p>举例：</p>
<ul>
<li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li>
<li><code>item.*</code>：只能匹配<code>item.spu</code></li>
</ul>
<p>图示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183148068-ad50ba76-0024-460b-9b24-3cf7a0fe172e.png#averageHue=%23f9f4f3&clientId=u0fe93ba5-a0ba-4&from=paste&height=305&id=u74a65bd0&originHeight=378&originWidth=1337&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=57084&status=done&style=none&taskId=u90f6bfb4-4f10-4ebe-8edb-70856565f27&title=&width=1078.5882007185928" alt="image.png"><br>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p>
<ul>
<li><code>china.news</code>代表有中国的新闻消息；</li>
<li><code>china.weather</code> 代表中国的天气消息；</li>
<li><code>japan.news</code> 则代表日本新闻；</li>
<li><code>japan.weather</code> 代表日本的天气消息；</li>
</ul>
<p>解释：</p>
<ul>
<li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul>
<li><code>china.news</code></li>
<li><code>china.weather</code></li>
</ul>
</li>
<li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul>
<li><code>china.news</code></li>
<li><code>japan.news</code></li>
</ul>
</li>
</ul>
<p>接下来，我们就按照上图所示，来演示一下Topic交换机的用法。<br>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689948475987-05bab459-43b6-47ad-bbfc-faf9f50d776e.png#averageHue=%23f5f5f4&clientId=uf6195e90-5366-4&from=paste&height=419&id=u3d545ee6&originHeight=468&originWidth=879&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=32637&status=done&style=none&taskId=u1bf5deb0-6b33-48e6-9d9d-d273a1be805&title=&width=787.8991428257888" alt="image.png"></p>
<h3 id="3-7-2-消息发送"><a href="#3-7-2-消息发送" class="headerlink" title="3.7.2.消息发送"></a>3.7.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">"hmall.topic"</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">"喜报！孙悟空大战哥斯拉，胜!"</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">"china.news"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3-消息接收"><a href="#3-7-3-消息接收" class="headerlink" title="3.7.3.消息接收"></a>3.7.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.queue1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到topic.queue1的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"topic.queue2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者2接收到topic.queue2的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-4-总结"><a href="#3-7-4-总结" class="headerlink" title="3.7.4.总结"></a>3.7.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p>
<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
<h2 id="3-8-声明队列和交换机"><a href="#3-8-声明队列和交换机" class="headerlink" title="3.8.声明队列和交换机"></a>3.8.声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p>
<h3 id="3-8-1-基本API"><a href="#3-8-1-基本API" class="headerlink" title="3.8.1.基本API"></a>3.8.1.基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945200636-5f4a823f-6f36-4088-9b67-7b9b3ae48079.png#averageHue=%23f9fcf7&clientId=uf6195e90-5366-4&from=paste&height=241&id=u2a7bba30&originHeight=269&originWidth=930&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=42392&status=done&style=none&taskId=uf1b5d62e-4e09-4ba8-a011-f8345dac005&title=&width=833.6134275631213" alt="image.png"></p>
<p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687181804385-c500bc13-9f81-4071-ad8a-598fa5f57d97.png#averageHue=%23f8f8f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=379&id=Qewqz&originHeight=470&originWidth=1469&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=23466&status=done&style=none&taskId=u357861af-c5aa-43c4-aafd-97dadaf8714&title=&width=1185.0755922629864" alt="image.png"><br>我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945421476-fe44bf9a-d6eb-4f51-af02-374359c8e70b.png#averageHue=%23f8f7f5&clientId=uf6195e90-5366-4&from=paste&height=278&id=uae4334fe&originHeight=310&originWidth=781&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=34426&status=done&style=none&taskId=uc1b7bc5b-68b9-4ce9-afe5-9eb733e8f4b&title=&width=700.0560074481696" alt="image.png"><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1689945503733-13d2179c-f586-4de5-b18c-d3b5749f1f96.png#averageHue=%23dcab6a&clientId=uf6195e90-5366-4&from=paste&height=145&id=u91096ccd&originHeight=162&originWidth=659&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=16128&status=done&style=none&taskId=u1da153f0-6e86-45b2-900b-8f83e489358&title=&width=590.7002674882763" alt="image.png"></p>
<h3 id="3-8-2-fanout示例"><a href="#3-8-2-fanout示例" class="headerlink" title="3.8.2.fanout示例"></a>3.8.2.fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机(consumer启动后会根据声明创建好队列和交换机)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"hmall.fanout"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.queue1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.queue2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-direct示例"><a href="#3-8-2-direct示例" class="headerlink" title="3.8.2.direct示例"></a>3.8.2.direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">"hmall.direct"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"direct.queue1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">"red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">"blue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"direct.queue2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">"red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">"yellow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-4-基于注解声明"><a href="#3-8-4-基于注解声明" class="headerlink" title="3.8.4.基于注解声明"></a>3.8.4.基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p>
<p>例如，我们同样声明Direct模式的交换机和队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">    value = <span class="meta">@Queue</span>(name = <span class="string">"direct.queue1"</span>),</span><br><span class="line">    exchange = <span class="meta">@Exchange</span>(name = <span class="string">"hmall.direct"</span>, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;<span class="string">"red"</span>, <span class="string">"blue"</span>&#125;</span><br><span class="line">))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到direct.queue1的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">    value = <span class="meta">@Queue</span>(name = <span class="string">"direct.queue2"</span>),</span><br><span class="line">    exchange = <span class="meta">@Exchange</span>(name = <span class="string">"hmall.direct"</span>, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;<span class="string">"red"</span>, <span class="string">"yellow"</span>&#125;</span><br><span class="line">))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者2接收到direct.queue2的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是简单多了。<br>再试试Topic模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">    value = <span class="meta">@Queue</span>(name = <span class="string">"topic.queue1"</span>),</span><br><span class="line">    exchange = <span class="meta">@Exchange</span>(name = <span class="string">"hmall.topic"</span>, type = ExchangeTypes.TOPIC),</span><br><span class="line">    key = <span class="string">"china.#"</span></span><br><span class="line">))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者1接收到topic.queue1的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">    value = <span class="meta">@Queue</span>(name = <span class="string">"topic.queue2"</span>),</span><br><span class="line">    exchange = <span class="meta">@Exchange</span>(name = <span class="string">"hmall.topic"</span>, type = ExchangeTypes.TOPIC),</span><br><span class="line">    key = <span class="string">"#.news"</span></span><br><span class="line">))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者2接收到topic.queue2的消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-消息转换器"><a href="#3-9-消息转换器" class="headerlink" title="3.9.消息转换器"></a>3.9.消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183652317-82b0319b-03aa-46ed-afbc-373e7a6fa0f1.png#averageHue=%23f6f9f5&clientId=u0fe93ba5-a0ba-4&from=paste&height=394&id=u2c63fbb1&originHeight=488&originWidth=1448&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=122291&status=done&style=none&taskId=u0da81780-720e-4c27-9c2f-c24d7dc0123&title=&width=1168.1344163354693" alt="image.png"><br>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>我们来测试一下。</p>
<h3 id="3-9-1-测试默认转换器"><a href="#3-9-1-测试默认转换器" class="headerlink" title="3.9.1.测试默认转换器"></a>3.9.1.测试默认转换器</h3><p>1）创建测试队列<br>首先，我们在consumer服务中声明一个新的配置类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687183868403-242aa812-a07f-4748-8863-dc5d1e161dc1.png#averageHue=%23f9fbf8&clientId=u0fe93ba5-a0ba-4&from=paste&height=351&id=u77b665f4&originHeight=435&originWidth=1053&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=48481&status=done&style=none&taskId=uf6d36991-ec76-497c-93d3-3e96d9d6590&title=&width=849.4789643655035" alt="image.png"><br>利用@Bean的方式创建一个队列，具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">objectQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"object.queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p>
<p>重启consumer服务以后，该队列就会被自动创建出来了：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184033157-c4c8e59e-a2b3-4b2b-9c20-ca3c597e556c.png#averageHue=%23f3f0ef&clientId=u0fe93ba5-a0ba-4&from=paste&height=456&id=u7c3fdb16&originHeight=565&originWidth=1196&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=72445&status=done&style=none&taskId=u03cddb0f-41a3-483d-83c7-d53a5ecb269&title=&width=964.8403052052632" alt="image.png"></p>
<p>2）发送消息<br>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">"name"</span>, <span class="string">"柳岩"</span>);</span><br><span class="line">    msg.put(<span class="string">"age"</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"object.queue"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息后查看控制台：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687184206574-69117533-5b4e-4172-b254-23130023f711.png#averageHue=%23f9f7f7&clientId=u0fe93ba5-a0ba-4&from=paste&height=528&id=u038b25c3&originHeight=654&originWidth=1244&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=46749&status=done&style=none&taskId=u8bea522c-fa98-48f1-bd84-1acfb50fff8&title=&width=1003.5629930395882" alt="image.png"><br>可以看到消息格式非常不友好。</p>
<h3 id="3-9-2-配置JSON转换器"><a href="#3-9-2-配置JSON转换器" class="headerlink" title="3.9.2.配置JSON转换器"></a>3.9.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p>
<p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    Jackson2JsonMessageConverter jackson2JsonMessageConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p>
<p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1687245684217-8b401cc5-29e6-4d08-9a9b-4fbe0dffd486.png#averageHue=%23f9f7f7&clientId=ucdd993b6-34bc-4&from=paste&height=432&id=ue5acc96b&originHeight=535&originWidth=990&originalType=binary&ratio=1.2395833730697632&rotation=0&showTitle=false&size=41352&status=done&style=none&taskId=u158a691b-c3b3-4103-993a-3064dc7139b&title=&width=798.655436582952" alt="image.png"></p>
<h3 id="3-9-3-消费者接收Object"><a href="#3-9-3-消费者接收Object" class="headerlink" title="3.9.3.消费者接收Object"></a>3.9.3.消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"object.queue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"消费者接收到object.queue消息：【"</span> + msg + <span class="string">"】"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-业务改造"><a href="#4-业务改造" class="headerlink" title="4.业务改造"></a>4.业务改造</h1><p>案例需求：改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用，改为基于RabbitMQ的异步通知。如图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690336853591-c874697b-688c-464e-8797-8162a02701e8.png#averageHue=%23faf3f3&clientId=u2c434c61-ffda-4&from=paste&height=396&id=ud83a0c53&originHeight=442&originWidth=1282&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=66835&status=done&style=none&taskId=uac12f07b-6953-4628-933f-82655332fb7&title=&width=1149.1316281031413" alt="image.png"><br>说明，我们只关注交易服务，步骤如下：</p>
<ul>
<li>定义topic类型交换机，命名为<code>pay.topic</code></li>
<li>定义消息队列，命名为<code>mark.order.pay.queue</code></li>
<li>将<code>mark.order.pay.queue</code>与<code>pay.topic</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li>
<li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.topic</code>，发送消息的<code>RoutingKey</code>  为<code>pay.success</code>，消息内容是订单id</li>
<li>交易服务监听<code>mark.order.pay.queue</code>队列，接收到消息后更新订单状态为已支付</li>
</ul>
<h2 id="4-1-配置MQ"><a href="#4-1-配置MQ" class="headerlink" title="4.1.配置MQ"></a>4.1.配置MQ</h2><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：<br>1）添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）配置MQ地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">    virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>

<h2 id="4-1-接收消息"><a href="#4-1-接收消息" class="headerlink" title="4.1.接收消息"></a>4.1.接收消息</h2><p>在trade-service服务中定义一个消息监听类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/27967491/1690339169409-cf6a9ad7-c364-4a26-992d-dd678f53e910.png#averageHue=%23f9fbf8&clientId=u2c434c61-ffda-4&from=paste&height=362&id=uc197e23b&originHeight=404&originWidth=899&originalType=binary&ratio=1.115625023841858&rotation=0&showTitle=false&size=38311&status=done&style=none&taskId=u11e78c89-237d-4689-a03a-1caed96b8fe&title=&width=805.8263133110172" alt="image.png"><br>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayStatusListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(name = <span class="string">"mark.order.pay.queue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(name = <span class="string">"pay.topic"</span>, type = ExchangeTypes.TOPIC),</span><br><span class="line">            key = <span class="string">"pay.success"</span></span><br><span class="line">    ))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenPaySuccess</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-发送消息"><a href="#4-2-发送消息" class="headerlink" title="4.2.发送消息"></a>4.2.发送消息</h2><p>修改<code>pay-service</code>服务下的<code>com.hmall.pay.service.impl.PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    PayOrder po = getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizIllegalException(<span class="string">"交易已支付或关闭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="keyword">boolean</span> success = markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizIllegalException(<span class="string">"交易已支付或关闭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    <span class="comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"pay.topic"</span>, <span class="string">"pay.success"</span>, po.getBizOrderNo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"支付成功的消息发送失败，支付单id：&#123;&#125;， 交易单id：&#123;&#125;"</span>, po.getId(), po.getBizOrderNo(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/09/22/Zookeeper/">Zookeeper</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Zookeeper/">Zookeeper</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/分布式/">分布式</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Zookeeper/">Zookeeper</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="简介-快速入门"><a href="#简介-快速入门" class="headerlink" title="简介/快速入门"></a>简介/快速入门</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.</span><br></pre></td></tr></table></figure>

<p><code>ZooKeeper</code>是一个集中的服务，用于维护配置信息、命名、提供分布式同步和提供组服务。所有这些类型的服务都以某种形式被分布式应用程序使用。每次它们被实现时，都会有大量的工作来修复不可避免的错误和竞争条件。由于实现这些服务的困难，应用程序最初通常会略过这些服务，这使得它们在出现更改时变得脆弱，并且难以管理。即使正确地执行了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性</p>
<p><code>zookeeper</code>由雅虎研究院开发,是<code>Google Chubby</code>的开源实现,后来托管到 <code>Apache</code>,于<code>2010年11月</code>正式成为<code>apache</code>的顶级项目</p>
<p>大数据生态系统里由很多组件的命名都是某些动物或者昆虫，比如<code>hadoop</code>大象，<code>hive</code>就是蜂巢，<code>zookeeper</code>即管理员，顾名思义就算管理大数据生态系统各组件的管理员，如下所示：</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPTUu.png" alt></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><code>zookeepepr</code>是一个经典的<strong>分布式</strong>数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用,且具有严格顺序访问控制能力的分布式协调存储服务。</p>
<ul>
<li>维护配置信息</li>
<li>分布式锁服务</li>
<li>集群管理</li>
<li>生成分布式唯一ID</li>
</ul>
<ol>
<li><p><strong>维护配置信息</strong></p>
<ul>
<li><p><code>java</code>编程经常会遇到配置项，比如数据库的<code>url</code>、 <code>schema</code>、<code>user</code>和 <code>password</code>等。通常这些配置项我们会放置在配置文件中，再将配置文件放置在服务器上当需要更改配置项时，需要去服务器上修改对应的配置文件。</p>
<p>但是随着分布式系统的兴起,由于许多服务都需要使用到该配置文件,因此有<strong>必须保证该配置服务的高可用性</strong>(<code>highavailability</code>)和各台服务器上配置数据的一致性。</p>
<p>通常会将配置文件部署在一个集群上，然而一个<strong>集群动辄上千台</strong>服务器，此时如果再一台台服务器逐个修改配置文件那将是非常繁琐且危险的的操作，因此就<strong>需要一种服务</strong>，<strong>能够高效快速且可靠地完成配置项的更改等操作</strong>，并能够保证各配置项在每台服务器上的数据一致性。</p>
<p><strong><code>zookeeper</code>就可以提供这样一种服务</strong>，其使用<code>Zab</code>这种一致性协议来保证一致性。现在有很多开源项目使用<code>zookeeper</code>来维护配置，如在 <code>hbase</code>中，客户端就是连接一个 <code>zookeeper</code>，获得必要的 <code>hbase</code>集群的配置信息，然后才可以进一步操作。还有在开源的消息队列 <code>kafka</code>中，也便用<code>zookeeper</code>来维护 <code>brokers</code>的信息。在 <code>alibaba</code>开源的<code>soa</code>框架<code>dubbo</code>中也广泛的使用<code>zookeeper</code>管理一些配置来实现服务治理。</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPEhT.png" alt></p>
</li>
</ul>
</li>
<li><p>分布式锁服务</p>
<ul>
<li>一个集群是一个分布式系统，由多台服务器组成。为了提高并发度和可靠性，多台服务器上运行着同一种服务。当多个服务在运行时就需要协调各服务的进度，有时候需要保证当某个服务在进行某个操作时，其他的服务都不能进行该操作，即对该操作进行加锁，如果当前机器挂掉后，释放锁并 <code>fail over</code>到其他的机器继续执行该服务</li>
</ul>
</li>
<li><p>集群管理</p>
<ul>
<li><p>一个集群有时会因为各种软硬件故障或者网络故障，出现棊些服务器挂掉而被移除集群，而某些服务器加入到集群中的情况，<code>zookeeper</code>会将这些服务器加入/移出的情况通知给集群中的其他正常工作的服务器，以及时调整存储和计算等任务的分配和执行等。此外<code>zookeeper</code>还会对故障的服务器做出诊断并尝试修复。</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PP9Pl.png" alt></p>
</li>
</ul>
</li>
<li><p>生产分布式唯一ID</p>
<ul>
<li><p>在过去的单库单表型系统中，通常可以使用数据库字段自带的<code>auto_ increment</code>属性来自动为每条记录生成一个唯一的<code>ID</code>。但是分库分表后，就无法在依靠数据库的<code>auto_ Increment</code>属性来唯一标识一条记录了。此时我们就可以用<code>zookeeper</code>在分布式环境下生成全局唯一<code>ID</code>。</p>
<p>做法如下:每次要生成一个新<code>id</code>时，创建一个持久顺序节点，创建操作返回的节点序号，即为新<code>id</code>，然后把比自己节点小的删除即可</p>
</li>
</ul>
</li>
</ol>
<h4 id="Zookeeper的设计目标"><a href="#Zookeeper的设计目标" class="headerlink" title="Zookeeper的设计目标"></a>Zookeeper的设计目标</h4><p><code>zooKeeper</code>致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务</p>
<ol>
<li>高性能<ul>
<li><code>zookeeper</code>将全量数据存储在<strong>内存</strong>中，并直接服务于客户端的所有非事务请求，尤其用于以读为主的应用场景</li>
</ul>
</li>
<li>高可用<ul>
<li><code>zookeeper</code>一般以集群的方式对外提供服务，一般<code>3~5</code>台机器就可以组成一个可用的 <code>Zookeeper</code>集群了，每台机器都会在内存中维护当前的服务器状态，井且每台机器之间都相互保持着通信。只要集群中超过一半的机器都能够正常工作，那么整个集群就能够正常对外服务</li>
</ul>
</li>
<li>严格顺序访问<ul>
<li>对于来自客户端的每个更新请求，<code>Zookeeper</code>都会分配一个全局唯一的递增编号，这个编号反应了所有事务操作的先后顺序</li>
</ul>
</li>
</ol>
<h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p><code>zookeeper</code>的数据结点可以视为树状结构(或目录)，树中的各个结点被称为<code>znode</code>(即<code>zookeeper node</code>)，一个<code>znode</code>可以由多个子结点。<code>zookeeper</code>结点在结构上表现为树状；</p>
<p>使用路径<code>path</code>来定位某个<code>znode</code>，比如<code>/ns-1/itcast/mysqml/schemal1/table1</code>，此处<code>ns-1，itcast、mysql、schemal1、table1</code>分别是<code>根结点、2级结点、3级结点以及4级结点</code>；其中<code>ns-1</code>是<code>itcast</code>的父结点，<code>itcast</code>是<code>ns-1</code>的子结点，<code>itcast</code>是<code>mysql</code>的父结点….以此类推</p>
<p><code>znode</code>，间距文件和目录两种特点，即像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPG6d.png" alt></p>
<p>那么如何描述一个<code>znode</code>呢？一个<code>znode</code>大体上分为<code>3</code>个部分：</p>
<ul>
<li>结点的数据：即<code>znode data</code>(结点<code>path</code>，结点<code>data</code>)的关系就像是<code>Java map</code>中的 <code>key value</code>关系</li>
<li>结点的子结点<code>children</code></li>
<li>结点的状态<code>stat</code>：用来描述当前结点的创建、修改记录，包括<code>cZxid</code>、<code>ctime</code>等</li>
</ul>
<h4 id="结点状态stat的属性"><a href="#结点状态stat的属性" class="headerlink" title="结点状态stat的属性"></a>结点状态stat的属性</h4><p>在<code>zookeeper shell</code>中使用 <code>get</code>命令查看指定路径结点的<code>data</code>、<code>stat</code>信息</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPaG2.png" alt></p>
<p>属性说明：</p>
<p>结点的各个属性如下。其中重要的概念是<code>Zxid(Zookeeper Transaction ID)</code>，<code>Zookeeper</code>结点的每一次更改都具有唯一的<code>Zxid</code>，如果<code>Zxid-1</code> 小于<code>Zxid-2</code> ，则<code>Zxid-1</code> 的更改发生在 <code>Zxid-2</code>更改之前</p>
<p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_zkDataModel_znodes" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_zkDataModel_znodes</a></p>
<ul>
<li><code>cZxid</code>数据结点创建时的事务ID——针对于<code>zookeeper</code>数据结点的管理：我们对结点数据的一些写操作都会导致<code>zookeeper</code>自动地为我们去开启一个事务，并且自动地去为每一个事务维护一个事务<code>ID</code></li>
<li><code>ctime</code>数据结点创建时的时间</li>
<li><code>mZxid</code>数据结点最后一次更新时的事务ID</li>
<li><code>mtime</code>数据结点最后一次更新时的时间</li>
<li><code>pZxid</code>数据节点最后一次修改此<code>znode</code>子节点更改的<code>zxid</code></li>
<li><code>cversion</code>子结点的更改次数</li>
<li><code>dataVersion</code>结点数据的更改次数</li>
<li><code>aclVersion</code>结点的ACL更改次数——类似<code>linux</code>的权限列表，维护的是当前结点的权限列表被修改的次数</li>
<li><code>ephemeralOwner</code>如果结点是临时结点，则表示创建该结点的会话的<code>SessionID</code>；如果是持久结点，该属性值为0</li>
<li><code>dataLength</code>数据内容的长度</li>
<li><code>numChildren</code>数据结点当前的子结点个数</li>
</ul>
<p><strong>结点类型</strong></p>
<p><code>zookeeper</code>中的结点有两种，分别为<strong>临时结点</strong>和<strong>永久结点</strong>。结点的类型在创建时被确定，并且不能改变</p>
<ul>
<li>临时节点：<ul>
<li>该节点的生命周期依赖于创建它们的会话。一旦会话( <code>Session</code>）结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的 <code>Znode</code>都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，<code>Zookeeper</code>的临时节点不允许拥有子节点</li>
</ul>
</li>
<li>持久化结点：<ul>
<li>该结点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，它们才能被删除</li>
</ul>
</li>
</ul>
<h4 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h4><p>测试系统环境<code>centos7.3</code></p>
<p><code>zookeeper:zookeeper-3.4.10.tar.gz</code></p>
<p><code>jdk:jdk-8u131-linux-x64.tar.gz</code></p>
<p><a href="http://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">http://archive.apache.org/dist/zookeeper/</a></p>
<ol>
<li><p>在<code>centos</code>中使用 <code>root</code>用户创建 <code>zookeeper</code>用户，用户名:<code>zookeeper</code>密码:<code>zookeeper</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd zookeeper</span><br><span class="line">passwd zookeeper</span><br><span class="line">su zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zookeeper</code>底层依赖于jdk，<code>zookeeper</code>用户登录后，根目录下先进行jdk 的安装，jdk使用 <code>jdk-8u131-linux-x64.tar.gz</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置jdk 环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">JAVA_HOME=/home/zookeeper/jdk1.8.0_131</span><br><span class="line">export JAVA_HOME</span><br><span class="line"></span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">souce /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测jdk安装</p>
<p><code>java -version</code> // 如果反馈了Java信息，则成功</p>
</li>
<li><p><code>zookeeper</code> 上传解压</p>
<p><code>tar -zxf tar.gz</code></p>
</li>
<li><p>为<code>zookeeper</code>准备配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入conf目录</span></span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制配置文件</span></span><br><span class="line">cp zoo_sampe.cfg zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> zookeeper 根目录下创建data目录</span></span><br><span class="line">mkdir data</span><br><span class="line"><span class="meta">#</span><span class="bash"> vi 配置文件中的dataDir</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此路径用于存储zookeeper中数据的内存快照、及事务日志文件，虽然zookeeper是使用内存的，但是需要持久化一些数据来保证数据的安全，和redis一样</span></span><br><span class="line">dataDir=/home/zookeeper/zookeeper-3.4.10/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>zookeeper</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入zookeeper的bin目录</span></span><br><span class="line">cd /home/zookeeper/zookeeper-3.4.10/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动zookeeper</span></span><br><span class="line">./zkServer.sh start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动: zkServer.sh start</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止: zkServer.sh stop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态：zkServer.sh status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入zookeeper 内部</span></span><br><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="常用shell命令"><a href="#常用shell命令" class="headerlink" title="常用shell命令"></a>常用shell命令</h4><p><code>zookeeper</code>——<code>getting started</code>——<a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_FileManagement" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_FileManagement</a></p>
<h5 id="操作结点"><a href="#操作结点" class="headerlink" title="操作结点"></a>操作结点</h5><p><strong>查询</strong></p>
<p><code>get /hadoop</code>  查看结点的数据和属性     <code>stat /hadoop</code> 查看结点的属性</p>
<p><strong>创建</strong></p>
<p>创建结点并写入数据：</p>
<p><code>create [-s] [-e] path data</code> # 其中 -s 为有序结点，-e 临时结点（默认是持久结点）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create /hadoop "123456"  # 此时，如果quit退出后再./ZkCient.sh 登入</span><br><span class="line">                         # 再用输入 get /hadoop 获取，结点依然存在(永久结点)</span><br><span class="line">				       </span><br><span class="line">create -s /a "a"         # 创建一个持久化有序结点，创建的时候可以观察到返回的数据带上了一个id       </span><br><span class="line">create -s /b "b"         # 返回的值，id递增了</span><br><span class="line"></span><br><span class="line">create -s -e /aa "aa"    # 依然还会返回自增的id，quit后再进来，继续创建，id依然是往后推的</span><br><span class="line"></span><br><span class="line">create /aa/xx            # 继续创建结点，可以看到pZxid变化了</span><br></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<p>更新结点的命令是<code>set</code>，可以直接进行修改，如下：</p>
<p><code>set path [version]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set /hadoop "345"        # 修改结点值</span><br><span class="line"></span><br><span class="line">set /hadoop "hadoop-x" 1 # 也可以基于版本号进行更改，类似于乐观锁，当传入版本号(dataVersion)</span><br><span class="line">                         # 和当前结点的数据版本号不一致时，zookeeper会拒绝本次修改</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<p>删除结点的语法如下：</p>
<p><code>delete path [version]</code> 和 <code>set</code> 方法相似，也可以传入版本号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete /hadoop           # 删除结点</span><br><span class="line">delete /hadoop 1         # 乐观锁机制，与set 方法一致</span><br></pre></td></tr></table></figure>

<p>要想删除某个结点及其所有后代结点，可以使用递归删除，命令为 <code>rmr path</code></p>
<p><strong>查看结点列表</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls /hadoop               # 可以查看结点的列表</span><br><span class="line">ls2 /hadoop              # 可以查看结点的列表以及目标结点的信息</span><br><span class="line"></span><br><span class="line">ls /                     # 根节点</span><br></pre></td></tr></table></figure>

<p><strong>监听器get path [watch] | stat path [watch]</strong> </p>
<p>使用<code>get path [watch]</code> 注册的监听器能够在结点<strong>内容发生改变</strong>的时候，向客户端发出通知。需要注意的是<code>zookeeper</code>的触发器是一次性的(<code>One-time trigger</code>)，即触发一次后就会立即失效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get /hadoop watch        # get 的时候添加监听器，当值改变的时候，监听器返回消息</span><br><span class="line">set /hadoop 45678        # 测试</span><br></pre></td></tr></table></figure>

<p><strong>ls\ls2 path [watch]</strong></p>
<p>使用 <code>ls path [watch] 或 ls2 path [watch]</code>注册的监听器能够监听该结点下<strong>所有子节点</strong>的<strong>增加</strong>和<strong>删除</strong>操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /hadoop watch         # 添加监听器</span><br><span class="line">set /hadoop/node "node"</span><br></pre></td></tr></table></figure>

<h3 id="zookeeper的Acl权限控制"><a href="#zookeeper的Acl权限控制" class="headerlink" title="zookeeper的Acl权限控制"></a>zookeeper的Acl权限控制</h3><p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_ZooKeeperAccessControl" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_ZooKeeperAccessControl</a></p>
<p><code>zookeeper</code>类似文件系统，<code>client</code>可以创建结点、更新结点、删除结点，那么如何做到结点的权限控制呢？</p>
<p><code>zookeeper</code>的 <code>access control list</code> 访问控制列表可以做到这一点</p>
<p><code>acl</code>权限控制，使用<code>scheme：id：permission</code>来标识，主要涵盖3个方面：</p>
<p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_BuiltinACLSchemes" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_BuiltinACLSchemes</a></p>
<ul>
<li>权限模式(<code>scheme</code>)：授权的策略</li>
<li>授权对象(<code>id</code>)：授权的对象</li>
<li>权限(<code>permission</code>)：授予的权限</li>
</ul>
<p>其特性如下：</p>
<ul>
<li><p><code>zookeeper</code>的权限控制是基于每个<code>znode</code>结点的，需要对每个结点设置权限</p>
</li>
<li><p>每个<code>znode</code>支持多种权限控制方案和多个权限</p>
</li>
<li><p>子结点不会继承父结点的权限，客户端无权访问某结点，但可能可以访问它的子结点：</p>
<p>例如<code>setAcl /test2 ip:192.168.133.133:crwda</code>  // 将结点权限设置为Ip：192.168.133.133 的客户端可以对节点进行<br>增删改查和管理权限</p>
</li>
</ul>
<p><strong>权限模式</strong></p>
<ul>
<li><p>采用何种方式授权</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>world</td>
<td>只有一个用户：<code>anyone</code>，代表登录<code>zookeeper</code>所有人(默认)</td>
</tr>
<tr>
<td>ip</td>
<td>对客户端使用IP地址认证</td>
</tr>
<tr>
<td>auth</td>
<td>使用已添加认证的用户认证</td>
</tr>
<tr>
<td>digest</td>
<td>使用”用户名：密码”方式认证</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>授权对象</strong></p>
<ul>
<li>给谁授予权限</li>
<li>授权对象ID是指，权限赋予的实体，例如：IP地址或用户</li>
</ul>
<p><strong>授权的权限</strong></p>
<ul>
<li><p>授予什么权限</p>
</li>
<li><p><code>create、delete、read、writer、admin</code>也就是 增、删、查、改、管理权限，这5种权限简写为 c d r w a，注意：<br>这五种权限中，有的权限并不是对结点自身操作的例如：delete是指对<strong>子结点</strong>的删除权限</p>
<p>可以试图删除父结点，但是子结点必须删除干净，所以<code>delete</code>的权限也是很有用的</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>ACL简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>c</td>
<td>可以创建子结点</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>可以删除子结点(仅下一级结点)</td>
</tr>
<tr>
<td>read</td>
<td>r</td>
<td>可以读取结点数据以及显示子结点列表</td>
</tr>
<tr>
<td>write</td>
<td>w</td>
<td>可以设置结点数据</td>
</tr>
<tr>
<td>admin</td>
<td>a</td>
<td>可以设置结点访问控制权限列表</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>授权的相关命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>使用方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getAcl</td>
<td>getAcl</td>
<td>读取ACL权限</td>
</tr>
<tr>
<td>setAcl</td>
<td>setAcl</td>
<td>设置ACL权限</td>
</tr>
<tr>
<td>addauth</td>
<td>addauth</td>
<td>添加认证用户</td>
</tr>
</tbody></table>
<h4 id="案例-远程登录"><a href="#案例-远程登录" class="headerlink" title="案例/远程登录"></a>案例/远程登录</h4><p><strong><code>./zkServer.sh -server 192.168.133.133</code></strong> 可以远程登录</p>
<p><strong>world权限模式</strong></p>
<ul>
<li><code>getAcl /node</code> // 读取权限信息</li>
<li><code>setAcl /node world:anyone:drwa</code> // 设置权限(禁用创建子结点的权限)</li>
</ul>
<p><strong>ip模式</strong></p>
<p><code>./zkServer.sh -server 192.168.133.133</code> 可以远程登录</p>
<ul>
<li><code>setAcl /hadoop ip:192.168.133.133:drwa</code></li>
<li>如果在两台不同的虚拟机中，另一台用远程连接的模式，进行上面这条命令，那么只会有一台被授权</li>
<li>需要两台虚拟机一起授权的话需要用<strong>逗号</strong>将授权列表隔开：<code>setAcl /hadoop ip:192.168.133.133:cdrwa,ip:192.168.133.132:cdrwa</code></li>
</ul>
<p><strong>auth认证用户模式</strong></p>
<p><strong><code>addauth digest &lt;user&gt;:&lt;password&gt;</code></strong></p>
<p><strong><code>setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;acl&gt;</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create /hadoop "hadoop"           # 初始化测试用的结点</span><br><span class="line">addauth digest itcast:123456      # 添加认证用户</span><br><span class="line">setAcl /hadoop auth:itcast:cdrwa  # 设置认证用户</span><br><span class="line">quit                              # 退出后再./zkCli.sh 进入</span><br><span class="line">get /hadoop                       # 这个时候就没有权限了，需要再次认证</span><br><span class="line">addauth digest itcast:123456      # 认证，密码错了的话 zookeeper 不会报错，但是不能认证</span><br><span class="line">get /hadoop</span><br></pre></td></tr></table></figure>

<p><strong>Digest授权模式</strong></p>
<p><strong><code>setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password&gt;:&lt;acl&gt;</code></strong></p>
<p>这里的密码是经过<code>SHA1</code>以及<code>BASE64</code>处理的密文，在shell 中可以通过以下命令计算：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 计算密码</span></span><br><span class="line">echo -n itcast:12345 | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取密码，设置权限列表</span></span><br><span class="line">setAcl /hadoop digest:itcast:qUFSHxJjItUW/93UHFXFVGlvryY=:cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在想要get /hadoop 需要登录了</span></span><br><span class="line">addauth digest itcast:12345</span><br><span class="line">get /hadoop</span><br></pre></td></tr></table></figure>

<p><strong>多种授权模式</strong></p>
<p>仅需逗号隔开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /hadoop ip:192.168.133.132:cdrwa,auth:hadoop:cdrwa,digest:itcast:673OfZhUE8JEFMcu0l64qI8e5ek=:cdrwa</span><br></pre></td></tr></table></figure>

<h4 id="acl-超级管理员"><a href="#acl-超级管理员" class="headerlink" title="acl 超级管理员"></a>acl 超级管理员</h4><ul>
<li><p><code>zookeeper</code>的权限管理模式有一种叫做<code>super</code>，该模式提供一个超管，可以方便的访问任何权限的节点</p>
<p>假设这个超管是<code>supper:admin</code>，需要为超管生产密码的密文</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n super:admin | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么打开<code>zookeeper</code>目录下<code>/bin/zkServer.sh</code>服务器脚本文件，找到如下一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/nohup # 快速查找，可以看到如下</span><br><span class="line">nohup "$JAVA" "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;"</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个就算脚本中启动<code>zookeeper</code>的命令，默认只有以上两个配置项，我们需要添加一个超管的配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后命令变成如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup "$JAVA" "-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;" "-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;" "-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重起后，现在随便对任意节点添加权限限制</span></span><br><span class="line">setAcl /hadoop ip:192.168.1.1:cdrwa # 这个ip并非本机</span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在当前用户没有权限了</span></span><br><span class="line">getAcl /hadoop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录超管</span></span><br><span class="line">addauth digest super:admin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行操作节点</span></span><br><span class="line">get /hadoop</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="zookeeper的-Java-API"><a href="#zookeeper的-Java-API" class="headerlink" title="zookeeper的 Java API"></a>zookeeper的 Java API</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>zonde</code>是 <code>zookeeper</code>集合的核心组件，<code>zookeeper API</code> 提供了一小组使用 <code>zookeeper</code>集群来操作<code>znode</code>的所有细节</p>
<p>客户端应该遵循以下步骤，与<code>zookeeper</code>服务器进行清晰和干净的交互</p>
<ul>
<li>连接到<code>zookeeper</code>服务器。<code>zookeeper</code>服务器为客户端分配会话<code>ID</code></li>
<li>定期向服务器发送心跳。否则，<code>zookeeper</code>服务器将过期会话<code>ID</code>，客户端需要重新连接</li>
<li>只要会话<code>Id</code>处于活动状态，就可以获取/设置<code>znode</code></li>
<li>所有任务完成后，断开与<code>zookeeper</code>服务器连接，如果客户端长时间不活动，则<code>zookeeper</code>服务器将自动断开客户端</li>
</ul>
<h4 id="连接到Zookeeper"><a href="#连接到Zookeeper" class="headerlink" title="连接到Zookeeper"></a>连接到Zookeeper</h4><p>这部分，官网的解释十分稀少<a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_ConnectingToZooKeeper" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_ConnectingToZooKeeper</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zkshell: 0] help</span><br><span class="line">ZooKeeper host:port cmd args</span><br><span class="line">    get path [watch]</span><br><span class="line">    ls path [watch]</span><br><span class="line">    set path data [version]</span><br><span class="line">    delquota [-n|-b] path</span><br><span class="line">    quit</span><br><span class="line">    printwatches on|off</span><br><span class="line">    create path data acl</span><br><span class="line">    stat path [watch]</span><br><span class="line">    listquota path</span><br><span class="line">    history</span><br><span class="line">    setAcl path acl</span><br><span class="line">    getAcl path</span><br><span class="line">    sync path</span><br><span class="line">    redo cmdno</span><br><span class="line">    addauth scheme auth</span><br><span class="line">    delete path [version]</span><br><span class="line">    deleteall path</span><br><span class="line">    setquota -n|-b val path</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper(String connectionString, <span class="keyword">int</span> sessionTimeout, watcher watcher)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>connectionString</code> - <code>zookeeper</code>主机</li>
<li><code>sessionTimeout</code>- 会话超时</li>
<li><code>watcher</code> - 实现”监听器” 对象。<code>zookeeper</code>集合通过监视器对象返回连接状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.133.133:2181"</span>, <span class="number">5000</span>, (WatchedEvent x) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.getState() == Watcher.Event.KeeperState.SyncConnected) &#123;</span><br><span class="line">                System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(zookeeper.getSessionId());</span><br><span class="line">        zookeeper.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">create(String path, <span class="keyword">byte</span>[] data, List&lt;ACL&gt; acl, CreateMode createMode,</span><br><span class="line">      AsynCallback.StringCallback callBack, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td><code>znode</code>路径</td>
</tr>
<tr>
<td><code>data</code></td>
<td>数据</td>
</tr>
<tr>
<td><code>acl</code></td>
<td>要创建的节点的访问控制列表。<code>zookeeper API</code>提供了一个静态接口 <code>ZooDefs.Ids</code> 来获取一些基本的<code>acl</code>列表。例如，<code>ZooDefs.Ids.OPEN_ACL_UNSAFE</code>返回打开<code>znode</code>的<code>acl</code>列表</td>
</tr>
<tr>
<td><code>createMode</code></td>
<td>节点的类型，这是一个枚举</td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>异步回调接口</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String str = <span class="string">"node"</span>;</span><br><span class="line">        String s = zookeeper.create(<span class="string">"/node"</span>, str.getBytes(),</span><br><span class="line">                ZooDefs.Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ArrayList&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">"ip"</span>,<span class="string">"192.168.133.133"</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL,id));</span><br><span class="line">        zookeeper.create(<span class="string">"/create/node4"</span>,<span class="string">"node4"</span>.getBytes(),acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest3</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        zookeeper.addAuthInfo(<span class="string">"digest"</span>,<span class="string">"itcast:12345"</span>.getBytes());</span><br><span class="line">        zookeeper.create(<span class="string">"/node5"</span>,<span class="string">"node5"</span>.getBytes(),</span><br><span class="line">                ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 自定义的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest3</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"><span class="comment">//        zookeeper.addAuthInfo("digest","itcast:12345".getBytes());</span></span><br><span class="line"><span class="comment">//        zookeeper.create("/node5","node5".getBytes(),</span></span><br><span class="line"><span class="comment">//                ZooDefs.Ids.CREATOR_ALL_ACL,CreateMode.PERSISTENT);</span></span><br><span class="line">        zookeeper.addAuthInfo(<span class="string">"digest"</span>,<span class="string">"itcast:12345"</span>.getBytes());</span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">"auth"</span>,<span class="string">"itcast"</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">        zookeeper.create(<span class="string">"/create/node6"</span>,<span class="string">"node6"</span>.getBytes(),</span><br><span class="line">                acls,CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// digest </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest3</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">    List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Id id = <span class="keyword">new</span> Id(<span class="string">"digest"</span>,<span class="string">"itcast:qUFSHxJjItUW/93UHFXFVGlvryY="</span>);</span><br><span class="line">    acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">    zookeeper.create(<span class="string">"/create/node7"</span>,<span class="string">"node7"</span>.getBytes(), 	</span><br><span class="line">                     acls,CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTest4</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        zookeeper.create(<span class="string">"/node12"</span>, <span class="string">"node12"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="keyword">new</span> AsyncCallback.StringCallback()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> rc 状态，0 则为成功，以下的所有示例都是如此</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> path 路径</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ctx 上下文参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> name 路径</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span></span>&#123;</span><br><span class="line">                System.out.println(rc + <span class="string">" "</span> + path + <span class="string">" "</span> + name +  <span class="string">" "</span> + ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"I am context"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><p>同样也有两种修改方式(<code>异步和同步</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">setData(String path, <span class="keyword">byte</span>[] data, <span class="keyword">int</span> version)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">setData(String path, <span class="keyword">byte</span>[] data, <span class="keyword">int</span> version, StatCallback callBack, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>节点路径</td>
</tr>
<tr>
<td><code>data</code></td>
<td>数据</td>
</tr>
<tr>
<td><code>version</code></td>
<td>数据的版本号， -<code>1</code>代表不使用版本号，乐观锁机制</td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>异步回调 <code>AsyncCallback.StatCallback</code>，和之前的回调方法参数不同，这个可以获取节点状态</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setData1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">// arg1:节点的路径</span></span><br><span class="line">    <span class="comment">// arg2:修改的数据</span></span><br><span class="line">    <span class="comment">// arg3:数据的版本号 -1 代表版本号不参与更新</span></span><br><span class="line">    Stat stat = zookeeper.setData(<span class="string">"/hadoop"</span>,<span class="string">"hadoop-1"</span>.getBytes(),-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setData2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    zookeeper.setData(<span class="string">"/hadoop"</span>, <span class="string">"hadoop-1"</span>.getBytes(), <span class="number">3</span> ,<span class="keyword">new</span> AsyncCallback.StatCallback()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 讲道理，要判空</span></span><br><span class="line">            System.out.println(rc + <span class="string">" "</span> + path + <span class="string">" "</span> + stat.getVersion() +  <span class="string">" "</span> + ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"I am context"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p>异步、同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">delete(String path, <span class="keyword">int</span> version)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">delete(String path, <span class="keyword">int</span> version, AsyncCallback.VoidCallback callBack, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>节点路径</td>
</tr>
<tr>
<td><code>version</code></td>
<td>版本</td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>数据的版本号， -<code>1</code>代表不使用版本号，乐观锁机制</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.delete(<span class="string">"/hadoop"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteData2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.delete(<span class="string">"/hadoop"</span>, <span class="number">1</span>, <span class="keyword">new</span> AsyncCallback.VoidCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx)</span> </span>&#123;</span><br><span class="line">            System.out.println(rc + <span class="string">" "</span> + path + <span class="string">" "</span> + ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"I am context"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h5><p>同步、异步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">getData(String path, <span class="keyword">boolean</span> watch, Stat stat)</span><br><span class="line">getData(String path, Watcher watcher, Stat stat)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">getData(String path, <span class="keyword">boolean</span> watch, DataCallback callBack, Object ctx)</span><br><span class="line">getData(String path, Watcher watcher, DataCallback callBack, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>节点路径</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>是否使用连接对象中注册的监听器</td>
</tr>
<tr>
<td><code>stat</code></td>
<td>元数据</td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>异步回调接口，可以获得状态和数据</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">    <span class="keyword">byte</span>[] data = zookeeper.getData(<span class="string">"/hadoop"</span>, <span class="keyword">false</span>, stat);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    System.out.println(stat.getCtime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.getData(<span class="string">"/hadoop"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> AsyncCallback.DataCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] bytes, Stat stat)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            System.out.println(rc + <span class="string">" "</span> + path</span><br><span class="line">                               + <span class="string">" "</span> + ctx + <span class="string">" "</span> + <span class="keyword">new</span> String(bytes) + <span class="string">" "</span> + </span><br><span class="line">                               stat.getCzxid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"I am context"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看子节点"><a href="#查看子节点" class="headerlink" title="查看子节点"></a>查看子节点</h5><p>同步、异步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">getChildren(String path, <span class="keyword">boolean</span> watch)</span><br><span class="line">getChildren(String path, Watcher watcher)</span><br><span class="line">getChildren(String path, <span class="keyword">boolean</span> watch, Stat stat)    </span><br><span class="line">getChildren(String path, Watcher watcher, Stat stat)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">getChildren(String path, <span class="keyword">boolean</span> watch, ChildrenCallback callBack, Object ctx)    </span><br><span class="line">getChildren(String path, Watcher watcher, ChildrenCallback callBack, Object ctx)</span><br><span class="line">getChildren(String path, Watcher watcher, Children2Callback callBack, Object ctx)    </span><br><span class="line">getChildren(String path, <span class="keyword">boolean</span> watch, Children2Callback callBack, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>节点路径</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>异步回调，可以获取节点列表</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChildren_1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; hadoop = zookeeper.getChildren(<span class="string">"/hadoop"</span>, <span class="keyword">false</span>);</span><br><span class="line">    hadoop.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChildren_2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    zookeeper.getChildren(<span class="string">"/hadoop"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> AsyncCallback.ChildrenCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">            list.forEach(System.out::println);</span><br><span class="line">            System.out.println(rc + <span class="string">" "</span> + path + <span class="string">" "</span> + ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"I am children"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h5><p>同步、异步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步</span></span><br><span class="line">exists(String path, <span class="keyword">boolean</span> watch)</span><br><span class="line">exists(String path, Watcher watcher)</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">exists(String path, <span class="keyword">boolean</span> watch, StatCallback cb, Object ctx)</span><br><span class="line">exists(String path, Watcher watcher, StatCallback cb, Object ctx)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>节点路径</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>callBack</code></td>
<td>异步回调，可以获取节点列表</td>
</tr>
<tr>
<td><code>ctx</code></td>
<td>传递上下文参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Stat exists = zookeeper.exists(<span class="string">"/hadoopx"</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    System.out.println(exists.getVersion() + <span class="string">"成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    zookeeper.exists(<span class="string">"/hadoopx"</span>, <span class="keyword">false</span>, <span class="keyword">new</span> AsyncCallback.StatCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            System.out.println(rc + <span class="string">" "</span> + path + <span class="string">" "</span> + ctx +<span class="string">" "</span> + stat.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"I am children"</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><p><strong>watcher概念</strong></p>
<p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_WatchRememberThese" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperProgrammers.html#sc_WatchRememberThese</a></p>
<ul>
<li><code>zookeeper</code>提供了数据的<code>发布/订阅</code>功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者</li>
<li><code>zookeeper</code>采用了 <code>Watcher</code>机制实现数据的发布订阅功能。该机制在被订阅对象发生变化时会异步通知客户端，因此客户端不必在 <code>Watcher</code>注册后轮询阻塞，从而减轻了客户端压力</li>
<li><code>watcher</code>机制事件上与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式</li>
</ul>
<h4 id="watcher架构"><a href="#watcher架构" class="headerlink" title="watcher架构"></a>watcher架构</h4><p><code>watcher</code>实现由三个部分组成</p>
<ul>
<li><code>zookeeper</code>服务端</li>
<li><code>zookeeper</code>客户端</li>
<li>客户端的<code>ZKWatchManager对象</code></li>
</ul>
<p>客户端<strong>首先将 <code>Watcher</code>注册到服务端</strong>，同时将 <code>Watcher</code>对象<strong>保存到客户端的<code>watch</code>管理器中</strong>。当<code>Zookeeper</code>服务端监听的数据状态发生变化时，服务端会<strong>主动通知客户端</strong>，接着客户端的 <code>Watch</code>管理器会<strong>触发相关 <code>Watcher</code></strong>来回调相应处理逻辑，从而完成整体的数据 <code>发布/订阅</code>流程</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPNeK.png" alt></p>
<h4 id="watcher特性"><a href="#watcher特性" class="headerlink" title="watcher特性"></a>watcher特性</h4><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一次性</td>
<td><code>watcher</code>是<strong>一次性</strong>的，一旦被触发就会移除，再次使用时需要重新注册</td>
</tr>
<tr>
<td>客户端顺序回调</td>
<td><code>watcher</code>回调是<strong>顺序串行</strong>执行的，只有回调后客户端才能看到最新的数据状态。一个<code>watcher</code>回调逻辑不应该太多，以免影响别的<code>watcher</code>执行</td>
</tr>
<tr>
<td>轻量级</td>
<td><code>WatchEvent</code>是最小的通信单位，结构上只包含<strong>通知状态、事件类型和节点路径</strong>，并不会告诉数据节点变化前后的具体内容</td>
</tr>
<tr>
<td>时效性</td>
<td><code>watcher</code>只有在当前<code>session</code>彻底失效时才会无效，若在<code>session</code>有效期内快速重连成功，则<code>watcher</code>依然存在，仍可接收到通知；</td>
</tr>
</tbody></table>
<p><strong>watcher接口设计</strong></p>
<p><code>Watcher</code>是一个接口，任何实现了<code>Watcher</code>接口的类就算一个新的<code>Watcher</code>。<code>Watcher</code>内部包含了两个枚举类：<code>KeeperState</code>、<code>EventType</code></p>
<p><img src="https://i.imgs.ovh/2023/09/22/PPyMj.png" alt></p>
<h5 id="Watcher通知状态-KeeperState"><a href="#Watcher通知状态-KeeperState" class="headerlink" title="Watcher通知状态(KeeperState)"></a>Watcher通知状态(KeeperState)</h5><p><code>KeeperState</code>是客户端与服务端<strong>连接状态</strong>发生变化时对应的通知类型。路径为<code>org.apache.zookeeper.Watcher.EventKeeperState</code>，是一个枚举类，其枚举属性如下：</p>
<table>
<thead>
<tr>
<th>枚举属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SyncConnected</code></td>
<td>客户端与服务器正常连接时</td>
</tr>
<tr>
<td><code>Disconnected</code></td>
<td>客户端与服务器断开连接时</td>
</tr>
<tr>
<td><code>Expired</code></td>
<td>会话<code>session</code>失效时</td>
</tr>
<tr>
<td><code>AuthFailed</code></td>
<td>身份认证失败时</td>
</tr>
</tbody></table>
<h5 id="Watcher事件类型-EventType"><a href="#Watcher事件类型-EventType" class="headerlink" title="Watcher事件类型(EventType)"></a>Watcher事件类型(EventType)</h5><p><code>EventType</code>是<strong>数据节点<code>znode</code>发生变化</strong>时对应的通知类型。<strong><code>EventType</code>变化时<code>KeeperState</code>永远处于<code>SyncConnected</code>通知状态下</strong>；当<code>keeperState</code>发生变化时，<code>EventType</code>永远为<code>None</code>。其路径为<code>org.apache.zookeeper.Watcher.Event.EventType</code>，是一个枚举类，枚举属性如下：</p>
<table>
<thead>
<tr>
<th>枚举属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>None</code></td>
<td>无</td>
</tr>
<tr>
<td><code>NodeCreated</code></td>
<td><code>Watcher</code>监听的数据节点被创建时</td>
</tr>
<tr>
<td><code>NodeDeleted</code></td>
<td><code>Watcher</code>监听的数据节点被删除时</td>
</tr>
<tr>
<td><code>NodeDataChanged</code></td>
<td><code>Watcher</code>监听的数据节点内容发生更改时(无论数据是否真的变化)</td>
</tr>
<tr>
<td><code>NodeChildrenChanged</code></td>
<td><code>Watcher</code>监听的数据节点的子节点列表发生变更时</td>
</tr>
</tbody></table>
<p>注意：客户端接收到的相关事件通知中只包含状态以及类型等信息，不包含节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需要调用<code>get</code>等方法重新获取</p>
<h5 id="捕获相应的事件"><a href="#捕获相应的事件" class="headerlink" title="捕获相应的事件"></a>捕获相应的事件</h5><p>上面讲到<code>zookeeper</code>客户端连接的状态和<code>zookeeper</code>对<code>znode</code>节点监听的事件类型，下面我们来讲解如何建立<code>zookeeper</code>的<strong><em><code>watcher</code>监听</em></strong>。在<code>zookeeper</code>中采用<code>zk.getChildren(path,watch)、zk.exists(path,watch)、zk.getData(path,watcher,stat)</code>这样的方式来为某个<code>znode</code>注册监听 。</p>
<p>下表以<code>node-x</code>节点为例，说明调用的注册方法和可用监听事件间的关系：</p>
<table>
<thead>
<tr>
<th>注册方式</th>
<th>created</th>
<th>childrenChanged</th>
<th>Changed</th>
<th>Deleted</th>
</tr>
</thead>
<tbody><tr>
<td><code>zk.exists(&quot;/node-x&quot;,watcher)</code></td>
<td>可监控</td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td><code>zk.getData(&quot;/node-x&quot;,watcher)</code></td>
<td></td>
<td></td>
<td>可监控</td>
<td>可监控</td>
</tr>
<tr>
<td><code>zk.getChildren(&quot;/node-x&quot;,watcher)</code></td>
<td></td>
<td>可监控</td>
<td></td>
<td>可监控</td>
</tr>
</tbody></table>
<p><strong>注册watcher的方法</strong></p>
<h5 id="客户端与服务器端的连接状态"><a href="#客户端与服务器端的连接状态" class="headerlink" title="客户端与服务器端的连接状态"></a>客户端与服务器端的连接状态</h5><ul>
<li><p><code>KeeperState</code>：通知状态</p>
</li>
<li><p><code>SyncConnected</code>：客户端与服务器正常连接时</p>
</li>
<li><p><code>Disconnected</code>：客户端与服务器断开连接时</p>
</li>
<li><p><code>Expired</code>：会话<code>session</code>失效时</p>
</li>
<li><p><code>AuthFailed</code>：身份认证失败时</p>
</li>
<li><p>事件类型为：<code>None</code></p>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkConnectionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        Event.KeeperState state = watchedEvent.getState();</span><br><span class="line">        <span class="keyword">if</span>(state == Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">            System.out.println(<span class="string">"正常连接"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (state == Event.KeeperState.Disconnected)&#123;</span><br><span class="line">            <span class="comment">// 可以用Windows断开虚拟机网卡的方式模拟</span></span><br><span class="line">            <span class="comment">// 当会话断开会出现，断开连接不代表不能重连，在会话超时时间内重连可以恢复正常</span></span><br><span class="line">            System.out.println(<span class="string">"断开连接"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (state == Event.KeeperState.Expired)&#123;</span><br><span class="line">            <span class="comment">// 没有在会话超时时间内重新连接，而是当会话超时被移除的时候重连会走进这里</span></span><br><span class="line">            System.out.println(<span class="string">"连接过期"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (state == Event.KeeperState.AuthFailed)&#123;</span><br><span class="line">            <span class="comment">// 在操作的时候权限不够会出现</span></span><br><span class="line">            System.out.println(<span class="string">"授权失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.133.133:2181"</span></span><br><span class="line">;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 5000为会话超时时间</span></span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> ZkConnectionWatcher());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">// 模拟授权失败</span></span><br><span class="line">        zooKeeper.addAuthInfo(<span class="string">"digest1"</span>,<span class="string">"itcast1:123451"</span>.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/hadoop"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="watcher检查节点"><a href="#watcher检查节点" class="headerlink" title="watcher检查节点"></a>watcher检查节点</h5><p><strong>exists</strong></p>
<ul>
<li><p><code>exists(String path, boolean b)</code></p>
</li>
<li><p><code>exists(String path, Watcher w)</code></p>
</li>
<li><p><code>NodeCreated</code>：<strong>节点</strong>创建</p>
</li>
<li><p><code>NodeDeleted</code>：<strong>节点</strong>删除</p>
</li>
<li><p><code>NodeDataChanged</code>：<strong>节点</strong>内容</p>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventTypeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.133.133:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用zookeeper连接创建时的监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        zooKeeper.exists(<span class="string">"/watcher1"</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        zooKeeper.exists(<span class="string">"/watcher1"</span>,(WatchedEvent w) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"自定义"</span> + w.getType());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 演示使用多次的监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        zooKeeper.exists(<span class="string">"/watcher1"</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"自定义的"</span> + watchedEvent.getType());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        zooKeeper.exists(<span class="string">"/watcher1"</span>,<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 演示一节点注册多个监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exists4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        zooKeeper.exists(<span class="string">"/watcher1"</span>,(WatchedEvent w) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"自定义1"</span> + w.getType());</span><br><span class="line">        &#125;);</span><br><span class="line">        zooKeeper.exists(<span class="string">"/watcher1"</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"自定义2"</span> + watchedEvent.getType());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        zooKeeper.exists(<span class="string">"/watcher1"</span>,<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> ZKWatcher());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        exists4();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(<span class="string">"zk的监听器"</span> + watchedEvent.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>getData</strong></p>
<ul>
<li><code>getData(String path, boolean b, Stat stat)</code></li>
<li><code>getData(String path, Watcher w, Stat stat)</code></li>
<li><code>NodeDeleted</code>：<strong>节点</strong>删除</li>
<li><code>NodeDataChange</code>：<strong>节点</strong>内容发生变化</li>
</ul>
<p><strong>getChildren</strong></p>
<ul>
<li><code>getChildren(String path, boolean b)</code></li>
<li><code>getChildren(String path, Watcher w)</code></li>
<li><code>NodeChildrenChanged</code>：<strong>子节点</strong>发生变化</li>
<li><code>NodeDeleted</code>：<strong>节点删除</strong></li>
</ul>
<p><strong>配置中心案例</strong></p>
<p>工作中有这样的一个场景：数据库用户名和密码信息放在一个配置文件中，应用读取该配置文件，配置文件信息放入缓存</p>
<p>若数据库的用户名和密码改变时候，还需要重新加载媛存，比较麻烦，通过 <code>Zookeeper</code>可以轻松完成,当数据库发生变化时自动完成缓存同步</p>
<p>使用事件监听机制可以做出一个简单的配置中心</p>
<p>设计思路</p>
<ol>
<li>连接<code>zookeeper</code>服务器</li>
<li>读取<code>zookeeper</code>中的配置信息，注册<code>watcher</code>监听器，存入本地变量</li>
<li>当<code>zookeeper</code>中的配置信息发生变化时，通过<code>watcher</code>的回调方法捕获数据变化事件</li>
<li>重新获取配置信息</li>
</ol>
<h5 id="分布式唯一id案例"><a href="#分布式唯一id案例" class="headerlink" title="分布式唯一id案例"></a>分布式唯一id案例</h5><p>在过去的单库单表型系统中，通常第可以使用数据库字段自带的<code>auto_ increment</code>属性来自动为每条记录生成个唯一的<code>ID</code>。但是分库分表后，就无法在依靠数据库的<code>auto_ increment</code>属性来唯一标识一条记录了。此时我们就可以用<code>zookeeper</code>在分布式环境下生成全局唯一<code>ID</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.133.133:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateId</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper.create(<span class="string">"/id"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">5000</span>, <span class="keyword">new</span> ZKWatcher());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(generateId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(<span class="string">"zk的监听器"</span> + watchedEvent.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h5><p>分布式锁有多种实现方式，比如通过数据库、redis都可实现。作为分布式协同工具<code>Zookeeper</code>，当然也有着标准的实现方式。下面介绍在<code>zookeeper</code>中如果实现排他锁</p>
<p>设计思路</p>
<ol>
<li>每个客户端往<code>/Locks</code>下创建临时有序节点<code>/Locks/Lock_</code>，创建成功后<code>/Locks</code>下面会有每个客户端对应的节点，如<code>/Locks/Lock_000000001</code></li>
<li>客户端取得/Locks下子节点，并进行排序，判断排在前面的是否为自己，如果自己的锁节点在第一位，代表获取锁成功</li>
<li>如果自己的锁节点不在第一位，则监听自己前一位的锁节点。例如，自己锁节点<code>Lock_000000002</code>，那么则监听<code>Lock_000000001</code></li>
<li>当前一位锁节点<code>(Lock_000000001)</code>对应的客户端执行完成，释放了锁，将会触发监听客户端<code>(Lock_000000002)</code>的逻辑</li>
<li>监听客户端重新执行第<code>2</code>步逻辑，判断自己是否获得了锁</li>
<li><strong>zookeeper是有工具包的(这里采用手写)</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delayOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Runable runable,<span class="keyword">int</span> threadNum)</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">30</span>, <span class="number">30</span>,</span><br><span class="line">                <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(runable::run);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        DistributedLock distributedLock = new DistributedLock();</span></span><br><span class="line"><span class="comment">//        distributedLock.acquireLock();</span></span><br><span class="line"><span class="comment">//        delayOperation();</span></span><br><span class="line"><span class="comment">//        distributedLock.releaseLock();</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="comment">// 每秒打印信息</span></span><br><span class="line">        run(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String format = dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">                System.out.println(format);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 线程测试</span></span><br><span class="line">        run(() -&gt; &#123;</span><br><span class="line">            DistributedLock distributedLock = <span class="keyword">new</span> DistributedLock();</span><br><span class="line">            distributedLock.acquireLock();</span><br><span class="line">            delayOperation();</span><br><span class="line">            distributedLock.releaseLock();</span><br><span class="line">        &#125;,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String IP = <span class="string">"192.168.133.133:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ROOT_LOCK = <span class="string">"/Root_Lock"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String LOCK_PREFIX = <span class="string">"/Lock_"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] DATA = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper = <span class="keyword">new</span> ZooKeeper(IP, <span class="number">200000</span>, w -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(w.getState() == Watcher.Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露的外部方法，主逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        createLock();</span><br><span class="line">        attemptLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露的外部方法，主逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path,-<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"锁释放了"</span> + path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个目录节点</span></span><br><span class="line">            Stat root = zookeeper.exists(ROOT_LOCK, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">                zookeeper.create(ROOT_LOCK, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="comment">// 目录下创建子节点</span></span><br><span class="line">            path = zookeeper.create(ROOT_LOCK + LOCK_PREFIX, DATA, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Watcher watcher = <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取正在排队的节点，由于是zookeeper生成的临时节点，不会出错，这里不能加监视器</span></span><br><span class="line">            <span class="comment">// 因为添加了监视器后，任何子节点的变化都会触发监视器</span></span><br><span class="line">            List&lt;String&gt; nodes = zookeeper.getChildren(ROOT_LOCK,<span class="keyword">false</span>);</span><br><span class="line">            nodes.sort(String::compareTo);</span><br><span class="line">            <span class="comment">// 获取自身节点的排名</span></span><br><span class="line">            <span class="keyword">int</span> ranking = nodes.indexOf(path.substring(ROOT_LOCK.length() + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 已经是最靠前的节点了，获取锁</span></span><br><span class="line">            <span class="keyword">if</span>(ranking == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 并不是靠前的锁，监视自身节点的前一个节点</span></span><br><span class="line">                Stat status = zookeeper.exists(ROOT_LOCK+<span class="string">"/"</span>+nodes.get(ranking - <span class="number">1</span>), watcher);</span><br><span class="line">                <span class="comment">// 有可能这这个判断的瞬间，0号完成了操作(此时我们应该判断成功自旋才对)，但是上面的status变量已经获取了值并且不为空，1号沉睡</span></span><br><span class="line">                <span class="comment">// 但是，请注意自行测试，虽然1号表面上沉睡了，但是实际上watcher.wait()是瞬间唤醒的</span></span><br><span class="line">                <span class="keyword">if</span>(status == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    attemptLock();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (watcher)&#123;</span><br><span class="line">                        watcher.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    attemptLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p><code>zookeeper</code>官网——<code>Getting started</code>——<a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_RunningReplicatedZooKeeper" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperStarted.html#sc_RunningReplicatedZooKeeper</a></p>
<p>完全配置——<a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkMulitServerSetup" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkMulitServerSetup</a><br><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration</a></p>
<p>运行时复制的<code>zookeeper</code></p>
<p><strong>说明</strong>：对于复制模式，至少需要三个服务器，并且强烈建议您使用奇数个服务器。如果只有两台服务器，那么您将处于一种情况，如果其中一台服务器发生故障，则没有足够的计算机构成多数仲裁(<code>zk</code>采用的是过半数仲裁。因此，搭建的集群要容忍n个节点的故障，就必须有<code>2n+1</code>台计算机，这是因为宕掉n台后，集群还残余<code>n+1</code>台计算机，<code>n+1</code>台计算机中必定有一个最完整最接近<code>leader</code>的<code>follower</code>，假如宕掉的n台都是有完整信息的，剩下的一台就会出现在残余的<code>zk</code>集群中。也就是说：<code>zk</code>为了安全，必须达到多数仲裁，否则没有<code>leader</code>，集群失败，具体体现在<strong><code>leader</code>选举-章</strong>)。由于存在两个单点故障，因此两个服务器还<strong>不如</strong>单个服务器稳定。</p>
<p>——关于<code>2n+1</code>原则，<code>Kafka</code>官网有权威的解释(虽然<code>Kafka</code>不采用)<a href="http://kafka.apache.org/0110/documentation.html#design_replicatedlog" target="_blank" rel="noopener">http://kafka.apache.org/0110/documentation.html#design_replicatedlog</a></p>
<p>多数仲裁的设计是为了<strong>避免脑裂</strong>(zk，已经采用了多数仲裁，所以不会出现)，和数据一致性的问题</p>
<ul>
<li><strong>脑裂</strong>：由于网络延迟等各种因素，最终导致集群一分为二，各自独立运行(两个<code>leader</code>)，集群就是坏的</li>
<li>如果有两台服务器，两台都认为另外的<code>zk</code>宕掉，各自成为<code>leader</code>运行(假设可以，实际上选不出<code>leader</code>，可以实际搭建一个集群，看看一台zk是否能够成功集群，详见<strong><code>leader</code>选举</strong>)，就会导致数据不一致。</li>
<li>如果有三台服务器，一台因为网络分区，无法连接，剩下两台网络正常，选举出了<code>leader</code>，集群正常</li>
<li>以此类推<ul>
<li><img src="https://i.imgs.ovh/2023/09/22/PPDFp.png" alt></li>
<li>zk的设计天生就是<code>cap</code>中的<code>cp</code>，所以不会出现上述的脑裂和数据一致性问题，我们搭建<code>zk</code>仅需保证<code>2n+1</code>原则</li>
</ul>
</li>
</ul>
<p>复制模式所需的<strong>conf / zoo.cfg</strong>文件类似于独立模式下使用的文件，但有一些区别。这是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/var/lib/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br><span class="line">server.1=zoo1:2888:3888 # 这是多机部署</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure>

<ul>
<li>新的键值<strong><code>initLimit</code></strong>是<code>zookeeper</code>用于限制选举中<code>zookeeper</code>服务连接到<code>leader</code>的时间，<strong><code>syncLimit</code></strong>限制服务器与<code>leader</code>的过期时间</li>
<li>对于这两个超时，您都可以使用<strong>tickTime</strong>指定时间单位。在此示例中，<code>initLimit</code>的超时为5个滴答声，即<code>2000</code>毫秒/滴答声，即<code>10</code>秒</li>
<li>表格<em><code>server.X</code></em>的条目列出了组成<code>ZooKeeper</code>服务的服务器。服务器启动时，它通过在数据目录中查找文件<em><code>myid</code></em>来知道它是哪台服务器。该文件包含<code>ASCII</code>的服务器号。</li>
<li>最后，记下每个服务器名称后面的两个端口号：<code>“ 2888”</code>和<code>“ 3888”</code>。对等方使用前一个端口连接到其他对等方。这种连接是必需的，以便对等方可以进行通信，例如，以商定更新顺序。更具体地说，<strong><code>ZooKeeper</code>服务器使用此端口将<code>follower</code>连接到<code>leader</code></strong>。当出现新的<code>leader</code>者时，<code>follower</code>使用此端口打开与<code>leader</code>的<code>TCP</code>连接。因为默认的<code>leader</code>选举也使用<code>TCP</code>，所以我们当前需要另一个端口来进行<code>leader</code>选举。这是第二个端口。</li>
</ul>
<p><strong>正文</strong>搭建：单机环境下，<code>jdk</code>、<code>zookeeper</code>安装完毕，基于一台虚拟机，进行<code>zookeeper</code><strong>伪集群搭建</strong>，<code>zookeeper</code>集群中包含3个节点，节点对外提供服务端口号，分别为<code>2181</code>、<code>2182</code>、<code>2183</code></p>
<ol>
<li><p>基于<code>zookeeper-3.4.10</code>复制三份<code>zookeeper</code>安装好的服务器文件,目录名称分别为<code>zookeeper2181</code>、<code>zookeeper2182</code>、<code>zookeeper2183</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -r zookeeper-3.4.10  zookeeper2181</span><br><span class="line">cp -r zookeeper-3.4.10  zookeeper2182</span><br><span class="line">cp -r zookeeper-3.4.10  zookeeper2183</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cp -r zookeeper-3.1.10 ./zookeeper218&#123;1..3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>zookeeper2181</code>服务器对应配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务器对应端口号</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据快照文件所在路径</span></span><br><span class="line">dataDir=/opt/zookeeper2181/data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群配置信息</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> server:A=B:C:D</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> A:是一个数字，表示这个是服务器的编号</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> B:是这个服务器的ip地址</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> C:Zookeeper服务器之间通信的端口(数据互通，必须的)</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> D:Leader选举的端口</span></span><br><span class="line">server.1=192.168.133.133:2287:3387  # 这是伪集群部署，注意端口号  </span><br><span class="line">server.2=192.168.133.133:2288:3388</span><br><span class="line">server.3=192.168.133.133:2289:3389</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对，这些都是2181的配置文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在上一步 <code>dataDir</code>指定的目录下，创建<code>myid</code>文件，然后在该文件添加上一步<code>server</code>配置的对应<code>A</code>数字</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zookeeper2181对应的数字为1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /opt/zookeeper2181/data目录(即dataDir的目录下)下执行命令</span></span><br><span class="line">echo "1" &gt; myid</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zookeeper2182、2183</code>参照2/3进行相应配置</p>
</li>
<li><p>分别启动三台服务器，检验集群状态</p>
<p>检查：<code>cd</code>进入<code>bin</code>目录<code>./zkServer status</code></p>
<p>登录命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh -server 192.168.60.130:2181</span><br><span class="line">./zkCli.sh -server 192.168.60.130:2182</span><br><span class="line">./zkCli.sh -server 192.168.60.130:2183</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果启动后没有显示出集群的状态，请自己检查端口和配置文件问题，主要是端口占用和配置文件问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ss -lntpd | grep 2181</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="一致性协议——zab协议"><a href="#一致性协议——zab协议" class="headerlink" title="一致性协议——zab协议"></a>一致性协议——zab协议</h4><p><code>zab</code>协议的全称是 <strong><em><code>Zookeeper Atomic Broadcast</code></em></strong> (<code>zookeeper</code>原子广播)。<code>zookeeper</code>是通过<code>zab</code>协议来保证分布式事务的最终一致性</p>
<p>基于<code>zab</code>协议，<code>zookeeper</code>集群中的角色主要有以下三类，如下所示：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>领导者(<code>Leader</code>)</strong></td>
<td>领导者负责进行投票的发起和决议，更新系统状态</td>
</tr>
<tr>
<td><strong>学习者(<code>Learner</code>)-跟随者(<code>Follower</code>)</strong></td>
<td><code>Follower</code>用于接收客户端请求并向客户端返回结果，在选主过程中参与投票</td>
</tr>
<tr>
<td><strong>学习者(<code>Learner</code>)-观察者(<code>ObServer</code>)</strong></td>
<td><code>ObServer</code>可以接收客户端连接，将写请求转发给<code>leader</code>节点。但<code>ObServer</code>不参加投票过程，只同步<code>leader</code>的状态。<code>ObServer</code>的目的是为了扩展系统，提高读取速度</td>
</tr>
<tr>
<td><strong>客户端(<code>Client</code>)</strong></td>
<td>请求发起方</td>
</tr>
</tbody></table>
<p>·<code>zab</code>广播模式工作原理，通过类似两端式提交协议的方式解决数据一致性：</p>
<p><img src="https://i.imgs.ovh/2023/09/22/PVCuI.png" alt></p>
<ol>
<li><code>leader</code>从客户端收<strong>到一个写请求</strong></li>
<li><code>leader</code><strong>生成一个新的事务</strong>并为这个事务生成一个唯一的<code>ZXID</code></li>
<li><code>leader</code><strong>将事务提议(<code>propose</code>)发送给所有的<code>follows</code>节点</strong></li>
<li><code>follower</code>节点将收到的事务请求加入到本地<strong>历史队列(<code>history queue</code>)中，并发送<code>ack</code>给<code>leader</code></strong>，表示确认提议</li>
<li>当<code>leader</code>收到大多数<code>follower</code>(<strong>半数以上节点</strong>)的<code>ack(acknowledgement)</code>确认消息，<code>leader</code>会本地提交，并发送<code>commit</code>请求</li>
<li>当<code>follower</code><strong>收到<code>commit</code>请求时，从历史队列中将事务请求<code>commit</code></strong></li>
</ol>
<p>因为是半数以上的结点就可以通过事务请求，所以延迟不高</p>
<h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p><strong>服务器状态</strong></p>
<ul>
<li><strong><code>looking</code></strong>：寻找<code>leader</code>状态。当服务器处于该状态时，它会认为当前集群中没有<code>leader</code>，因此需要进入<code>leader</code>选举状态</li>
<li><strong><code>following</code></strong>：跟随着状态。表明当前服务器角色是<code>follower</code></li>
<li><strong><code>observing</code></strong>：观察者状态。表明当前服务器角色是<code>observer</code></li>
</ul>
<p>分为两种选举，<strong>服务器启动时的选举</strong>和<strong>服务器运行时期的选举</strong></p>
<p><strong>服务器启动时期的leader选举</strong></p>
<p>在集群初始化节点，当有一台服务器<code>server1</code>启动时，其<strong>单独无法进行和完成<code>leader</code>选举</strong>，当第二台服务器<code>server2</code>启动时，此时两台及其可以相互通信，每台及其都试图找到<code>leader</code>，<strong>于是进入<code>leader</code>选举过程</strong>。选举过程如下：</p>
<ol>
<li><p>每个<code>server</code>发出一个投票。由于是初始状态，<code>server1</code>和<code>server2</code>都会将自己作为<code>leader</code>服务器来进行投票，每次投票都会包<strong>含所推举的<code>myid</code>和<code>zxid</code>，使用(<code>myid，zxid</code>)</strong>，此时<code>server1</code>的投票为(1，0)，<code>server2</code>的投票为(2，0)，然后<strong>各自将这个投票发给集群中的其它机器</strong></p>
</li>
<li><p>集群中的<strong>每台服务器都接收来自集群中各个服务器的投票</strong></p>
</li>
<li><p><strong>处理投票</strong>。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，规则如下</p>
<ul>
<li><p>优先检查<code>zxid</code>。<code>zxid</code>比较大的服务器优先作为<code>leader</code>(<strong><code>zxid</code>较大者保存的数据更多</strong>)</p>
</li>
<li><p>如果<code>zxid</code>相同。那么就比较<code>myid</code>。<code>myid</code>较大的服务器作为<code>leader</code>服务器</p>
<p><strong>对于<code>Server1</code>而言，它的投票是(1，0)</strong>，接收<code>Server2</code>的投票为(2，0)，<strong>首先会比较两者的<code>zxid</code></strong>，均为0，<strong>再比较<code>myid</code></strong>，此时<code>server2</code>的<code>myid</code>最大，于是更新自己的投票为(2，0)，然后重新投票，<strong>对于server2而言，无需更新自己的投票</strong>，只是再次向集群中所有机器发出上一次投票信息即可</p>
</li>
</ul>
</li>
<li><p><strong>统计投票</strong>。每次投票后，服务器都会统计投票信息，判断是否已经有<strong>过半机器接受到相同的投票信息</strong>，对于<code>server1、server2</code>而言，都统计出集群中已经有两台机器接受了(2，0)的投票信息，此时便认为已经选举出了<code>leader</code></p>
</li>
<li><p><strong>改变服务器状态</strong>。一旦确定了<code>leader</code>,每个服务器就会更新自己的状态，如果是<code>follower</code>，那么就变更为<code>following</code>，如果是<code>leader</code>，就变更为<code>leading</code></p>
</li>
</ol>
<p><strong>举例：如果我们有三个节点的集群，1，2，3，启动 1 和 2 后，2 一定会是 <code>leader</code>，3 再加入不会进行选举，而是直接成为<code>follower</code></strong>—— 仔细观察 一台<code>zk</code>无法集群，没有<code>leader</code></p>
<p><strong>服务器运行时期选举</strong></p>
<p>在<code>zookeeper</code>运行期间，<code>leader</code>与非<code>leader</code>服务器各司其职，即使当有非<code>leader</code>服务器宕机或者新加入，此时也不会影响<code>leader</code>，但是一旦<code>leader</code>服务器挂了，那么整个集群将暂停对外服务，进入新一轮<code>leader</code>选举，其过程和启动时期的<code>leader</code>选举过程基本一致</p>
<p>假设正在运行的有<code>server1</code>、<code>server2</code>、<code>server3</code>三台服务器，当前<code>leader</code>是<code>server2</code>，若某一时刻<code>leader</code>挂了，此时便开始<code>Leader</code>选举。选举过程如下</p>
<ol>
<li>变更状态。<strong><code>leader</code>挂后，余下的服务器都会将自己的服务器状态变更为<code>looking</code></strong>，然后开始进入<code>leader</code>选举过程</li>
<li>每个<code>server</code>发出一个投票。在运行期间，<strong>每个服务器上的<code>zxid</code>可能不同</strong>，此时假定<code>server1</code>的<code>zxid</code>为<code>122</code>，<code>server3</code>的<code>zxid</code>为<code>122</code>，<strong>在第一轮投票中，server1和server3都会投自己</strong>，产生投票(1，122)，(3，122)，然后<strong>各自将投票发送给集群中所有机器</strong></li>
<li><strong>接收来自各个服务器的投票</strong>。与启动时过程相同</li>
<li><strong>处理投票</strong>。与启动时过程相同，此时，<code>server3</code>将会成为<code>leader</code></li>
<li><strong>统计投票</strong>。与启动时过程相同</li>
<li><strong>改变服务器的状态</strong>。与启动时过程相同</li>
</ol>
<h4 id="observer角色及其配置"><a href="#observer角色及其配置" class="headerlink" title="observer角色及其配置"></a>observer角色及其配置</h4><p><code>zookeeper</code>官网——<code>Observers Guide</code><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperObservers.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperObservers.html</a></p>
<p>尽管<code>ZooKeeper</code>通过使用客户端直接连接到该集合的投票成员表现良好，但是此体系结构使其很难扩展到大量客户端。问题在于，随着我们添加更多的投票成员，写入性能会下降。这是由于以下事实：写操作需要（通常）集合中至少一半节点的同意，因此，随着添加更多的投票者，投票的成本可能会显着增加。</p>
<p>我们引入了一种称为<em>Observer</em>的新型<code>ZooKeeper</code>节点，该节点有助于解决此问题并进一步提高<code>ZooKeeper</code>的可伸缩性。观察员是合法的非投票成员，他们仅听取投票结果，而听不到投票结果。除了这种简单的区别之外，观察者的功能与跟随者的功能完全相同-客户端可以连接到观察者，并向其发送读写请求。观察者像追随者一样将这些请求转发给领导者，但是他们只是等待听取投票结果。因此，我们可以在不影响投票效果的情况下尽可能增加观察员的数量。</p>
<p>观察者还有其他优点。因为他们不投票，所以它们不是<code>ZooKeeper</code>选举中的关键部分。因此，它们可以在不损害<code>ZooKeeper</code>服务可用性的情况下发生故障或与群集断开连接。给用户带来的好处是，观察者可以通过比跟随者更不可靠的网络链接进行连接。实际上，观察者可用于与另一个数据中心的<code>ZooKeeper</code>服务器进行对话。观察者的客户端将看到快速读取，因为所有读取均在本地提供，并且由于缺少表决协议而需要的消息数量较小，因此写入会导致网络流量最小</p>
<p><code>ovserver</code>角色<strong>特点</strong>：</p>
<ol>
<li><strong>不参与集群的<code>leader</code>选举</strong></li>
<li><strong>不参与集群中写数据时的<code>ack</code>反馈</strong></li>
</ol>
<p>为了使用<code>observer</code>角色，在任何想变成<code>observer</code>角色的配置文件中加入如下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peerType=observer</span><br></pre></td></tr></table></figure>

<p>并在所有<code>server</code>的配置文件中，配置成<code>observer</code>模式的<code>server</code>的那行配置追加<strong><em><code>:observer</code></em></strong>，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.133.133:2287:3387  # 注意端口号  </span><br><span class="line">server.2=192.168.133.133:2288:3388</span><br><span class="line">server.3=192.168.133.133:2289:3389:observer</span><br></pre></td></tr></table></figure>

<p>注意<code>2n+1</code>原则——<code>集群搭建</code></p>
<h4 id="API连接集群"><a href="#API连接集群" class="headerlink" title="API连接集群"></a>API连接集群</h4><p><code>Zookeeper(String connectionString, int sessionTimeout, Watcher watcher)</code></p>
<ul>
<li><code>connectionString</code> ：<code>zookeeper</code>集合主机</li>
<li><code>sessionTimeout</code>：会话超时(以毫秒为单位)</li>
<li><code>watcher</code>：实现”监听器”界面的对象。<code>zookeeper</code>集合通过监视器对象返回连接状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    ZooKeeper connection = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>, <span class="number">5000</span>, watchedEvent -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected)</span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    connection.create(<span class="string">"/hadoop"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class="line">    System.out.println(connection.getSessionId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="curator介绍"><a href="#curator介绍" class="headerlink" title="curator介绍"></a>curator介绍</h3><p><a href="https://blog.csdn.net/wo541075754/article/details/68067872" target="_blank" rel="noopener">https://blog.csdn.net/wo541075754/article/details/68067872</a> 关于第三方客户端的小介绍</p>
<p><code>zkClient</code>有对<code>dubbo</code>的一些操作支持，但是<code>zkClient</code>几乎没有文档，下面是<code>curator</code></p>
<p><strong>curator简介</strong></p>
<p><code>curator</code>是<code>Netflix</code>公司开源的一个 <code>zookeeper</code>客户端，后捐献给 <code>apache</code>,，<code>curator</code>框架在<code>zookeeper</code>原生<code>API</code>接口上进行了包装，解决了很多<code>zooKeeper</code>客户端非常底层的细节开发。提供<code>zooKeeper</code>各种应用场景(比如:分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等的抽象封装，实现了<code>Fluent</code>风格的APl接口，是最好用，最流行的<code>zookeeper</code>的客户端</p>
<p>原生<code>zookeeperAPI</code>的不足</p>
<ul>
<li>连接对象异步创建，需要开发人员自行编码等待</li>
<li>连接没有自动重连超时机制</li>
<li>watcher一次注册生效一次</li>
<li>不支持递归创建树形节点</li>
</ul>
<p><code>curator</code>特点</p>
<ul>
<li>解决<code>session</code>会话超时重连</li>
<li><code>watcher</code>反复注册</li>
<li>简化开发<code>api</code></li>
<li>遵循<code>Fluent</code>风格<code>API</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclustions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclustion</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclustion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclustions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">            <span class="comment">// ip端口号</span></span><br><span class="line">            .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">            <span class="comment">// 会话超时</span></span><br><span class="line">            .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">            <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">            <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点</span></span><br><span class="line">            .namespace(<span class="string">"create"</span>)</span><br><span class="line">            .build();</span><br><span class="line">    client.start();</span><br><span class="line">    </span><br><span class="line">    System.out.println(client.getState());</span><br><span class="line">    client.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>session</code>重连策略<ul>
<li><code>RetryPolicy retry Policy = new RetryOneTime(3000);</code><ul>
<li>说明：三秒后重连一次，只重连一次</li>
</ul>
</li>
<li><code>RetryPolicy retryPolicy = new RetryNTimes(3,3000);</code><ul>
<li>说明：每三秒重连一次，重连三次</li>
</ul>
</li>
<li><code>RetryPolicy retryPolicy = new RetryUntilElapsed(1000,3000);</code><ul>
<li>说明：每三秒重连一次，总等待时间超过个<code>10</code>秒后停止重连</li>
</ul>
</li>
<li><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000,3)</code><ul>
<li>说明：这个策略的重试间隔会越来越长<ul>
<li>公式：<code>baseSleepTImeMs * Math.max(1,random.nextInt(1 &lt;&lt; (retryCount + 1)))</code><ul>
<li><code>baseSleepTimeMs</code> = <code>1000</code> 例子中的值</li>
<li><code>maxRetries</code> = <code>3</code> 例子中的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">curatorGettingStart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ids权限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新增节点</span></span><br><span class="line">        client.create()</span><br><span class="line">                <span class="comment">// 节点的类型</span></span><br><span class="line">                .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                <span class="comment">// 节点的acl权限列表</span></span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                <span class="comment">// arg1：节点路径，arg2：节点数据</span></span><br><span class="line">                .forPath(<span class="string">"/node1"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义权限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ArrayList&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Id id = <span class="keyword">new</span> Id(<span class="string">"world"</span>, <span class="string">"anyone"</span>);</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ,id));</span><br><span class="line">        <span class="comment">// 新增节点</span></span><br><span class="line">        client.create()</span><br><span class="line">                <span class="comment">// 节点的类型</span></span><br><span class="line">                .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                <span class="comment">// 节点的acl权限列表</span></span><br><span class="line">                .withACL(acls)</span><br><span class="line">                <span class="comment">// arg1：节点路径，arg2：节点数据</span></span><br><span class="line">                .forPath(<span class="string">"/node2"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新增节点</span></span><br><span class="line">        client.create()</span><br><span class="line">                <span class="comment">// 递归创建</span></span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                <span class="comment">// 节点的类型</span></span><br><span class="line">                .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                <span class="comment">// 节点的acl权限列表</span></span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                <span class="comment">// arg1：节点路径，arg2：节点数据</span></span><br><span class="line">                .forPath(<span class="string">"/node2/nodex"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新增节点</span></span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        client.create()</span><br><span class="line"></span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                <span class="comment">// 节点的类型</span></span><br><span class="line">                .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                <span class="comment">// 节点的acl权限列表</span></span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                <span class="comment">// 异步</span></span><br><span class="line">                .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"异步创建成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// arg1：节点路径，arg2：节点数据</span></span><br><span class="line">                .forPath(<span class="string">"/node2/nodex"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点</span></span><br><span class="line">                .namespace(<span class="string">"create"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line"><span class="comment">//        create1();</span></span><br><span class="line"><span class="comment">//        create2();</span></span><br><span class="line"><span class="comment">//        create3();</span></span><br><span class="line">        create4();</span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">curatorGettingStart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 修改节点</span></span><br><span class="line">        client.setData()</span><br><span class="line">                <span class="comment">// 版本</span></span><br><span class="line">                .withVersion(-<span class="number">1</span>)</span><br><span class="line">                .forPath(<span class="string">"/hadoop"</span>,<span class="string">"hadoop1"</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 修改节点</span></span><br><span class="line">        client.setData()</span><br><span class="line">                .withVersion(<span class="number">1</span>)</span><br><span class="line">                .forPath(<span class="string">"/hadoop"</span>,<span class="string">"hadoop2"</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 修改节点</span></span><br><span class="line">        client.setData()</span><br><span class="line">                .withVersion(<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 异步</span></span><br><span class="line">                .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(curatorEvent.getType() == CuratorEventType.SET_DATA)</span><br><span class="line">                            System.out.println(curatorEvent.getPath()+ <span class="string">"    "</span> +curatorEvent.getType());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">"/hadoop"</span>,<span class="string">"hadoop3"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                .namespace(<span class="string">"update"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line"><span class="comment">//        set1();</span></span><br><span class="line">        set2();</span><br><span class="line"><span class="comment">//        set3();</span></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">curatorGettingStart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        client.delete()</span><br><span class="line">                .forPath(<span class="string">"node1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        client.delete()</span><br><span class="line">                <span class="comment">// 版本</span></span><br><span class="line">                .withVersion(<span class="number">1</span>)</span><br><span class="line">                .forPath(<span class="string">"node2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        client.delete()</span><br><span class="line">                <span class="comment">// 递归删除</span></span><br><span class="line">                .deletingChildrenIfNeeded()</span><br><span class="line">                .withVersion(-<span class="number">1</span>)</span><br><span class="line">                .forPath(<span class="string">"node3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        client.delete()</span><br><span class="line">                .withVersion(-<span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 异步</span></span><br><span class="line">                .inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (curatorEvent.getType() == CuratorEventType.DELETE)</span><br><span class="line">                            System.out.println(curatorEvent.getPath() + <span class="string">"    "</span> + curatorEvent.getType());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">"node3"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                .namespace(<span class="string">"delete"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//        delete1();</span></span><br><span class="line">        <span class="comment">//        delete2();</span></span><br><span class="line">        <span class="comment">//        delete3();</span></span><br><span class="line">        <span class="comment">// delete4();</span></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取节点"><a href="#读取节点" class="headerlink" title="读取节点"></a>读取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">curatorGettingStart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get1</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = client.getData()</span><br><span class="line">                .forPath(<span class="string">"/node"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String((bytes)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get2</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = client.getData()</span><br><span class="line">                .storingStatIn(stat)</span><br><span class="line">                .forPath(<span class="string">"/node"</span>);;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String((bytes)));</span><br><span class="line">        System.out.println(stat.getVersion());</span><br><span class="line">        System.out.println(stat.getCzxid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get3</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        client.getData()</span><br><span class="line">                .inBackground((CuratorFramework curatorFramework, CuratorEvent curatorEvent) -&gt; &#123;</span><br><span class="line">                    System.out.println(curatorEvent.getPath() + <span class="string">"  "</span> + curatorEvent.getType());</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">"/node"</span>);;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                .namespace(<span class="string">"get"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        get1();</span><br><span class="line">        get2();</span><br><span class="line">        get3();</span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取子节点"><a href="#读取子节点" class="headerlink" title="读取子节点"></a>读取子节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">curatorGettingStart</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChildren1</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        List&lt;String&gt; strings = client.getChildren()</span><br><span class="line">                .forPath(<span class="string">"/get"</span>);</span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getChildren2</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        client.getChildren()</span><br><span class="line">                .inBackground((curatorFramework, curatorEvent) -&gt; &#123;</span><br><span class="line">                    curatorEvent.getChildren().forEach(System.out::println);</span><br><span class="line">                    System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">"/get"</span>);</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line"><span class="comment">//                .namespace("get")</span></span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        getChildren1();</span><br><span class="line">        getChildren2();</span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatcherTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watcher1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 curator的客户端</span></span><br><span class="line">        <span class="comment">// arg2 监视的路径</span></span><br><span class="line">        NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, <span class="string">"/watcher"</span>);</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        nodeCache.start();</span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 节点变化时的回调方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 路径</span></span><br><span class="line">                System.out.println(nodeCache.getCurrentData().getPath() + <span class="string">"  "</span> + nodeCache.getCurrentData().getStat());</span><br><span class="line">                <span class="comment">// 输出节点内容</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"注册完成"</span>);</span><br><span class="line">        <span class="comment">// 时间窗内可以一直监听</span></span><br><span class="line">        <span class="comment">//        TimeUnit.SECONDS.sleep(1000);</span></span><br><span class="line">        <span class="comment">//关 闭</span></span><br><span class="line">        nodeCache.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">watcher2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// arg1 客户端</span></span><br><span class="line">        <span class="comment">// arg2 路径</span></span><br><span class="line">        <span class="comment">// arg3 事件钟是否可以获取节点数据</span></span><br><span class="line">        PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(client, <span class="string">"/watcher"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        pathChildrenCache.start();</span><br><span class="line">        pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 节点变化时的回调方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (pathChildrenCacheEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取子节点数据</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(pathChildrenCacheEvent.getData().getData()));</span><br><span class="line">                    <span class="comment">// 路径</span></span><br><span class="line">                    System.out.println(pathChildrenCacheEvent.getData().getPath());</span><br><span class="line">                    <span class="comment">// 事件类型</span></span><br><span class="line">                    System.out.println(pathChildrenCacheEvent.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 时间窗内可以一直监听</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//关 闭</span></span><br><span class="line">        pathChildrenCache.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                <span class="comment">//                .namespace("get")</span></span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        watcher1();</span></span><br><span class="line">        watcher2();</span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorTransaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">/*client.inTransaction()</span></span><br><span class="line"><span class="comment">                .create()</span></span><br><span class="line"><span class="comment">                    .withMode(CreateMode.PERSISTENT)</span></span><br><span class="line"><span class="comment">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span></span><br><span class="line"><span class="comment">                    .forPath("/transaction",new byte[0])</span></span><br><span class="line"><span class="comment">                .and()</span></span><br><span class="line"><span class="comment">                .setData()</span></span><br><span class="line"><span class="comment">                    .forPath("/setData/transaction",new byte[0])</span></span><br><span class="line"><span class="comment">                .and()</span></span><br><span class="line"><span class="comment">                .commit();*/</span></span><br><span class="line">        client.create()</span><br><span class="line">                .withMode(CreateMode.PERSISTENT)</span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                .forPath(<span class="string">"/transaction"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">        client.setData()</span><br><span class="line">                .forPath(<span class="string">"/setData/transaction"</span>,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                <span class="comment">//                .namespace("get")</span></span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        transaction();</span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁-1"><a href="#分布式锁-1" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul>
<li><code>InterProcessMutex</code>：分布式可重入排它锁</li>
<li><code>InterProcessReadWriteLock</code>：分布式读写锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorDistributeLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interProcessMutex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"排他锁"</span>);</span><br><span class="line">        <span class="comment">// 获取一个分布式排他锁</span></span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, <span class="string">"/lock1"</span>);</span><br><span class="line">        <span class="comment">// 开启两个进程测试，会发现：如果一个分布式排它锁获取了锁，那么直到锁释放为止数据都不会被侵扰</span></span><br><span class="line">        System.out.println(<span class="string">"获取锁中"</span>);</span><br><span class="line">        lock.acquire();</span><br><span class="line">        System.out.println(<span class="string">"操作中"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.release();</span><br><span class="line">        System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interProcessReadWriteLock1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"写锁"</span>);</span><br><span class="line">        <span class="comment">// 分布式读写锁</span></span><br><span class="line">        InterProcessReadWriteLock lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, <span class="string">"/lock1"</span>);</span><br><span class="line">        <span class="comment">// 开启两个进程测试，观察到写写互斥，特性同排它锁</span></span><br><span class="line">        System.out.println(<span class="string">"获取锁中"</span>);</span><br><span class="line">        lock.writeLock().acquire();</span><br><span class="line">        System.out.println(<span class="string">"操作中"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.writeLock().release();</span><br><span class="line">        System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">interProcessReadWriteLock2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"读锁"</span>);</span><br><span class="line">        <span class="comment">// 分布式读写锁</span></span><br><span class="line">        InterProcessReadWriteLock lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, <span class="string">"/lock1"</span>);</span><br><span class="line">        <span class="comment">// 开启两个进程测试，观察得到读读共享，两个进程并发进行，注意并发和并行是两个概念，(并发是线程启动时间段不一定一致，并行是时间轴一致的)</span></span><br><span class="line">        <span class="comment">// 再测试两个进程，一个读，一个写，也会出现互斥现象</span></span><br><span class="line">        System.out.println(<span class="string">"获取锁中"</span>);</span><br><span class="line">        lock.readLock().acquire();</span><br><span class="line">        System.out.println(<span class="string">"操作中"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.readLock().release();</span><br><span class="line">        System.out.println(<span class="string">"释放锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建，fluent风格</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                <span class="comment">// ip端口号</span></span><br><span class="line">                .connectString(<span class="string">"192.168.133.133:2181,192.168.133.133:2182,192.168.133.133:2183"</span>)</span><br><span class="line">                <span class="comment">// 会话超时</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// 重试机制，这里是超时后1000毫秒重试一次</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryOneTime(<span class="number">1000</span>))</span><br><span class="line">                <span class="comment">// 名称空间，在操作节点的时候，会以这个为父节点,可选操作</span></span><br><span class="line">                <span class="comment">//                .namespace("get")</span></span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="comment">//        interProcessMutex();</span></span><br><span class="line"><span class="comment">//                interProcessReadWriteLock1();</span></span><br><span class="line">        interProcessReadWriteLock2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(client.getState() + <span class="string">"操作完成"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四字监控命令-配置属性"><a href="#四字监控命令-配置属性" class="headerlink" title="四字监控命令/配置属性"></a>四字监控命令/配置属性</h3><p><code>zookeeper</code>文档——<code>administrator&#39;s Guide</code>——<a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkCommands" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_zkCommands</a> 四字命令</p>
<p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.14/zookeeperAdmin.html#sc_configuration</a> 配置属性</p>
<p><code>zookeeper</code>支持某些特定的四字命令与其的交互。它们大多数是查询命令，用来获取<code>zookeeper</code>服务的当前状态及相关信息。用户再客户端可以通过<code>telnet</code>或<code>nc</code>向<code>zookeeper</code>提交相应的命令。<code>zookeeper</code>常用四字命令见下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>conf</code></td>
<td>输出相关服务配置的详细信息。比如端口号、<code>zk</code>数据以及日志配置路径、最大连接数，<code>session</code>超时、<code>serverId</code>等</td>
</tr>
<tr>
<td><code>cons</code></td>
<td>列出所有连接到这台服务器的客户端连接/会话的详细信息。包括”接收/发送”的包数量、<code>sessionId</code>、操作延迟、最后的操作执行等信息</td>
</tr>
<tr>
<td><code>crst</code></td>
<td>重置当前这台服务器所有连接/会话的统计信息</td>
</tr>
<tr>
<td><code>dump</code></td>
<td>列出未经处理的会话和临时节点，这仅适用于领导者</td>
</tr>
<tr>
<td><code>envi</code></td>
<td>处理关于服务器的环境详细信息</td>
</tr>
<tr>
<td><code>ruok</code></td>
<td>测试服务是否处于正确运行状态。如果正常返回”<code>imok</code>“，否则返回空</td>
</tr>
<tr>
<td><code>stat</code></td>
<td>输出服务器的详细信息：接收/发送包数量、连接数、模式(<code>leader/follower</code>)、节点总数、延迟。所有客户端的列表</td>
</tr>
<tr>
<td><code>srst</code></td>
<td>重置<code>server</code>状态</td>
</tr>
<tr>
<td><code>wchs</code></td>
<td>列出服务器<code>watchers</code>的简洁信息：连接总数、<code>watching</code>节点总数和<code>watches</code>总数</td>
</tr>
<tr>
<td><code>wchc</code></td>
<td>通过session分组，列出watch的所有节点，它的输出是一个与<code>watch</code>相关的会话的节点信息，根据<code>watch</code>数量的不同，此操作可能会很昂贵（即影响服务器性能），请小心使用</td>
</tr>
<tr>
<td><code>mntr</code></td>
<td>列出集群的健康状态。包括”接收/发送”的包数量、操作延迟、当前服务模式(<code>leader/follower</code>)、节点总数、<code>watch</code>总数、临时节点总数</td>
</tr>
</tbody></table>
<p><strong>tclnet</strong></p>
<ul>
<li><code>yum install -y tclnet</code></li>
<li><code>tclnet 192.168.133.133 2181</code>(进入终端)<ul>
<li><code>mntr</code>(现在可以看到信息)</li>
</ul>
</li>
</ul>
<p><strong>nc</strong></p>
<ul>
<li><code>yum install -y nc</code><ul>
<li><code>echo mntr | nc 192.168.133.133:2181</code></li>
</ul>
</li>
</ul>
<h4 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h4><p>输出相关服务配置的详细信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>clientPort</code></td>
<td>客户端端口号</td>
</tr>
<tr>
<td><code>dataDir</code></td>
<td>数据快照文件目录，默认情况下<code>10w</code>次事务操作生成一次快照</td>
</tr>
<tr>
<td><code>dataLogDir</code></td>
<td>事务日志文件目录，生产环节中放再独立的磁盘上</td>
</tr>
<tr>
<td><code>tickTime</code></td>
<td>服务器之间或客户端与服务器之间维持心跳的时间间隔(以毫秒为单位)</td>
</tr>
<tr>
<td><code>maxClientCnxns</code></td>
<td>最大连接数</td>
</tr>
<tr>
<td><code>minSessionTimeout</code></td>
<td>最小<code>session</code>超时<code>minSessionTimeout=tickTime*2</code> ，即使客户端连接设置了会话超时，也不能打破这个限制</td>
</tr>
<tr>
<td><code>maxSessionTimeout</code></td>
<td>最大<code>session</code>超时<code>maxSessionTimeout=tickTime*20</code>，即使客户端连接设置了会话超时，也不能打破这个限制</td>
</tr>
<tr>
<td><code>serverId</code></td>
<td>服务器编号</td>
</tr>
<tr>
<td><code>initLimit</code></td>
<td>集群中<code>follower</code>服务器<code>(F)</code>与<code>leader</code>服务器<code>(L)</code>之间初始连接时能容忍的最多心跳数，实际上以<code>tickTime</code>为单位，换算为毫秒数</td>
</tr>
<tr>
<td><code>syncLimit</code></td>
<td>集群中<code>follower</code>服务器<code>(F)</code>与<code>leader</code>服务器<code>(L)</code>之间请求和应答之间能容忍的最大心跳数，实际上以<code>tickTime</code>为单位，换算为毫秒数</td>
</tr>
<tr>
<td><code>electionAlg</code></td>
<td>0：基于<code>UDP</code>的<code>LeaderElection</code>1：基于<code>UDP</code>的<code>FastLeaderElection</code>2：基于UDP和认证的<code>FastLeaderElection</code>3：基于<code>TCP</code>的<code>FastLeaderElection</code>在<code>3.4.10</code>版本中，默认值为3，另外三种算法以及被弃用，并且有计划在之后的版本中将它们彻底删除且不再支持</td>
</tr>
<tr>
<td><code>electionPort</code></td>
<td>选举端口</td>
</tr>
<tr>
<td><code>quorumPort</code></td>
<td>数据通信端口</td>
</tr>
<tr>
<td><code>peerType</code></td>
<td>是否为观察者 1为观察者</td>
</tr>
</tbody></table>
<h4 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h4><p>列出所有连接到这台服务器的客户端连接/会话的详细信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ip</code></td>
<td>IP地址</td>
</tr>
<tr>
<td><code>port</code></td>
<td>端口号</td>
</tr>
<tr>
<td><code>queued</code></td>
<td>等待被处理的请求数，请求缓存在队列中</td>
</tr>
<tr>
<td><code>received</code></td>
<td>收到的包数</td>
</tr>
<tr>
<td><code>sent</code></td>
<td>发送的包数</td>
</tr>
<tr>
<td><code>sid</code></td>
<td>会话id</td>
</tr>
<tr>
<td><code>lop</code></td>
<td>最后的操作 GETD-读取数据 DELE-删除数据 CREA-创建数据</td>
</tr>
<tr>
<td><code>est</code></td>
<td>连接时间戳</td>
</tr>
<tr>
<td><code>to</code></td>
<td>超时时间</td>
</tr>
<tr>
<td><code>lcxid</code></td>
<td>当前会话的操作id</td>
</tr>
<tr>
<td><code>lzxid</code></td>
<td>最大事务id</td>
</tr>
<tr>
<td><code>lresp</code></td>
<td>最后响应时间戳</td>
</tr>
<tr>
<td><code>llat</code></td>
<td>最后/最新 延迟</td>
</tr>
<tr>
<td><code>minlat</code></td>
<td>最小延时</td>
</tr>
<tr>
<td><code>maxlat</code></td>
<td>最大延时</td>
</tr>
<tr>
<td><code>avglat</code></td>
<td>平均延时</td>
</tr>
</tbody></table>
<h4 id="crst"><a href="#crst" class="headerlink" title="crst"></a>crst</h4><p>重置当前这台服务器所有连接/会话的统计信息</p>
<h4 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h4><p>列出临时节点信息，适用于<code>leader</code></p>
<h4 id="envi"><a href="#envi" class="headerlink" title="envi"></a>envi</h4><p>输出关于服务器的环境详细信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>zookeeper.version</code></td>
<td>版本</td>
</tr>
<tr>
<td><code>host.name</code></td>
<td><code>host</code>信息</td>
</tr>
<tr>
<td><code>java.version</code></td>
<td><code>java</code>版本</td>
</tr>
<tr>
<td><code>java.vendor</code></td>
<td>供应商</td>
</tr>
<tr>
<td><code>java.home</code></td>
<td>运行环境所在目录</td>
</tr>
<tr>
<td><code>java.class.path</code></td>
<td><code>classpath</code></td>
</tr>
<tr>
<td><code>java.library.path</code></td>
<td>第三方库指定非Java类包的为止(如：dll，so)</td>
</tr>
<tr>
<td><code>java.io.tmpdir</code></td>
<td>默认的临时文件路径</td>
</tr>
<tr>
<td><code>java.compiler</code></td>
<td><code>JIT</code>编辑器的名称</td>
</tr>
<tr>
<td><code>os.name</code></td>
<td><code>Linux</code></td>
</tr>
<tr>
<td><code>os.arch</code></td>
<td><code>amd64</code></td>
</tr>
<tr>
<td><code>os.version</code></td>
<td><code>3.10.0-1062.el7.x86_64</code></td>
</tr>
<tr>
<td><code>user.name</code></td>
<td><code>zookeeper</code></td>
</tr>
<tr>
<td><code>user.home</code></td>
<td><code>/opt/zookeeper</code></td>
</tr>
<tr>
<td><code>user.dir</code></td>
<td><code>/opt/zookeeper/zookeeper2181/bin</code></td>
</tr>
</tbody></table>
<h4 id="ruok"><a href="#ruok" class="headerlink" title="ruok"></a>ruok</h4><p>测试服务是否处于正确运行状态，如果目标正确运行会返回imok（are you ok | I’m ok）</p>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>输出服务器的详细信息与<code>srvr</code>相似(<code>srvr</code>这里不举例了，官网有一点描述)，但是多了每个连接的会话信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>zookeeper version</code></td>
<td>版本</td>
</tr>
<tr>
<td><code>Latency min/avg/max</code></td>
<td>延时</td>
</tr>
<tr>
<td><code>Received</code></td>
<td>收包</td>
</tr>
<tr>
<td><code>Sent</code></td>
<td>发包</td>
</tr>
<tr>
<td><code>Connections</code></td>
<td>当前服务器连接数</td>
</tr>
<tr>
<td><code>Outstanding</code></td>
<td>服务器堆积的未处理请求数</td>
</tr>
<tr>
<td><code>Zxid</code></td>
<td>最大事务<code>id</code></td>
</tr>
<tr>
<td><code>Mode</code></td>
<td>服务器角色</td>
</tr>
<tr>
<td><code>Node count</code></td>
<td>节点数</td>
</tr>
</tbody></table>
<h4 id="srst"><a href="#srst" class="headerlink" title="srst"></a>srst</h4><p>重置<code>server</code>状态</p>
<h4 id="wchs"><a href="#wchs" class="headerlink" title="wchs"></a>wchs</h4><p>列出服务器<code>watches</code>的简洁信息</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>connectsions</code></td>
<td>连接数</td>
</tr>
<tr>
<td><code>watch-paths</code></td>
<td><code>watch</code>节点数</td>
</tr>
<tr>
<td><code>watchers</code></td>
<td><code>watcher</code>数量</td>
</tr>
</tbody></table>
<h4 id="wchc"><a href="#wchc" class="headerlink" title="wchc"></a>wchc</h4><p>通过<code>session</code>分组，列出<code>watch</code>的所有节点，它的输出是一个与<code>watch</code>相关的会话的节点列表</p>
<p>问题</p>
<p><code>wchc is not executed because it is not in the whitelist</code></p>
<p>解决办法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改启动指令zkServer.sh</span></span><br><span class="line"><span class="comment"># 注意找到这个信息</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"JMX disabled by user request"</span> &gt;&amp;2</span><br><span class="line">	ZOOMAIN=<span class="string">"org.apache.zookeeper.server.quorum.QuorumPeerMain"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 下面添加如下信息</span></span><br><span class="line">ZOOMAIN=<span class="string">"-Dzookeeper.4lw.commands.whitelist=* <span class="variable">$&#123;ZOOMAIN&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<p>每一个客户端的连接的<code>watcher</code>信息都会被收集起来，并且监控的路径都会被展示出来（代价高，消耗性能）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# echo wchc | nc 192.168.133.133 2180</span><br><span class="line">0x171be6c6faf0000</span><br><span class="line">        /node2</span><br><span class="line">        /node1</span><br><span class="line">0x171be6c6faf0001</span><br><span class="line">        /node3</span><br></pre></td></tr></table></figure>

<h4 id="wchp"><a href="#wchp" class="headerlink" title="wchp"></a>wchp</h4><p>通过路径分组，列出所有的<code>watch</code>的<code>session id</code> 信息</p>
<p>配置同<code>wchc</code></p>
<h4 id="mntr"><a href="#mntr" class="headerlink" title="mntr"></a>mntr</h4><p>列出服务器的健康状态</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>zk_version</code></td>
<td>版本</td>
</tr>
<tr>
<td><code>zk_avg_latency</code></td>
<td>平均延时</td>
</tr>
<tr>
<td><code>zk_max_latency</code></td>
<td>最大延时</td>
</tr>
<tr>
<td><code>zk_min_latency</code></td>
<td>最小延时</td>
</tr>
<tr>
<td><code>zk_packets_received</code></td>
<td>收包数</td>
</tr>
<tr>
<td><code>zk_packets_sent</code></td>
<td>发包数</td>
</tr>
<tr>
<td><code>zk_num_alive_connections</code></td>
<td>连接数</td>
</tr>
<tr>
<td><code>zk_outstanding_requests</code></td>
<td>堆积请求数</td>
</tr>
<tr>
<td><code>zk_server_state</code></td>
<td><code>leader/follower</code>状态</td>
</tr>
<tr>
<td><code>zk_znode_count</code></td>
<td><code>znode</code>数量</td>
</tr>
<tr>
<td><code>zk_watch_count</code></td>
<td><code>watch</code>数量</td>
</tr>
<tr>
<td><code>zk_ephemerals_count</code></td>
<td>l临时节点<code>(znode)</code></td>
</tr>
<tr>
<td><code>zk_approximate_data_size</code></td>
<td>数据大小</td>
</tr>
<tr>
<td><code>zk_open_file_descriptor_count</code></td>
<td>打开的文件描述符数量</td>
</tr>
<tr>
<td><code>zk_max_file_descriptor_count</code></td>
<td>最大文件描述符数量</td>
</tr>
</tbody></table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/03/IO-操作系统IO模型/">IO模型-Linux操作系统中的IO模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/IO/">IO</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IO/">IO</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><blockquote>
<p><a href="https://blog.csdn.net/m0_73257876/article/details/126403791" target="_blank" rel="noopener">https://blog.csdn.net/m0_73257876/article/details/126403791</a></p>
<p><a href="https://juejin.cn/post/7136110312440201223" target="_blank" rel="noopener">https://juejin.cn/post/7136110312440201223</a></p>
</blockquote>
<h3 id="五种模型"><a href="#五种模型" class="headerlink" title="五种模型"></a>五种模型</h3><p>对于一个套接字上的输入操作，第一步是等待数据从网络中到达，当数据到达时被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</p>
<p>Linux 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<p>五种模型对比：</p>
<ul>
<li>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段，非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞</li>
</ul>
<ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞</li>
<li>异步 I/O：第二阶段应用进程不会阻塞</li>
</ul>
<h4 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h4><p>应用进程通过系统调用 recvfrom 接收数据，会被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。阻塞不意味着整个操作系统都被阻塞，其它应用进程还可以执行，只是当前阻塞进程不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</p>
<p>recvfrom() 用于<strong>接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</strong>，把 recvfrom() 当成系统调用</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt></p>
<h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好数据，内核返回一个错误码，过一段时间应用进程再执行 recvfrom 系统调用，在两次发送请求的时间段，进程可以进行其他任务，这种方式称为轮询（polling）</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png" alt></p>
<h4 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，等待数据阶段应用进程是非阻塞的。当内核数据准备就绪时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png" alt></p>
<h4 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h4><p>IO 复用模型使用 select 或者 poll 函数等待数据，select 会监听所有注册好的 IO，<strong>等待多个套接字中的任何一个变为可读</strong>，等待过程会被阻塞，当某个套接字准备好数据变为可读时 select 调用就返回，然后调用 recvfrom 把数据从内核复制到进程中</p>
<p>IO 复用让单个进程具有处理多个 I/O 事件的能力，又被称为 Event Driven I/O，即<strong>事件驱动 I/O</strong></p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都要创建一个线程去处理，如果同时有几万个连接，就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt></p>
<h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><p>应用进程执行 aio_read 系统调用会立即返回，给内核传递描述符、缓冲区指针、缓冲区大小等。应用进程可以继续执行不会被阻塞，内核会在所有操作完成之后向应用进程发送信号</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png" alt></p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>Socket 不是文件，只是一个标识符，但是 Unix 操作系统把所有东西都<strong>看作</strong>是文件，所以 Socket 说成 file descriptor，也就是 fd</p>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd_set 使用 <strong>bitmap 数组</strong>实现，数组大小用 FD_SETSIZE 定义，<strong>单进程</strong>只能监听少于 FD_SETSIZE 数量的描述符，32 位机默认是 1024 个，64 位机默认是 2048，可以对进行修改，然后重新编译内核</p>
</li>
<li><p>fd_set 有三种类型的描述符：readset、writeset、exceptset，对应读、写、异常条件的描述符集合</p>
</li>
<li><p>n 是监测的 socket 的最大数量</p>
</li>
<li><p>timeout 为超时参数，调用 select 会一直<strong>阻塞</strong>直到有描述符的事件到达或者等待的时间超过 timeout</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec; 	<span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;	<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout == null：等待无限长的时间</li>
<li>tv_sec == 0 &amp;&amp; tv_usec == 0：获取后直接返回，不阻塞等待</li>
<li>tv_sec != 0 || tv_usec != 0：等待指定时间</li>
</ul>
</li>
<li><p>方法成功调用返回结果为<strong>就绪的文件描述符个数</strong>，出错返回结果为 -1，超时返回结果为 0</p>
</li>
</ul>
<p>Linux 提供了一组宏为 fd_set 进行赋值操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;			<span class="comment">// 将一个 fd_set 类型变量的所有值都置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">// 判断 fd 位是否被置为 1</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));<span class="comment">//绑定连接</span></span><br><span class="line">listen(sockfd, <span class="number">5</span>);<span class="comment">//监听5个端口</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;client, e, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">	fds[i] = accept(sockfd, (struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="comment">//将监听的对应的文件描述符fd存入fds：[3,4,5,6,7]</span></span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">		max = fds[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;rset);<span class="comment">//置为0</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    	FD_SET(fds[i], &amp;rset);<span class="comment">//对应位置1 [0001 1111 00.....]</span></span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">"round again"</span>);</span><br><span class="line">	select(max + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//监听</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset)) &#123;<span class="comment">//判断监听哪一个端口</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">            read(fds[i], buffer, MAXBUF);<span class="comment">//进入内核态读数据</span></span><br><span class="line">            print(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>select 调用流程图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-select%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt></p>
<ol>
<li>使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间，进程阻塞</li>
<li>注册回调函数 _pollwait</li>
<li>遍历所有 fd，调用其对应的 poll 方法判断当前请求是否准备就绪，对于 socket，这个 poll 方法是 sock_poll，sock_poll 根据情况会调用到 tcp_poll、udp_poll 或者 datagram_poll，以 tcp_poll 为例，其核心实现就是 _pollwait</li>
<li>_pollwait 把 <strong>current（调用 select 的进程）</strong>挂到设备的等待队列，不同设备有不同的等待队列，对于 tcp_poll ，其等待队列是 sk → sk_sleep（把进程挂到等待队列中并不代表进程已经睡眠），在设备收到消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒，进入就绪队列</li>
<li>poll 方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值</li>
<li>如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout 让 current 进程进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程，如果超过一定的超时时间（schedule_timeout）没有其他线程唤醒，则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd</li>
<li>把 fd_set 从内核空间拷贝到用户空间，阻塞进程继续执行</li>
</ol>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<p>其他流程图：<a href="https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1" target="_blank" rel="noopener">https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1</a></p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>select 和 poll 对比：</p>
<ul>
<li>select 会修改描述符，而 poll 不会</li>
<li>select 的描述符类型使用数组实现，有描述符的限制；而 poll 使用<strong>链表</strong>实现，没有描述符数量的限制</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高</li>
</ul>
<ul>
<li>select 和 poll 速度都比较慢，<strong>每次调用</strong>都需要将全部描述符数组 fd 从应用进程缓冲区复制到内核缓冲区，同时每次都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时会很大</li>
<li>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll</li>
<li>select 和 poll 的时间复杂度 O(n)，对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低，因为并不知道具体是哪个 socket 具有事件，所以随着 fd 数量的增加会造成遍历速度慢的<strong>线性下降</strong>性能问题</li>
<li>poll 还有一个特点是水平触发，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>epoll 使用事件的就绪通知方式，通过 epoll_ctl() 向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，一旦该 fd 就绪，<strong>内核通过 callback 回调函数将 I/O 准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件就绪的描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>epall_create：一个系统函数，函数将在内核空间内创建一个 epoll 数据结构，可以理解为 epoll 结构空间，返回值为 epoll 的文件描述符编号，以后有 client 连接时，向该 epoll 结构中添加监听，所以 epoll 使用一个文件描述符管理多个描述符</p>
</li>
<li><p>epall_ctl：epoll 的事件注册函数，select 函数是调用时指定需要监听的描述符和事件，epoll 先将用户感兴趣的描述符事件注册到 epoll 空间。此函数是非阻塞函数，用来增删改 epoll 空间内的描述符，参数解释：</p>
<ul>
<li><p>epfd：epoll 结构的进程 fd 编号，函数将依靠该编号找到对应的 epoll 结构</p>
</li>
<li><p>op：表示当前请求类型，有三个宏定义：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中</li>
<li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li>
<li>EPOLL_CTI_DEL：从 epfd 中删除一个 fd</li>
</ul>
</li>
<li><p>fd：需要监听的文件描述符，一般指 socket_fd</p>
</li>
<li><p>event：告诉内核对该 fd 资源感兴趣的事件，epoll_event 的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">_uint32_t</span> events;	<span class="comment">/*epoll events*/</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">/*user data variable*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events 可以是以下几个宏集合：EPOLLIN、EPOLOUT、EPOLLPRI、EPOLLERR、EPOLLHUP（挂断）、EPOLET（边缘触发）、EPOLLONESHOT（只监听一次，事件触发后自动清除该 fd，从 epoll 列表）</p>
</li>
</ul>
</li>
<li><p>epoll_wait：等待事件的产生，类似于 select() 调用，返回值为本次就绪的 fd 个数，直接从就绪链表获取，时间复杂度 O(1)</p>
<ul>
<li>epfd：<strong>指定感兴趣的 epoll 事件列表</strong></li>
<li>events：指向一个 epoll_event 结构数组，当函数返回时，内核会把就绪状态的数据拷贝到该数组</li>
<li>maxevents：标明 epoll_event 数组最多能接收的数据量，即本次操作最多能获取多少就绪数据</li>
<li>timeout：单位为毫秒<ul>
<li>0：表示立即返回，非阻塞调用</li>
<li>-1：阻塞调用，直到有用户感兴趣的事件就绪为止</li>
<li>大于 0：阻塞调用，阻塞指定时间内如果有事件就绪则提前返回，否则等待指定时间后返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）：</p>
<ul>
<li>LT 模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程，是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</li>
<li>ET 模式：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高；只支持 No-Blocking，以避免由于一个 fd 的阻塞读/阻塞写操作把处理多个文件描述符的任务饥饿</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll 描述符，每个应用程序只需要一个，用于监控所有套接字</span></span><br><span class="line"><span class="keyword">int</span> pollingfd = epoll_create(<span class="number">0xCAFE</span>);</span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )<span class="comment">// report error</span></span><br><span class="line"><span class="comment">// 初始化 epoll 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连接类实例与事件相关联，可以关联任何想要的东西</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视输入，并且在事件发生后不自动重新准备描述符</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// 将描述符添加到监控列表中，即使另一个线程在epoll_wait中等待，描述符将被正确添加</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多等待 20 个事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[20];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待10秒，检索20个并存入epoll_event数组</span></span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait(pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">// 检查epoll是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span>)<span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span>)<span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready; i+ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取连接指针</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：<a href="https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" target="_blank" rel="noopener">https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>epoll 的特点：</p>
<ul>
<li><p>epoll 仅适用于 Linux 系统</p>
</li>
<li><p>epoll 使用<strong>一个文件描述符管理多个描述符</strong>，将用户关心的文件描述符的事件存放到内核的一个事件表（个人理解成哑元节点）</p>
</li>
<li><p>没有最大描述符数量（并发连接）的限制，打开 fd 的上限远大于1024（1G 内存能监听约 10 万个端口）</p>
</li>
<li><p>epoll 的时间复杂度 O(1)，epoll 理解为 event poll，不同于忙轮询和无差别轮询，调用 epoll_wait <strong>只是轮询就绪链表</strong>。当监听列表有设备就绪时调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait 中阻塞的进程，所以 epoll 实际上是<strong>事件驱动</strong>（每个事件关联上fd）的，降低了 system call 的时间复杂度</p>
</li>
<li><p>epoll 内核中根据每个 fd 上的 callback 函数来实现，只有活跃的 socket 才会主动调用 callback，所以使用 epoll 没有前面两者的线性下降的性能问题，效率提高</p>
</li>
<li><p>epoll 注册新的事件是注册到到内核中 epoll 句柄中，不需要每次调用 epoll_wait 时重复拷贝，对比前面两种只需要将描述符从进程缓冲区向内核缓冲区<strong>拷贝一次</strong>，也可以利用 <strong>mmap() 文件映射内存</strong>加速与内核空间的消息传递（只是可以用，并没有用）</p>
</li>
<li><p>前面两者要把 current 往设备等待队列中挂一次，epoll 也只把 current 往等待队列上挂一次，但是这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列，这样可以节省开销</p>
</li>
<li><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符，也不会产生像 select 和 poll 的不确定情况</p>
</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd940e7fca2</a></p>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html" target="_blank" rel="noopener">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用场景： </p>
<ul>
<li><p>select 应用场景：</p>
<ul>
<li>select 的 timeout 参数精度为微秒，poll 和 epoll 为毫秒，因此 select 适用<strong>实时性要求比较高</strong>的场景，比如核反应堆的控制</li>
<li>select 可移植性更好，几乎被所有主流平台所支持</li>
</ul>
</li>
<li><p>poll 应用场景：poll 没有最大描述符数量的限制，适用于平台支持并且对实时性要求不高的情况</p>
</li>
<li><p>epoll 应用场景：</p>
<ul>
<li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是<strong>长连接</strong></li>
<li>需要同时监控小于 1000 个描述符，没必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势</li>
<li>需要监控的描述符状态变化多，而且是非常短暂的，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，每次对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率，并且 epoll 的描述符存储在内核，不容易调试</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h4><p>用户空间：用户代码、用户堆栈</p>
<p>内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info 进程描述符）</p>
<ul>
<li>进程描述符和用户的进程是一一对应的</li>
<li>SYS_API 系统调用：如 read、write，系统调用就是 0X80 中断</li>
<li>进程描述符 pd：进程从用户态切换到内核态时，需要<strong>保存用户态时的上下文信息在 PCB 中</strong></li>
<li>线程上下文：用户程序基地址，程序计数器、cpu cache、寄存器等，方便程序切回用户态时恢复现场</li>
<li>内核堆栈：<strong>系统调用函数也是要创建变量的，</strong>这些变量在内核堆栈上分配</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png" alt></p>
<h4 id="80中断"><a href="#80中断" class="headerlink" title="80中断"></a>80中断</h4><p>在用户程序中调用操作系统提供的核心态级别的子功能，为了系统安全需要进行用户态和内核态转换，状态的转换需要进行 CPU 中断，中断分为硬中断和软中断：</p>
<ul>
<li>硬中断：如网络传输中，数据到达网卡后，网卡经过一系列操作后发起硬件中断</li>
<li>软中断：如程序运行过程中本身产生的一些中断<ul>
<li>发起 <code>0X80</code> 中断</li>
<li>程序执行碰到除 0 异常</li>
</ul>
</li>
</ul>
<p>系统调用 system_call 函数所对应的中断指令编号是 0X80（十进制是 8×16=128），而该指令编号对应的就是系统调用程序的入口，所以称系统调用为 80 中断</p>
<p>系统调用的流程：</p>
<ul>
<li>在 CPU 寄存器里存一个系统调用号，表示哪个系统函数，比如 read</li>
<li>将 CPU 的临时数据都保存到 thread_info 中</li>
<li>执行 80 中断处理程序，找到刚刚存的系统调用号（read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间</li>
<li>最后恢复到用户态，通过 thread_info 恢复现场，用户态继续执行</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797" target="_blank" rel="noopener">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA (Direct Memory Access) ：直接存储器访问，让外部设备不通过 CPU 直接与系统内存交换数据的接口技术</p>
<p>作用：可以解决批量数据的输入/输出问题，使数据的传送速度取决于存储器和外设的工作速度</p>
<p>把内存数据传输到网卡然后发送：</p>
<ul>
<li>没有 DMA：CPU 读内存数据到 CPU 高速缓存，再写到网卡，这样就把 CPU 的速度拉低到和网卡一个速度</li>
<li>使用 DMA：把数据读到 Socket 内核缓存区（CPU 复制），CPU 分配给 DMA 开始<strong>异步</strong>操作，DMA 读取 Socket 缓冲区到 DMA 缓冲区，然后写到网卡。DMA 执行完后<strong>中断</strong>（就是通知） CPU，这时 Socket 内核缓冲区为空，CPU 从用户态切换到内核态，执行中断处理程序，将需要使用 Socket 缓冲区的阻塞进程移到就绪队列</li>
</ul>
<p>一个完整的 DMA 传输过程必须经历 DMA 请求、DMA 响应、DMA 传输、DMA 结束四个步骤：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-DMA.png" style="zoom: 50%;">

<p>DMA 方式是一种完全由硬件进行信息传送的控制方式，通常系统总线由 CPU 管理，在 DMA 方式中，CPU 的主存控制信号被禁止使用，CPU 把总线（地址总线、数据总线、控制总线）让出来由 DMA 控制器接管，用来控制传送的字节数、判断 DMA 是否结束、以及发出 DMA 结束信号，所以 DMA 控制器必须有以下功能：</p>
<ul>
<li>接受外设发出的 DMA 请求，并向 CPU 发出总线接管请求</li>
<li>当 CPU 发出允许接管信号后，进入 DMA 操作周期</li>
<li>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数</li>
<li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li>
<li>判断 DMA 传送是否结束，发出 DMA 结束信号，使 CPU 恢复正常工作状态（中断）</li>
</ul>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>传统的 I/O 操作进行了 4 次用户空间与内核空间的上下文切换，以及 4 次数据拷贝：</p>
<ul>
<li>JVM 发出 read 系统调用，OS 上下文切换到内核模式（切换 1）并将数据从网卡或硬盘等设备通过 DMA 读取到内核空间缓冲区（拷贝 1），内核缓冲区实际上是<strong>磁盘高速缓存（PageCache）</strong></li>
<li>OS 内核将数据复制到用户空间缓冲区（拷贝 2），然后 read 系统调用返回，又会导致一次内核空间到用户空间的上下文切换（切换 2）</li>
<li>JVM 处理代码逻辑并发送 write() 系统调用，OS 上下文切换到内核模式（切换3）并从用户空间缓冲区复制数据到内核空间缓冲区（拷贝3）</li>
<li>将内核空间缓冲区中的数据写到 hardware（拷贝4），write 系统调用返回，导致内核空间到用户空间的再次上下文切换（切换4）</li>
</ul>
<p>流程图中的箭头反过来也成立，可以从网卡获取数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-BIO%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>read 调用图示：read、write 都是系统调用指令</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-缓冲区读写.png" style="zoom: 67%;">


<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（Memory Mapped Files）内存映射加 write 实现零拷贝，<strong>零拷贝就是没有数据从内核空间复制到用户空间</strong></p>
<p>用户空间和内核空间都使用内存，所以可以共享同一块物理内存地址，省去用户态和内核态之间的拷贝。写网卡时，共享空间的内容拷贝到 Socket 缓冲区，然后交给 DMA 发送到网卡，只需要 3 次复制</p>
<p>进行了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（2 次 DMA，一次 CPU 复制）：</p>
<ul>
<li>发出 mmap 系统调用，DMA 拷贝到内核缓冲区，映射到共享缓冲区；mmap 系统调用返回，无需拷贝</li>
<li>发出 write 系统调用，将数据从内核缓冲区拷贝到内核 Socket 缓冲区；write 系统调用返回，DMA 将内核空间 Socket 缓冲区中的数据传递到协议引擎</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-mmap%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>原理：利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射后对物理内存的操作会<strong>被同步</strong>到硬盘上</p>
<p>缺点：不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘</p>
<p>Java NIO 提供了 <strong>MappedByteBuffer</strong> 类可以用来实现 mmap 内存映射，MappedByteBuffer 类对象<strong>只能通过调用 <code>FileChannel.map()</code> 获取</strong></p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile 实现零拷贝，打开文件的文件描述符 fd 和 socket 的 fd 传递给 sendfile，然后经过 3 次复制和 2 次用户态和内核态的切换</p>
<p>原理：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，由于和用户态完全无关，就减少了两次上下文切换</p>
<p>说明：零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-sendfile%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>sendfile2.4 之后，sendfile 实现了更简单的方式，文件到达内核缓冲区后，不必再将数据全部复制到 socket buffer 缓冲区，而是只<strong>将记录数据位置和长度相关等描述符信息</strong>保存到 socket buffer，DMA 根据 Socket 缓冲区中描述符提供的位置和偏移量信息直接将内核空间缓冲区中的数据拷贝到协议引擎上（2 次复制 2 次切换）</p>
<p>Java NIO 对 sendfile 的支持是 <code>FileChannel.transferTo()/transferFrom()</code>，把磁盘文件读取 OS 内核缓冲区后的 fileChannel，直接转给 socketChannel 发送，底层就是 sendfile</p>
<p>参考文章：<a href="https://blog.csdn.net/hancoder/article/details/112149121" target="_blank" rel="noopener">https://blog.csdn.net/hancoder/article/details/112149121</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/75/">75</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.328888.xyz/2022/12/21/ARudF.png)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2023 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>